<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Experimental algorithms · Graphs.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://gdalle.github.io/Graphs.jl/advanced/experimental/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Graphs.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Graphs.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><input class="collapse-toggle" id="menuitem-1" type="checkbox"/><label class="tocitem" for="menuitem-1"><span class="docs-label">First steps</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../">Graphs.jl</a></li><li><a class="tocitem" href="../../first_steps/theory/">Basics of graph theory</a></li><li><a class="tocitem" href="../../first_steps/construction/">Graph construction</a></li><li><a class="tocitem" href="../../first_steps/access/">Graph access</a></li><li><a class="tocitem" href="../../first_steps/paths_traversal/">Paths and traversal</a></li><li><a class="tocitem" href="../../first_steps/plotting/">Graph plotting</a></li><li><a class="tocitem" href="../../first_steps/persistence/">Reading and writing graphs</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Ecosystem</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../ecosystem/graphtypes/">Graph types</a></li><li><a class="tocitem" href="../../ecosystem/interface/">Creating your own graph format</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Core API</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../core_functions/core/">Core functions</a></li><li><a class="tocitem" href="../../core_functions/interface/">AbstractGraph interface</a></li><li><a class="tocitem" href="../../core_functions/module/">Module</a></li><li><a class="tocitem" href="../../core_functions/operators/">Operators</a></li><li><a class="tocitem" href="../../core_functions/persistence/">Reading and writing files</a></li><li><a class="tocitem" href="../../core_functions/simplegraphs_generators/">Generators for common graphs</a></li><li><a class="tocitem" href="../../core_functions/simplegraphs/">SimpleGraphs formats</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Algorithms API</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../algorithms/biconnectivity/">Biconnected graphs</a></li><li><a class="tocitem" href="../../algorithms/centrality/">Centrality measures</a></li><li><a class="tocitem" href="../../algorithms/community/">Community structures</a></li><li><a class="tocitem" href="../../algorithms/connectivity/">Connected components</a></li><li><a class="tocitem" href="../../algorithms/cut/">Cuts</a></li><li><a class="tocitem" href="../../algorithms/cycles/">Cycles</a></li><li><a class="tocitem" href="../../algorithms/trees/">Trees</a></li><li><a class="tocitem" href="../../algorithms/degeneracy/">Degeneracy</a></li><li><a class="tocitem" href="../../algorithms/digraph/">Directed graphs</a></li><li><a class="tocitem" href="../../algorithms/distance/">Distance</a></li><li><a class="tocitem" href="../../algorithms/dominatingset/">Dominating sets</a></li><li><a class="tocitem" href="../../algorithms/editdist/">Edit distance</a></li><li><a class="tocitem" href="../../algorithms/independentset/">Independent sets</a></li><li><a class="tocitem" href="../../algorithms/linalg/">Linear algebra</a></li><li><a class="tocitem" href="../../algorithms/shortestpaths/">Shortest paths</a></li><li><a class="tocitem" href="../../algorithms/spanningtrees/">Spanning trees</a></li><li><a class="tocitem" href="../../algorithms/steinertree/">Steiner tree</a></li><li><a class="tocitem" href="../../algorithms/traversals/">Traversals and coloring</a></li><li><a class="tocitem" href="../../algorithms/utils/">Utilities</a></li><li><a class="tocitem" href="../../algorithms/vertexcover/">Vertex cover</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox" checked/><label class="tocitem" for="menuitem-5"><span class="docs-label">For advanced users</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../errorhandling/">Error handling</a></li><li class="is-active"><a class="tocitem" href>Experimental algorithms</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Full-docs"><span>Full docs</span></a></li></ul></li><li><a class="tocitem" href="../parallel/">Parallel algorithms</a></li><li><a class="tocitem" href="../../contributing/">Contributor Guide</a></li><li><a class="tocitem" href="../../license/">License information</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">For advanced users</a></li><li class="is-active"><a href>Experimental algorithms</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Experimental algorithms</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaGraphs/Graphs.jl/blob/master/docs/src/advanced/experimental.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Experimental-algorithms"><a class="docs-heading-anchor" href="#Experimental-algorithms">Experimental algorithms</a><a id="Experimental-algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Experimental-algorithms" title="Permalink"></a></h1><p><code>Graphs.Experimental</code> is a module for graph algorithms that are newer or less stable. We can adopt algorithms before we finalize an interface for using them or if we feel that full support cannot be provided to the current implementation. You can expect new developments to land here before they make it into the main module. This enables the development to keep advancing without being risk-averse because of stability guarantees. You can think of this module as a 0.X semantic version space ; it is a place where you can play around with new algorithms, perspectives, and interfaces without fear of breaking critical code.</p><p><strong>A Note To Users</strong></p><p>Code in this module is unstable and subject to change. Do not use any code in this module in production environments without understanding the (large) risks involved. However, we welcome bug reports and issues via the normal channels..</p><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#Graphs.Experimental.IsomorphismAlgorithm"><code>Graphs.Experimental.IsomorphismAlgorithm</code></a></li><li><a href="#Graphs.Experimental.ShortestPaths.AStar"><code>Graphs.Experimental.ShortestPaths.AStar</code></a></li><li><a href="#Graphs.Experimental.ShortestPaths.BFS"><code>Graphs.Experimental.ShortestPaths.BFS</code></a></li><li><a href="#Graphs.Experimental.ShortestPaths.BellmanFord"><code>Graphs.Experimental.ShortestPaths.BellmanFord</code></a></li><li><a href="#Graphs.Experimental.ShortestPaths.DEsopoPape"><code>Graphs.Experimental.ShortestPaths.DEsopoPape</code></a></li><li><a href="#Graphs.Experimental.ShortestPaths.Dijkstra"><code>Graphs.Experimental.ShortestPaths.Dijkstra</code></a></li><li><a href="#Graphs.Experimental.ShortestPaths.FloydWarshall"><code>Graphs.Experimental.ShortestPaths.FloydWarshall</code></a></li><li><a href="#Graphs.Experimental.ShortestPaths.Johnson"><code>Graphs.Experimental.ShortestPaths.Johnson</code></a></li><li><a href="#Graphs.Experimental.ShortestPaths.SPFA"><code>Graphs.Experimental.ShortestPaths.SPFA</code></a></li><li><a href="#Graphs.Experimental.ShortestPaths.ShortestPathAlgorithm"><code>Graphs.Experimental.ShortestPaths.ShortestPathAlgorithm</code></a></li><li><a href="#Graphs.Experimental.ShortestPaths.ShortestPathResult"><code>Graphs.Experimental.ShortestPaths.ShortestPathResult</code></a></li><li><a href="#Graphs.Experimental.Traversals.AbstractTraversalState"><code>Graphs.Experimental.Traversals.AbstractTraversalState</code></a></li><li><a href="#Graphs.Experimental.Traversals.TraversalAlgorithm"><code>Graphs.Experimental.Traversals.TraversalAlgorithm</code></a></li><li><a href="#Graphs.Experimental.VF2"><code>Graphs.Experimental.VF2</code></a></li><li><a href="#Graphs.Experimental.VF2State"><code>Graphs.Experimental.VF2State</code></a></li><li><a href="#Graphs.Experimental.Parallel.gdistances-Union{Tuple{T}, Tuple{AbstractGraph{T}, Vector{&lt;:Integer}}} where T&lt;:Integer"><code>Graphs.Experimental.Parallel.gdistances</code></a></li><li><a href="#Graphs.Experimental.Parallel.gdistances!-Union{Tuple{T}, Tuple{AbstractGraph{T}, Vector{&lt;:Integer}, Vector{T}}} where T&lt;:Integer"><code>Graphs.Experimental.Parallel.gdistances!</code></a></li><li><a href="#Graphs.Experimental.Parallel.partition_sources!-Union{Tuple{T}, Tuple{Array{Vector{T}, 1}, Vector{&lt;:Integer}, Vector{Bool}}} where T&lt;:Integer"><code>Graphs.Experimental.Parallel.partition_sources!</code></a></li><li><a href="#Graphs.Experimental.ShortestPaths.dists-Tuple{Graphs.Experimental.ShortestPaths.ShortestPathResult, Integer}"><code>Graphs.Experimental.ShortestPaths.dists</code></a></li><li><a href="#Graphs.Experimental.ShortestPaths.has_negative_weight_cycle-Tuple{AbstractGraph, AbstractMatrix, Graphs.Experimental.ShortestPaths.SPFA}"><code>Graphs.Experimental.ShortestPaths.has_negative_weight_cycle</code></a></li><li><a href="#Graphs.Experimental.ShortestPaths.has_negative_weight_cycle"><code>Graphs.Experimental.ShortestPaths.has_negative_weight_cycle</code></a></li><li><a href="#Graphs.Experimental.ShortestPaths.paths-Tuple{Graphs.Experimental.ShortestPaths.ShortestPathResult, AbstractVector{&lt;:Integer}}"><code>Graphs.Experimental.ShortestPaths.paths</code></a></li><li><a href="#Graphs.Experimental.ShortestPaths.shortest_paths-Tuple{AbstractGraph, Any, Graphs.Experimental.ShortestPaths.ShortestPathAlgorithm}"><code>Graphs.Experimental.ShortestPaths.shortest_paths</code></a></li><li><a href="#Graphs.Experimental.Traversals.distances-Union{Tuple{T}, Tuple{AbstractGraph{T}, Any}, Tuple{AbstractGraph{T}, Any, Graphs.Experimental.Traversals.BFS}} where T"><code>Graphs.Experimental.Traversals.distances</code></a></li><li><a href="#Graphs.Experimental.Traversals.initfn!-Tuple{Graphs.Experimental.Traversals.AbstractTraversalState, Any}"><code>Graphs.Experimental.Traversals.initfn!</code></a></li><li><a href="#Graphs.Experimental.Traversals.newvisitfn!-Tuple{Graphs.Experimental.Traversals.AbstractTraversalState, Any, Any}"><code>Graphs.Experimental.Traversals.newvisitfn!</code></a></li><li><a href="#Graphs.Experimental.Traversals.parents-Union{Tuple{T}, Tuple{AbstractGraph{T}, Integer, Graphs.Experimental.Traversals.TraversalAlgorithm}, Tuple{AbstractGraph{T}, Integer, Graphs.Experimental.Traversals.TraversalAlgorithm, Any}} where T"><code>Graphs.Experimental.Traversals.parents</code></a></li><li><a href="#Graphs.Experimental.Traversals.postlevelfn!-Tuple{Graphs.Experimental.Traversals.AbstractTraversalState}"><code>Graphs.Experimental.Traversals.postlevelfn!</code></a></li><li><a href="#Graphs.Experimental.Traversals.postvisitfn!-Tuple{Graphs.Experimental.Traversals.AbstractTraversalState, Any}"><code>Graphs.Experimental.Traversals.postvisitfn!</code></a></li><li><a href="#Graphs.Experimental.Traversals.previsitfn!-Tuple{Graphs.Experimental.Traversals.AbstractTraversalState, Any}"><code>Graphs.Experimental.Traversals.previsitfn!</code></a></li><li><a href="#Graphs.Experimental.Traversals.traverse_graph!-Tuple{AbstractGraph, Integer, Any, Any, Any}"><code>Graphs.Experimental.Traversals.traverse_graph!</code></a></li><li><a href="#Graphs.Experimental.Traversals.traverse_graph!-Union{Tuple{U}, Tuple{AbstractGraph{U}, AbstractVector, Graphs.Experimental.Traversals.BFS, Graphs.Experimental.Traversals.AbstractTraversalState}, Tuple{AbstractGraph{U}, AbstractVector, Graphs.Experimental.Traversals.BFS, Graphs.Experimental.Traversals.AbstractTraversalState, Function}} where U&lt;:Integer"><code>Graphs.Experimental.Traversals.traverse_graph!</code></a></li><li><a href="#Graphs.Experimental.Traversals.tree-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:Integer"><code>Graphs.Experimental.Traversals.tree</code></a></li><li><a href="#Graphs.Experimental.Traversals.tree"><code>Graphs.Experimental.Traversals.tree</code></a></li><li><a href="#Graphs.Experimental.Traversals.visited_vertices-Union{Tuple{U}, Tuple{AbstractGraph{U}, AbstractVector, Graphs.Experimental.Traversals.TraversalAlgorithm}} where U&lt;:Integer"><code>Graphs.Experimental.Traversals.visited_vertices</code></a></li><li><a href="#Graphs.Experimental.Traversals.visitfn!-Tuple{Graphs.Experimental.Traversals.AbstractTraversalState, Any, Any}"><code>Graphs.Experimental.Traversals.visitfn!</code></a></li><li><a href="#Graphs.Experimental.all_induced_subgraphisomorph"><code>Graphs.Experimental.all_induced_subgraphisomorph</code></a></li><li><a href="#Graphs.Experimental.all_isomorph"><code>Graphs.Experimental.all_isomorph</code></a></li><li><a href="#Graphs.Experimental.all_subgraphisomorph"><code>Graphs.Experimental.all_subgraphisomorph</code></a></li><li><a href="#Graphs.Experimental.could_have_isomorph-Tuple{AbstractGraph, AbstractGraph}"><code>Graphs.Experimental.could_have_isomorph</code></a></li><li><a href="#Graphs.Experimental.count_induced_subgraphisomorph"><code>Graphs.Experimental.count_induced_subgraphisomorph</code></a></li><li><a href="#Graphs.Experimental.count_isomorph"><code>Graphs.Experimental.count_isomorph</code></a></li><li><a href="#Graphs.Experimental.count_subgraphisomorph"><code>Graphs.Experimental.count_subgraphisomorph</code></a></li><li><a href="#Graphs.Experimental.has_induced_subgraphisomorph"><code>Graphs.Experimental.has_induced_subgraphisomorph</code></a></li><li><a href="#Graphs.Experimental.has_isomorph"><code>Graphs.Experimental.has_isomorph</code></a></li><li><a href="#Graphs.Experimental.has_subgraphisomorph"><code>Graphs.Experimental.has_subgraphisomorph</code></a></li><li><a href="#Graphs.Experimental.vf2-Union{Tuple{G}, Tuple{Function, G, G, Graphs.Experimental.GraphMorphismProblem}} where G&lt;:Graphs.SimpleGraphs.AbstractSimpleGraph"><code>Graphs.Experimental.vf2</code></a></li><li><a href="#Graphs.Experimental.vf2check_feasibility-Tuple{Any, Any, Graphs.Experimental.VF2State, Any, Union{Nothing, Function}, Union{Nothing, Function}}"><code>Graphs.Experimental.vf2check_feasibility</code></a></li><li><a href="#Graphs.Experimental.vf2match!-Tuple{Any, Any, Function, Graphs.Experimental.GraphMorphismProblem, Any, Any}"><code>Graphs.Experimental.vf2match!</code></a></li><li><a href="#Graphs.Experimental.vf2reset_state!-Tuple{Graphs.Experimental.VF2State, Any, Any, Any}"><code>Graphs.Experimental.vf2reset_state!</code></a></li><li><a href="#Graphs.Experimental.vf2update_state!-Tuple{Graphs.Experimental.VF2State, Any, Any, Any}"><code>Graphs.Experimental.vf2update_state!</code></a></li></ul><h2 id="Full-docs"><a class="docs-heading-anchor" href="#Full-docs">Full docs</a><a id="Full-docs-1"></a><a class="docs-heading-anchor-permalink" href="#Full-docs" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Graphs.Experimental.IsomorphismAlgorithm" href="#Graphs.Experimental.IsomorphismAlgorithm"><code>Graphs.Experimental.IsomorphismAlgorithm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IsomorphismAlgorithm</code></pre><p>An abstract type used for method dispatch on isomorphism functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/559404d193e901c67c63fc84168872f65889e4eb/src/Experimental/isomorphism.jl#L6-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.Experimental.all_induced_subgraphisomorph" href="#Graphs.Experimental.all_induced_subgraphisomorph"><code>Graphs.Experimental.all_induced_subgraphisomorph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">all_induced_subgraphisomorph(g1, g2, alg::IsomorphismAlgorithm=VF2(); vertex_relation=nothing, edge_relation=nothing)</code></pre><p>Return all isomorphism from vertex induced subgraphs of <code>g1</code> to <code>g2</code>. The isomorphisms are returned as an iterator of vectors of tuples, where the i-th vector is  the i-th isomorphism and a tuple (u, v) in this vector means that u ∈ g1 is mapped to v ∈ g2.</p><p><strong>Optional Arguments</strong></p><ul><li><code>alg</code>: The algorithm that is used to find the induced subgraph isomorphism. Can be only   <code>VF2()</code> at the moment.</li><li><code>vertex_relation</code>: A binary function that takes a vertex from <code>g1</code> and one from <code>g2</code>. An   isomorphism only exists if this function returns <code>true</code> for all matched vertices.</li><li><code>edge_relation</code>: A binary function that takes an edge from <code>g1</code> and one from <code>g2</code>. An   isomorphism only exists if this function returns <code>true</code> for all matched edges.</li></ul><p><strong>Examples</strong></p><pre><code class="language-doctest jl hljs">julia&gt; all_induced_subgraphisomorph(path_graph(3), SimpleGraph(2)) |&gt; collect
2-element Array{Array{Tuple{Int64,Int64},1},1}:
 [(1, 1), (3, 2)]
 [(3, 1), (1, 2)]

julia&gt; g1 = path_digraph(3); color1 = [1, 1, 2]
julia&gt; g2 = path_digraph(2); color2 = [1, 2]
julia&gt; color_rel(u, v) = (color1[u] == color2[v])
julia&gt; all_induced_subgraphisomorph(g1, g2) |&gt; collect
2-element Array{Array{Tuple{Int64,Int64},1},1}:
 [(1, 1), (2, 2)]
 [(2, 1), (3, 2)]
julia&gt; all_induced_subgraphisomorph(g1, g2, vertex_relation=color_rel) |&gt; collect
1-element Array{Array{Tuple{Int64,Int64},1},1}:
 [(1, 1), (2, 2)]</code></pre><p><strong>See also</strong></p><p><a href="#Graphs.Experimental.all_subgraphisomorph"><code>all_subgraphisomorph</code></a>, <a href="#Graphs.Experimental.all_isomorph"><code>all_isomorph</code></a>, <a href="#Graphs.Experimental.has_induced_subgraphisomorph"><code>has_induced_subgraphisomorph</code></a>, <a href="#Graphs.Experimental.count_induced_subgraphisomorph"><code>count_induced_subgraphisomorph</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/559404d193e901c67c63fc84168872f65889e4eb/src/Experimental/isomorphism.jl#L312-L348">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.Experimental.all_isomorph" href="#Graphs.Experimental.all_isomorph"><code>Graphs.Experimental.all_isomorph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">all_isomorph(g1, g2, alg::IsomorphismAlgorithm=VF2(); vertex_relation=nothing, edge_relation=nothing)</code></pre><p>Return all isomorphism from <code>g1</code> to <code>g2</code>. The isomorphisms are returned as an iterator of vectors of tuples, where the i-th vector is  the i-th isomorphism and a tuple (u, v) in this vector means that u ∈ g1 is mapped to v ∈ g2.</p><p><strong>Optional Arguments</strong></p><ul><li><code>alg</code>: The algorithm that is used to find the induced subgraph isomorphism. Can be only   <code>VF2()</code> at the moment.</li><li><code>vertex_relation</code>: A binary function that takes a vertex from <code>g1</code> and one from <code>g2</code>. An   isomorphism only exists if this function returns <code>true</code> for all matched vertices.</li><li><code>edge_relation</code>: A binary function that takes an edge from <code>g1</code> and one from <code>g2</code>. An   isomorphism only exists if this function returns <code>true</code> for all matched edges.</li></ul><p><strong>Examples</strong></p><pre><code class="language-doctest jl hljs">julia&gt; all_isomorph(star_graph(4), star_graph(4)) |&gt; collect
6-element Array{Array{Tuple{Int64,Int64},1},1}:
 [(1, 1), (2, 2), (3, 3), (4, 4)]
 [(1, 1), (2, 2), (4, 3), (3, 4)]
 [(1, 1), (3, 2), (2, 3), (4, 4)]
 [(1, 1), (3, 2), (4, 3), (2, 4)]
 [(1, 1), (4, 2), (2, 3), (3, 4)]
 [(1, 1), (4, 2), (3, 3), (2, 4)]
 
julia&gt; g1 = cycle_digraph(3); color1 = [1, 1, 2]
julia&gt; g2 = cycle_digraph(3); color2 = [2, 1, 1]
julia&gt; color_rel(u, v) = (color1[u] == color2[v])
julia&gt; all_isomorph(g1, g2) |&gt; collect
3-element Array{Array{Tuple{Int64,Int64},1},1}:
 [(1, 1), (2, 2), (3, 3)]
 [(2, 1), (3, 2), (1, 3)]
 [(3, 1), (1, 2), (2, 3)]
julia&gt; all_subgraphisomorph(g1, g2, vertex_relation=color_rel)
1-element Array{Array{Tuple{Int64,Int64},1},1}:
 [(3, 1), (1, 2), (2, 3)]</code></pre><p><strong>See also</strong></p><p><a href="#Graphs.Experimental.all_induced_subgraphisomorph"><code>all_induced_subgraphisomorph</code></a>, <a href="#Graphs.Experimental.all_subgraphisomorph"><code>all_subgraphisomorph</code></a>, <a href="#Graphs.Experimental.has_isomorph"><code>has_isomorph</code></a>, <a href="#Graphs.Experimental.count_isomorph"><code>count_isomorph</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/559404d193e901c67c63fc84168872f65889e4eb/src/Experimental/isomorphism.jl#L412-L453">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.Experimental.all_subgraphisomorph" href="#Graphs.Experimental.all_subgraphisomorph"><code>Graphs.Experimental.all_subgraphisomorph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">all_subgraphisomorph(g1, g2, alg::IsomorphismAlgorithm=VF2(); vertex_relation=nothing, edge_relation=nothing)</code></pre><p>Return all isomorphism from  subgraphs of <code>g1</code> to <code>g2</code>. The isomorphisms are returned as an iterator of vectors of tuples, where the i-th vector is  the i-th isomorphism and a tuple (u, v) in this vector means that u ∈ g1 is mapped to v ∈ g2.</p><p><strong>Optional Arguments</strong></p><ul><li><code>alg</code>: The algorithm that is used to find the induced subgraph isomorphism. Can be only   <code>VF2()</code> at the moment.</li><li><code>vertex_relation</code>: A binary function that takes a vertex from <code>g1</code> and one from <code>g2</code>. An   isomorphism only exists if this function returns <code>true</code> for all matched vertices.</li><li><code>edge_relation</code>: A binary function that takes an edge from <code>g1</code> and one from <code>g2</code>. An   isomorphism only exists if this function returns <code>true</code> for all matched edges.</li></ul><p><strong>Examples</strong></p><pre><code class="language-doctest jl hljs">julia&gt; all_subgraphisomorph(path_graph(3), path_graph(2)) |&gt; collect
4-element Array{Array{Tuple{Int64,Int64},1},1}:
 [(1, 1), (2, 2)]
 [(2, 1), (1, 2)]
 [(2, 1), (3, 2)]
 [(3, 1), (2, 2)]

julia&gt; g1 = path_digraph(3); color1 = [1, 1, 2]
julia&gt; g2 = path_digraph(2); color2 = [1, 2]
julia&gt; color_rel(u, v) = (color1[u] == color2[v])
julia&gt; all_subgraphisomorph(g1, g2) |&gt; collect
2-element Array{Array{Tuple{Int64,Int64},1},1}:
 [(1, 1), (2, 2)]
 [(2, 1), (3, 2)]
julia&gt; all_subgraphisomorph(g1, g2, vertex_relation=color_rel)
1-element Array{Array{Tuple{Int64,Int64},1},1}:
 [(2, 1), (3, 2)]</code></pre><p><strong>See also</strong></p><p><a href="#Graphs.Experimental.all_induced_subgraphisomorph"><code>all_induced_subgraphisomorph</code></a>, <a href="#Graphs.Experimental.all_isomorph"><code>all_isomorph</code></a>, <a href="#Graphs.Experimental.has_subgraphisomorph"><code>has_subgraphisomorph</code></a>, <a href="#Graphs.Experimental.count_subgraphisomorph"><code>count_subgraphisomorph</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/559404d193e901c67c63fc84168872f65889e4eb/src/Experimental/isomorphism.jl#L361-L399">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.Experimental.could_have_isomorph-Tuple{AbstractGraph, AbstractGraph}" href="#Graphs.Experimental.could_have_isomorph-Tuple{AbstractGraph, AbstractGraph}"><code>Graphs.Experimental.could_have_isomorph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">could_have_isomorph(g1, g2)</code></pre><p>Run quick test to check if <code>g1 and</code>g2` could be isomorphic.</p><p>If the result is <code>false</code>, then <code>g1</code> and <code>g2</code> are definitely not isomorphic, but if the result is <code>true</code> this is not guaranteed.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Graphs

julia&gt; Graphs.Experimental.could_have_isomorph(path_graph(3), star_graph(4))
false

julia&gt; Graphs.Experimental.could_have_isomorph(path_graph(3), star_graph(3))
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/559404d193e901c67c63fc84168872f65889e4eb/src/Experimental/isomorphism.jl#L13-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.Experimental.count_induced_subgraphisomorph" href="#Graphs.Experimental.count_induced_subgraphisomorph"><code>Graphs.Experimental.count_induced_subgraphisomorph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">count_induced_subgraphisomorph(g1, g2, alg::IsomorphismAlgorithm=VF2(); vertex_relation=nothing, edge_relation=nothing)</code></pre><p>Return the number of vertex induced subgraphs of the graph <code>g1</code> that are isomorphic to <code>g2</code>.</p><p><strong>Optional Arguments</strong></p><ul><li><code>vertex_relation</code>: A binary function that takes a vertex from <code>g1</code> and one from <code>g2</code>. An   isomorphism only exists if this function returns <code>true</code> for all matched vertices.</li><li><code>edge_relation</code>: A binary function that takes an edge from <code>g1</code> and one from <code>g2</code>. An   isomorphism only exists if this function returns <code>true</code> for all matched edges.</li></ul><p><strong>Examples</strong></p><pre><code class="language-doctest jl hljs">julia&gt; count_induced_subgraphisomorph(complete_graph(5), complete_graph(4))
120
julia&gt; count_induced_subgraphisomorph(complete_graph(5), cycle_graph(4))
0

julia&gt; g1 = path_graph(3); color1 = [1, 1, 2]
julia&gt; g2 = path_graph(2); color2 = [1, 2]
julia&gt; color_rel(u, v) = (color1[u] == color2[v])
julia&gt; count_induced_subgraphisomorph(g1, g2)
2
julia&gt; count_induced_subgraphisomorph(g1, g2, vertex_relation=color_rel)
1</code></pre><p><strong>See also</strong></p><p><a href="#Graphs.Experimental.count_subgraphisomorph"><code>count_subgraphisomorph</code></a>, <a href="#Graphs.Experimental.count_isomorph"><code>count_isomorph</code></a>, <a href="#Graphs.Experimental.has_induced_subgraphisomorph"><code>has_induced_subgraphisomorph</code></a>, <a href="#Graphs.Experimental.all_induced_subgraphisomorph"><code>all_induced_subgraphisomorph</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/559404d193e901c67c63fc84168872f65889e4eb/src/Experimental/isomorphism.jl#L181-L209">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.Experimental.count_isomorph" href="#Graphs.Experimental.count_isomorph"><code>Graphs.Experimental.count_isomorph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">count_isomorph(g1, g2, alg::IsomorphismAlgorithm=VF2(); vertex_relation=nothing, edge_relation=nothing)</code></pre><p>Return the number of isomorphism from graph <code>g1</code> to <code>g2</code>.</p><p><strong>Optional Arguments</strong></p><ul><li><code>alg</code>: The algorithm that is used to find the induced subgraph isomorphism. Can be only   <code>VF2()</code> at the moment.</li><li><code>vertex_relation</code>: A binary function that takes a vertex from <code>g1</code> and one from <code>g2</code>. An   isomorphism only exists if this function returns <code>true</code> for all matched vertices.</li><li><code>edge_relation</code>: A binary function that takes an edge from <code>g1</code> and one from <code>g2</code>. An   isomorphism only exists if this function returns <code>true</code> for all matched edges.</li></ul><p><strong>Examples</strong></p><pre><code class="language-doctest jl hljs">julia&gt; count_isomorph(cycle_graph(5), cycle_graph(5))
10
julia&gt; count_isomorph(complete_graph(5), cycle_graph(5))
0

julia&gt; g1 = cycle_digraph(3); color1 = [1, 1, 2]
julia&gt; g2 = cycle_digraph(3); color2 = [1, 1, 1]
julia&gt; color_rel(u, v) = (color1[u] == color2[v])
julia&gt; count_isomorph(g1, g2)
3
julia&gt; count_isomorph(g1, g2, vertex_relation=color_rel)
0</code></pre><p><strong>See also</strong></p><p><a href="#Graphs.Experimental.count_induced_subgraphisomorph"><code>count_induced_subgraphisomorph</code></a>, <a href="#Graphs.Experimental.count_subgraphisomorph"><code>count_subgraphisomorph</code></a>, <a href="#Graphs.Experimental.has_isomorph"><code>has_isomorph</code></a>, <a href="#Graphs.Experimental.all_isomorph"><code>all_isomorph</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/559404d193e901c67c63fc84168872f65889e4eb/src/Experimental/isomorphism.jl#L269-L299">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.Experimental.count_subgraphisomorph" href="#Graphs.Experimental.count_subgraphisomorph"><code>Graphs.Experimental.count_subgraphisomorph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">count_subgraphisomorph(g1, g2, alg::IsomorphismAlgorithm=VF2(); vertex_relation=nothing, edge_relation=nothing)</code></pre><p>Return the number of subgraphs of the graph <code>g1</code> that are isomorphic to <code>g2</code>.</p><p><strong>Optional Arguments</strong></p><ul><li><code>alg</code>: The algorithm that is used to find the induced subgraph isomorphism. Can be only   <code>VF2()</code> at the moment.</li><li><code>vertex_relation</code>: A binary function that takes a vertex from <code>g1</code> and one from <code>g2</code>. An   isomorphism only exists if this function returns <code>true</code> for all matched vertices.</li><li><code>edge_relation</code>: A binary function that takes an edge from <code>g1</code> and one from <code>g2</code>. An   isomorphism only exists if this function returns <code>true</code> for all matched edges.</li></ul><p><strong>Examples</strong></p><pre><code class="language-doctest jl hljs">julia&gt; count_subgraphisomorph(complete_graph(5), complete_graph(4))
120
julia&gt; count_subgraphisomorph(complete_graph(5), cycle_graph(4))
120

julia&gt; g1 = cycle_digraph(3); color1 = [1, 1, 2]
julia&gt; g2 = SimpleDiGraph(2); color2 = [1, 2]
julia&gt; color_rel(u, v) = (color1[u] == color2[v])
julia&gt; count_subgraphisomorph(g1, g2)
6
julia&gt; count_subgraphisomorph(g1, g2, vertex_relation=color_rel)
2</code></pre><p><strong>See also</strong></p><p><a href="#Graphs.Experimental.count_induced_subgraphisomorph"><code>count_induced_subgraphisomorph</code></a>, <a href="#Graphs.Experimental.count_isomorph"><code>count_isomorph</code></a>, <a href="#Graphs.Experimental.has_subgraphisomorph"><code>has_subgraphisomorph</code></a>, <a href="#Graphs.Experimental.all_subgraphisomorph"><code>all_subgraphisomorph</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/559404d193e901c67c63fc84168872f65889e4eb/src/Experimental/isomorphism.jl#L222-L252">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.Experimental.has_induced_subgraphisomorph" href="#Graphs.Experimental.has_induced_subgraphisomorph"><code>Graphs.Experimental.has_induced_subgraphisomorph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">has_induced_subgraphisomorph(g1, g2, alg::IsomorphismAlgorithm=VF2(); vertex_relation=nothing, edge_relation=nothing)</code></pre><p>Return <code>true</code> if the graph <code>g1</code> contains a vertex induced subgraph that is isomorphic to <code>g2</code>.</p><p><strong>Optional Arguments</strong></p><ul><li><code>alg</code>: The algorithm that is used to find the induced subgraph isomorphism. Can be only   <code>VF2()</code> at the moment.</li><li><code>vertex_relation</code>: A binary function that takes a vertex from <code>g1</code> and one from <code>g2</code>. An   isomorphism only exists if this function returns <code>true</code> for all matched vertices.</li><li><code>edge_relation</code>: A binary function that takes an edge from <code>g1</code> and one from <code>g2</code>. An   isomorphism only exists if this function returns <code>true</code> for all matched edges.</li></ul><p><strong>Examples</strong></p><pre><code class="language-doctest jl hljs">julia&gt; has_induced_subgraphisomorph(complete_graph(5), complete_graph(4))
true
julia&gt; has_induced_subgraphisomorph(complete_graph(5), cycle_graph(4))
false

julia&gt; g1 = path_digraph(3); color1 = [1, 1, 1]
julia&gt; g2 = path_digraph(2); color2 = [1, 2]
julia&gt; color_rel(u, v) = (color1[u] == color2[v])
julia&gt; has_induced_subgraphisomorph(g1, g2)
true
julia&gt; has_induced_subgraphisomorph(g1, g2, vertex_relation=color_rel)
false</code></pre><p><strong>See also</strong></p><p><a href="#Graphs.Experimental.has_subgraphisomorph"><code>has_subgraphisomorph</code></a>, <a href="#Graphs.Experimental.has_isomorph"><code>has_isomorph</code></a>, <a href="#Graphs.Experimental.count_induced_subgraphisomorph"><code>count_induced_subgraphisomorph</code></a>, <a href="#Graphs.Experimental.all_induced_subgraphisomorph"><code>all_induced_subgraphisomorph</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/559404d193e901c67c63fc84168872f65889e4eb/src/Experimental/isomorphism.jl#L52-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.Experimental.has_isomorph" href="#Graphs.Experimental.has_isomorph"><code>Graphs.Experimental.has_isomorph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">has_isomorph(g1, g2, alg::IsomorphismAlgorithm=VF2(); vertex_relation=nothing, edge_relation=nothing)</code></pre><p>Return <code>true</code> if the graph <code>g1</code> is isomorphic to <code>g2</code>.</p><p><strong>Optional Arguments</strong></p><ul><li><code>alg</code>: The algorithm that is used to find the induced subgraph isomorphism. Can be only   <code>VF2()</code> at the moment.</li><li><code>vertex_relation</code>: A binary function that takes a vertex from <code>g1</code> and one from <code>g2</code>. An   isomorphism only exists if this function returns <code>true</code> for all matched vertices.</li><li><code>edge_relation</code>: A binary function that takes an edge from <code>g1</code> and one from <code>g2</code>. An   isomorphism only exists if this function returns <code>true</code> for all matched edges.</li></ul><p><strong>Examples</strong></p><pre><code class="language-doctest jl hljs">julia&gt; has_isomorph(complete_graph(3), cycle_graph(3))
true
julia&gt; has_isomorph(complete_graph(4), cycle_graph(4))
false

julia&gt; g1 = path_digraph(4); color1 = [1, 2, 1, 1]
julia&gt; g2 = path_digraph(4); color2 = [1, 2, 2, 1]
julia&gt; color_rel(u, v) = (color1[u] == color2[v])
julia&gt; has_isomorph(g1, g2)
true
julia&gt; has_isomorph(g1, g2, vertex_relation=color_rel)
false</code></pre><p><strong>See also</strong></p><p><a href="#Graphs.Experimental.has_induced_subgraphisomorph"><code>has_induced_subgraphisomorph</code></a>, <a href="#Graphs.Experimental.has_subgraphisomorph"><code>has_subgraphisomorph</code></a>, <a href="#Graphs.Experimental.count_subgraphisomorph"><code>count_subgraphisomorph</code></a>, <a href="#Graphs.Experimental.all_subgraphisomorph"><code>all_subgraphisomorph</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/559404d193e901c67c63fc84168872f65889e4eb/src/Experimental/isomorphism.jl#L138-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.Experimental.has_subgraphisomorph" href="#Graphs.Experimental.has_subgraphisomorph"><code>Graphs.Experimental.has_subgraphisomorph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">has_subgraphisomorph(g1, g2, alg::IsomorphismAlgorithm=VF2(); vertex_relation=nothing, edge_relation=nothing)</code></pre><p>Return <code>true</code> if the graph <code>g1</code> contains a subgraph that is isomorphic to <code>g2</code>.</p><p><strong>Optional Arguments</strong></p><ul><li><code>alg</code>: The algorithm that is used to find the induced subgraph isomorphism. Can be only   <code>VF2()</code> at the moment.</li><li><code>vertex_relation</code>: A binary function that takes a vertex from <code>g1</code> and one from <code>g2</code>. An   isomorphism only exists if this function returns <code>true</code> for all matched vertices.</li><li><code>edge_relation</code>: A binary function that takes an edge from <code>g1</code> and one from <code>g2</code>. An   isomorphism only exists if this function returns <code>true</code> for all matched edges.</li></ul><p><strong>Examples</strong></p><pre><code class="language-doctest jl hljs">julia&gt; has_subgraphisomorph(complete_graph(5), complete_graph(4))
true
julia&gt; has_subgraphisomorph(complete_graph(5), cycle_graph(4))
true

julia&gt; g1 = path_digraph(3); color1 = [1, 1, 1]
julia&gt; g2 = path_digraph(2); color2 = [1, 2]
julia&gt; color_rel(u, v) = (color1[u] == color2[v])
julia&gt; has_subgraphisomorph(g1, g2)
true
julia&gt; has_subgraphisomorph(g1, g2, vertex_relation=color_rel)
false</code></pre><p><strong>See also</strong></p><p><a href="#Graphs.Experimental.has_induced_subgraphisomorph"><code>has_induced_subgraphisomorph</code></a>, <a href="#Graphs.Experimental.has_isomorph"><code>has_isomorph</code></a>, <a href="#Graphs.Experimental.count_subgraphisomorph"><code>count_subgraphisomorph</code></a>, <a href="#Graphs.Experimental.all_subgraphisomorph"><code>all_subgraphisomorph</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/559404d193e901c67c63fc84168872f65889e4eb/src/Experimental/isomorphism.jl#L95-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.Experimental.VF2" href="#Graphs.Experimental.VF2"><code>Graphs.Experimental.VF2</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VF2</code></pre><p>An empty concrete type used to dispatch to <a href="#Graphs.Experimental.vf2-Union{Tuple{G}, Tuple{Function, G, G, Graphs.Experimental.GraphMorphismProblem}} where G&lt;:Graphs.SimpleGraphs.AbstractSimpleGraph"><code>vf2</code></a> isomorphism functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/559404d193e901c67c63fc84168872f65889e4eb/src/Experimental/vf2.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.Experimental.VF2State" href="#Graphs.Experimental.VF2State"><code>Graphs.Experimental.VF2State</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VF2State{G, T}</code></pre><p>Structure that is internally used by vf2</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/559404d193e901c67c63fc84168872f65889e4eb/src/Experimental/vf2.jl#L8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.Experimental.vf2-Union{Tuple{G}, Tuple{Function, G, G, Graphs.Experimental.GraphMorphismProblem}} where G&lt;:Graphs.SimpleGraphs.AbstractSimpleGraph" href="#Graphs.Experimental.vf2-Union{Tuple{G}, Tuple{Function, G, G, Graphs.Experimental.GraphMorphismProblem}} where G&lt;:Graphs.SimpleGraphs.AbstractSimpleGraph"><code>Graphs.Experimental.vf2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vf2(callback, g1, g2, problemtype; vertex_relation=nothing, edge_relation=nothing)</code></pre><p>Iterate over all isomorphism between the graphs <code>g1</code> (or subgraphs thereof) and <code>g2</code>. The problem that is solved depends on the value of <code>problemtype</code>:</p><ul><li>IsomorphismProblem(): Only isomorphisms between the whole graph <code>g1</code> and <code>g2</code> are considered.</li><li>SubGraphIsomorphismProblem(): All isomorphism between subgraphs of <code>g1</code> and <code>g2</code> are considered.</li><li>InducedSubGraphIsomorphismProblem(): All isomorphism between vertex induced subgraphs of <code>g1</code> and <code>g2</code> are considered.</li></ul><p>Upon finding an isomorphism, the function <code>callback</code> is called with a vector <code>vmap</code> as an argument. <code>vmap</code> is a vector where <code>vmap[v] == u</code> means that vertex <code>v</code> in <code>g2</code> is mapped to vertex <code>u</code> in <code>g1</code>. If the algorithm should look for another isomorphism, then this function should return <code>true</code>.</p><p><strong>Optional Arguments</strong></p><ul><li><code>vertex_relation</code>: A binary function that takes a vertex from <code>g1</code> and one from <code>g2</code>. An   isomorphism only exists if this function returns <code>true</code> for all matched vertices.</li><li><code>edge_relation</code>: A binary function that takes an edge from <code>g1</code> and one from <code>g2</code>. An   isomorphism only exists if this function returns <code>true</code> for all matched edges.</li></ul><p><strong>References</strong></p><p>Luigi P. Cordella, Pasquale Foggia, Carlo Sansone, Mario Vento “A (Sub)Graph Isomorphism Algorithm for Matching Large Graphs”</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/559404d193e901c67c63fc84168872f65889e4eb/src/Experimental/vf2.jl#L37-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.Experimental.vf2check_feasibility-Tuple{Any, Any, Graphs.Experimental.VF2State, Any, Union{Nothing, Function}, Union{Nothing, Function}}" href="#Graphs.Experimental.vf2check_feasibility-Tuple{Any, Any, Graphs.Experimental.VF2State, Any, Union{Nothing, Function}, Union{Nothing, Function}}"><code>Graphs.Experimental.vf2check_feasibility</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vf2check_feasibility(u, v, state, problemtype, vertex_relation, edge_relation)</code></pre><p>Check whether two vertices of G₁ and G₂ can be matched. Used by <a href="#Graphs.Experimental.vf2match!-Tuple{Any, Any, Function, Graphs.Experimental.GraphMorphismProblem, Any, Any}"><code>vf2match!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/559404d193e901c67c63fc84168872f65889e4eb/src/Experimental/vf2.jl#L80-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.Experimental.vf2match!-Tuple{Any, Any, Function, Graphs.Experimental.GraphMorphismProblem, Any, Any}" href="#Graphs.Experimental.vf2match!-Tuple{Any, Any, Function, Graphs.Experimental.GraphMorphismProblem, Any, Any}"><code>Graphs.Experimental.vf2match!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vf2match!(state, depth, callback, problemtype, vertex_relation, edge_relation)</code></pre><p>Perform isomorphic subgraph matching. Called by <a href="#Graphs.Experimental.vf2-Union{Tuple{G}, Tuple{Function, G, G, Graphs.Experimental.GraphMorphismProblem}} where G&lt;:Graphs.SimpleGraphs.AbstractSimpleGraph"><code>vf2</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/559404d193e901c67c63fc84168872f65889e4eb/src/Experimental/vf2.jl#L365-L369">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.Experimental.vf2reset_state!-Tuple{Graphs.Experimental.VF2State, Any, Any, Any}" href="#Graphs.Experimental.vf2reset_state!-Tuple{Graphs.Experimental.VF2State, Any, Any, Any}"><code>Graphs.Experimental.vf2reset_state!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vf2reset_state!(state, u, v, depth)</code></pre><p>Reset state after returning from recursion. Helper function for <a href="#Graphs.Experimental.vf2match!-Tuple{Any, Any, Function, Graphs.Experimental.GraphMorphismProblem, Any, Any}"><code>vf2match!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/559404d193e901c67c63fc84168872f65889e4eb/src/Experimental/vf2.jl#L333-L337">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.Experimental.vf2update_state!-Tuple{Graphs.Experimental.VF2State, Any, Any, Any}" href="#Graphs.Experimental.vf2update_state!-Tuple{Graphs.Experimental.VF2State, Any, Any, Any}"><code>Graphs.Experimental.vf2update_state!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vf2update_state!(state, u, v, depth)</code></pre><p>Update state before recursing. Helper function for <a href="#Graphs.Experimental.vf2match!-Tuple{Any, Any, Function, Graphs.Experimental.GraphMorphismProblem, Any, Any}"><code>vf2match!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/559404d193e901c67c63fc84168872f65889e4eb/src/Experimental/vf2.jl#L301-L305">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.Experimental.Traversals.distances-Union{Tuple{T}, Tuple{AbstractGraph{T}, Any}, Tuple{AbstractGraph{T}, Any, Graphs.Experimental.Traversals.BFS}} where T" href="#Graphs.Experimental.Traversals.distances-Union{Tuple{T}, Tuple{AbstractGraph{T}, Any}, Tuple{AbstractGraph{T}, Any, Graphs.Experimental.Traversals.BFS}} where T"><code>Graphs.Experimental.Traversals.distances</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">distances(g, s, alg=BFS())
distances(g, ss, alg=BFS())</code></pre><p>Return a vector filled with the geodesic distances of vertices in  <code>g</code> from vertex <code>s</code> / unique vertices <code>ss</code> using BFS traversal algorithm <code>alg</code>.  For vertices in disconnected components the default distance is <code>typemax(T)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/559404d193e901c67c63fc84168872f65889e4eb/src/Experimental/Traversals/bfs.jl#L80-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.Experimental.Traversals.traverse_graph!-Union{Tuple{U}, Tuple{AbstractGraph{U}, AbstractVector, Graphs.Experimental.Traversals.BFS, Graphs.Experimental.Traversals.AbstractTraversalState}, Tuple{AbstractGraph{U}, AbstractVector, Graphs.Experimental.Traversals.BFS, Graphs.Experimental.Traversals.AbstractTraversalState, Function}} where U&lt;:Integer" href="#Graphs.Experimental.Traversals.traverse_graph!-Union{Tuple{U}, Tuple{AbstractGraph{U}, AbstractVector, Graphs.Experimental.Traversals.BFS, Graphs.Experimental.Traversals.AbstractTraversalState}, Tuple{AbstractGraph{U}, AbstractVector, Graphs.Experimental.Traversals.BFS, Graphs.Experimental.Traversals.AbstractTraversalState, Function}} where U&lt;:Integer"><code>Graphs.Experimental.Traversals.traverse_graph!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">traverse_graph!(g, s, alg, state, neighborfn=outneighbors)
traverse_graph!(g, ss, alg, state, neighborfn=outneighbors)

Traverse a graph `g` starting at vertex `s` / vertices `ss` using algorithm `alg`, maintaining state in [`AbstractTraversalState`](@ref) `state`. Next vertices to be visited are determined by `neighborfn` (default `outneighbors`). Return `true` if traversal finished; `false` if one of the visit functions caused an early termination.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/559404d193e901c67c63fc84168872f65889e4eb/src/Experimental/Traversals/bfs.jl#L15-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.Experimental.Traversals.AbstractTraversalState" href="#Graphs.Experimental.Traversals.AbstractTraversalState"><code>Graphs.Experimental.Traversals.AbstractTraversalState</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractTraversalState</code></pre><p><code>AbstractTraversalState</code> is the abstract type used to hold mutable states for various traversal algorithms (see <a href="#Graphs.Experimental.Traversals.traverse_graph!-Union{Tuple{U}, Tuple{AbstractGraph{U}, AbstractVector, Graphs.Experimental.Traversals.BFS, Graphs.Experimental.Traversals.AbstractTraversalState}, Tuple{AbstractGraph{U}, AbstractVector, Graphs.Experimental.Traversals.BFS, Graphs.Experimental.Traversals.AbstractTraversalState, Function}} where U&lt;:Integer"><code>traverse_graph!</code></a>).</p><p>When creating concrete types, you should override the following functions where relevant. These functions are listed in order of occurrence in the traversal:</p><ul><li><a href="#Graphs.Experimental.Traversals.initfn!-Tuple{Graphs.Experimental.Traversals.AbstractTraversalState, Any}"><code>initfn!(&lt;:AbstractTraversalState, u::Integer)</code></a>: runs prior to traversal, used to set initial state.</li><li><a href="#Graphs.Experimental.Traversals.previsitfn!-Tuple{Graphs.Experimental.Traversals.AbstractTraversalState, Any}"><code>previsitfn!(&lt;:AbstractTraversalState, u::Integer)</code></a>: runs prior to neighborhood discovery for vertex <code>u</code>.</li><li><a href="#Graphs.Experimental.Traversals.visitfn!-Tuple{Graphs.Experimental.Traversals.AbstractTraversalState, Any, Any}"><code>visitfn!(&lt;:AbstractTraversalState, u::Integer, v::Integer)</code></a>: runs for each neighbor <code>v</code> (newly-discovered or not) of vertex <code>u</code>.</li><li><a href="#Graphs.Experimental.Traversals.newvisitfn!-Tuple{Graphs.Experimental.Traversals.AbstractTraversalState, Any, Any}"><code>newvisitfn!(&lt;:AbstractTraversalState, u::Integer, v::Integer)</code></a>: runs when a new neighbor <code>v</code> of vertex <code>u</code> is discovered.</li><li><a href="#Graphs.Experimental.Traversals.postvisitfn!-Tuple{Graphs.Experimental.Traversals.AbstractTraversalState, Any}"><code>postvisitfn!(&lt;:AbstractTraversalState, u::Integer)</code></a>: runs after neighborhood discovery for vertex <code>u</code>.</li><li><a href="#Graphs.Experimental.Traversals.postlevelfn!-Tuple{Graphs.Experimental.Traversals.AbstractTraversalState}"><code>postlevelfn!(&lt;:AbstractTraversalState)</code></a>: runs after each traversal level.</li></ul><p>Each of these functions should return a boolean. If the return value of the function is <code>false</code>, the traversal will return the state immediately. Otherwise, the traversal will continue.</p><p>For better performance, use the <code>@inline</code> directive and make your functions branch-free.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/559404d193e901c67c63fc84168872f65889e4eb/src/Experimental/Traversals/Traversals.jl#L17-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.Experimental.Traversals.TraversalAlgorithm" href="#Graphs.Experimental.Traversals.TraversalAlgorithm"><code>Graphs.Experimental.Traversals.TraversalAlgorithm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type TraversalAlgorithm</code></pre><p><code>TraversalAlgorithm</code> is the abstract type used to specify breadth-first traversal (<code>BFS</code>) or depth-first traversal (<code>DFS</code>) for the various traversal functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/559404d193e901c67c63fc84168872f65889e4eb/src/Experimental/Traversals/Traversals.jl#L9-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.Experimental.Traversals.initfn!-Tuple{Graphs.Experimental.Traversals.AbstractTraversalState, Any}" href="#Graphs.Experimental.Traversals.initfn!-Tuple{Graphs.Experimental.Traversals.AbstractTraversalState, Any}"><code>Graphs.Experimental.Traversals.initfn!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initfn!(state, u)</code></pre><p>Modify <a href="#Graphs.Experimental.Traversals.AbstractTraversalState"><code>AbstractTraversalState</code></a> <code>state</code> on initialization of traversal with source vertices, and return <code>true</code> if successful; <code>false</code> otherwise. <code>initfn!</code> will be called once for each vertex passed to <a href="#Graphs.Experimental.Traversals.traverse_graph!-Union{Tuple{U}, Tuple{AbstractGraph{U}, AbstractVector, Graphs.Experimental.Traversals.BFS, Graphs.Experimental.Traversals.AbstractTraversalState}, Tuple{AbstractGraph{U}, AbstractVector, Graphs.Experimental.Traversals.BFS, Graphs.Experimental.Traversals.AbstractTraversalState, Function}} where U&lt;:Integer"><code>traverse_graph!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/559404d193e901c67c63fc84168872f65889e4eb/src/Experimental/Traversals/Traversals.jl#L39-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.Experimental.Traversals.newvisitfn!-Tuple{Graphs.Experimental.Traversals.AbstractTraversalState, Any, Any}" href="#Graphs.Experimental.Traversals.newvisitfn!-Tuple{Graphs.Experimental.Traversals.AbstractTraversalState, Any, Any}"><code>Graphs.Experimental.Traversals.newvisitfn!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">newvisitfn!(state, u, v)</code></pre><p>Modify <a href="#Graphs.Experimental.Traversals.AbstractTraversalState"><code>AbstractTraversalState</code></a> <code>state</code> when the first edge between <code>u</code> and <code>v</code> is encountered, and return <code>true</code> if successful; <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/559404d193e901c67c63fc84168872f65889e4eb/src/Experimental/Traversals/Traversals.jl#L56-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.Experimental.Traversals.parents-Union{Tuple{T}, Tuple{AbstractGraph{T}, Integer, Graphs.Experimental.Traversals.TraversalAlgorithm}, Tuple{AbstractGraph{T}, Integer, Graphs.Experimental.Traversals.TraversalAlgorithm, Any}} where T" href="#Graphs.Experimental.Traversals.parents-Union{Tuple{T}, Tuple{AbstractGraph{T}, Integer, Graphs.Experimental.Traversals.TraversalAlgorithm}, Tuple{AbstractGraph{T}, Integer, Graphs.Experimental.Traversals.TraversalAlgorithm, Any}} where T"><code>Graphs.Experimental.Traversals.parents</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parents(g, s, alg, neighborfn=outneighbors)</code></pre><p>Return a vector of parent vertices indexed by vertex using <a href="#Graphs.Experimental.Traversals.TraversalAlgorithm"><code>TraversalAlgorithm</code></a> <code>alg</code> starting with vertex <code>s</code>. If <code>neighborfn</code> is specified, use the corresponding neighbor-generation function (<a href="../../core_functions/interface/#Graphs.inneighbors-Tuple{Any, Any}"><code>inneighbors</code></a>r and <a href="../../core_functions/interface/#Graphs.outneighbors-Tuple{Any, Any}"><code>outneighbors</code></a> are valid values).</p><p><strong>Performance</strong></p><p>This implementation is designed to perform well on large graphs. There are implementations which are marginally faster in practice for smaller graphs, but the performance improvements using this implementation on large graphs can be significant.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/559404d193e901c67c63fc84168872f65889e4eb/src/Experimental/Traversals/Traversals.jl#L151-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.Experimental.Traversals.postlevelfn!-Tuple{Graphs.Experimental.Traversals.AbstractTraversalState}" href="#Graphs.Experimental.Traversals.postlevelfn!-Tuple{Graphs.Experimental.Traversals.AbstractTraversalState}"><code>Graphs.Experimental.Traversals.postlevelfn!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">postlevelfn!(state)</code></pre><p>Modify <a href="#Graphs.Experimental.Traversals.AbstractTraversalState"><code>AbstractTraversalState</code></a> <code>state</code> before moving to the next vertex in the traversal algorithm, and return <code>true</code> if successful; <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/559404d193e901c67c63fc84168872f65889e4eb/src/Experimental/Traversals/Traversals.jl#L81-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.Experimental.Traversals.postvisitfn!-Tuple{Graphs.Experimental.Traversals.AbstractTraversalState, Any}" href="#Graphs.Experimental.Traversals.postvisitfn!-Tuple{Graphs.Experimental.Traversals.AbstractTraversalState, Any}"><code>Graphs.Experimental.Traversals.postvisitfn!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">postvisitfn!(state, u)</code></pre><p>Modify <a href="#Graphs.Experimental.Traversals.AbstractTraversalState"><code>AbstractTraversalState</code></a> <code>state</code> after having examined all neighbors of vertex <code>u</code>, and return <code>true</code> if successful; <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/559404d193e901c67c63fc84168872f65889e4eb/src/Experimental/Traversals/Traversals.jl#L74-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.Experimental.Traversals.previsitfn!-Tuple{Graphs.Experimental.Traversals.AbstractTraversalState, Any}" href="#Graphs.Experimental.Traversals.previsitfn!-Tuple{Graphs.Experimental.Traversals.AbstractTraversalState, Any}"><code>Graphs.Experimental.Traversals.previsitfn!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">previsitfn!(state, u)</code></pre><p>Modify <a href="#Graphs.Experimental.Traversals.AbstractTraversalState"><code>AbstractTraversalState</code></a> <code>state</code> before examining neighbors of vertex <code>u</code>, and return <code>true</code> if successful; <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/559404d193e901c67c63fc84168872f65889e4eb/src/Experimental/Traversals/Traversals.jl#L48-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.Experimental.Traversals.traverse_graph!-Tuple{AbstractGraph, Integer, Any, Any, Any}" href="#Graphs.Experimental.Traversals.traverse_graph!-Tuple{AbstractGraph, Integer, Any, Any, Any}"><code>Graphs.Experimental.Traversals.traverse_graph!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">traverse_graph!(g, s, alg, state, neighborfn=outneighbors)
traverse_graph!(g, ss, alg, state, neighborfn=outneighbors)</code></pre><p>Traverse a graph <code>g</code> from source vertex <code>s</code> / vertices <code>ss</code> keeping track of <code>state</code>. Return <code>true</code> if traversal finished normally; <code>false</code> if one of the visit functions returned <code>false</code> (see )</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/559404d193e901c67c63fc84168872f65889e4eb/src/Experimental/Traversals/Traversals.jl#L92-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.Experimental.Traversals.tree" href="#Graphs.Experimental.Traversals.tree"><code>Graphs.Experimental.Traversals.tree</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tree(g, s, alg, neighborfn=outneighbors)</code></pre><p>Return a directed acyclic graph based on traversal of the graph <code>g</code> starting with source vertex <code>s</code> using algorithm <code>alg</code> with neighbor function <code>neighborfn</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/559404d193e901c67c63fc84168872f65889e4eb/src/Experimental/Traversals/Traversals.jl#L193-L198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.Experimental.Traversals.tree-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:Integer" href="#Graphs.Experimental.Traversals.tree-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:Integer"><code>Graphs.Experimental.Traversals.tree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tree(p)</code></pre><p>Return a directed acyclic graph based on a <a href="#Graphs.Experimental.Traversals.parents-Union{Tuple{T}, Tuple{AbstractGraph{T}, Integer, Graphs.Experimental.Traversals.TraversalAlgorithm}, Tuple{AbstractGraph{T}, Integer, Graphs.Experimental.Traversals.TraversalAlgorithm, Any}} where T"><code>parents</code></a> vector <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/559404d193e901c67c63fc84168872f65889e4eb/src/Experimental/Traversals/Traversals.jl#L177-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.Experimental.Traversals.visited_vertices-Union{Tuple{U}, Tuple{AbstractGraph{U}, AbstractVector, Graphs.Experimental.Traversals.TraversalAlgorithm}} where U&lt;:Integer" href="#Graphs.Experimental.Traversals.visited_vertices-Union{Tuple{U}, Tuple{AbstractGraph{U}, AbstractVector, Graphs.Experimental.Traversals.TraversalAlgorithm}} where U&lt;:Integer"><code>Graphs.Experimental.Traversals.visited_vertices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">visited_vertices(g, s, alg)
visited_vertices(g, ss, alg)</code></pre><p>Return a vector representing the vertices of <code>g</code> visited in order by <a href="#Graphs.Experimental.Traversals.TraversalAlgorithm"><code>TraversalAlgorithm</code></a> <code>alg</code> starting at vertex <code>s</code> (vertices <code>ss</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/559404d193e901c67c63fc84168872f65889e4eb/src/Experimental/Traversals/Traversals.jl#L120-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.Experimental.Traversals.visitfn!-Tuple{Graphs.Experimental.Traversals.AbstractTraversalState, Any, Any}" href="#Graphs.Experimental.Traversals.visitfn!-Tuple{Graphs.Experimental.Traversals.AbstractTraversalState, Any, Any}"><code>Graphs.Experimental.Traversals.visitfn!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">visitfn!(state, u, v)</code></pre><p>Modify <a href="#Graphs.Experimental.Traversals.AbstractTraversalState"><code>AbstractTraversalState</code></a> <code>state</code> when the edge between <code>u</code> and <code>v</code> is encountered, and return <code>true</code> if successful; <code>false</code> otherwise. Note: <code>visitfn!</code> may be called multiple times per edge, depending on the traversal algorithm, for a function that operates on the first occurrence only, use <a href="#Graphs.Experimental.Traversals.newvisitfn!-Tuple{Graphs.Experimental.Traversals.AbstractTraversalState, Any, Any}"><code>newvisitfn!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/559404d193e901c67c63fc84168872f65889e4eb/src/Experimental/Traversals/Traversals.jl#L64-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.Experimental.ShortestPaths.AStar" href="#Graphs.Experimental.ShortestPaths.AStar"><code>Graphs.Experimental.ShortestPaths.AStar</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct AStar &lt;: ShortestPathAlgorithm</code></pre><p>The structure used to configure and specify that <a href="#Graphs.Experimental.ShortestPaths.shortest_paths-Tuple{AbstractGraph, Any, Graphs.Experimental.ShortestPaths.ShortestPathAlgorithm}"><code>shortest_paths</code></a> should use the <a href="http://en.wikipedia.org/wiki/A%2A_search_algorithm">A* search algorithm</a>. An optional <code>heuristic</code> function may be supplied. If missing, the heuristic is set to <code>n -&gt; 0</code>.</p><p><strong>Implementation Notes</strong></p><p><code>AStar</code> supports the following shortest-path functionality:</p><ul><li>non-negative distance matrices / weights</li><li>single destination</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/559404d193e901c67c63fc84168872f65889e4eb/src/Experimental/ShortestPaths/astar.jl#L6-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.Experimental.ShortestPaths.BellmanFord" href="#Graphs.Experimental.ShortestPaths.BellmanFord"><code>Graphs.Experimental.ShortestPaths.BellmanFord</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct BellmanFord &lt;: ShortestPathAlgorithm</code></pre><p>The structure used to configure and specify that <a href="#Graphs.Experimental.ShortestPaths.shortest_paths-Tuple{AbstractGraph, Any, Graphs.Experimental.ShortestPaths.ShortestPathAlgorithm}"><code>shortest_paths</code></a> should use the <a href="http://en.wikipedia.org/wiki/Bellman–Ford_algorithm">Bellman-Ford algorithm</a>. No fields are specified or required.</p><p><strong>Implementation Notes</strong></p><p><code>BellmanFord</code> supports the following shortest-path functionality:</p><ul><li>negative distance matrices / weights</li><li>(optional) multiple sources</li><li>all destinations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/559404d193e901c67c63fc84168872f65889e4eb/src/Experimental/ShortestPaths/bellman-ford.jl#L8-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.Experimental.ShortestPaths.BFS" href="#Graphs.Experimental.ShortestPaths.BFS"><code>Graphs.Experimental.ShortestPaths.BFS</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct BFS &lt;: ShortestPathAlgorithm</code></pre><p>The structure used to configure and specify that <a href="#Graphs.Experimental.ShortestPaths.shortest_paths-Tuple{AbstractGraph, Any, Graphs.Experimental.ShortestPaths.ShortestPathAlgorithm}"><code>shortest_paths</code></a> should use the <a href="https://en.m.wikipedia.org/wiki/Breadth-first_search">Breadth-First Search algorithm</a>.</p><p>An optional sorting algorithm may be specified (default = no sorting). Sorting helps maintain cache locality and will improve performance on very large graphs; for normal use, sorting will incur a performance penalty.</p><p><code>BFS</code> is the default algorithm used when a source is specified but no distance matrix is specified.</p><p><strong>Implementation Notes</strong></p><p><code>BFS</code> supports the following shortest-path functionality:</p><ul><li>(optional) multiple sources</li><li>all destinations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/559404d193e901c67c63fc84168872f65889e4eb/src/Experimental/ShortestPaths/bfs.jl#L3-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.Experimental.ShortestPaths.DEsopoPape" href="#Graphs.Experimental.ShortestPaths.DEsopoPape"><code>Graphs.Experimental.ShortestPaths.DEsopoPape</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct DEsopoPape &lt;: ShortestPathAlgorithm</code></pre><p>The structure used to configure and specify that <a href="#Graphs.Experimental.ShortestPaths.shortest_paths-Tuple{AbstractGraph, Any, Graphs.Experimental.ShortestPaths.ShortestPathAlgorithm}"><code>shortest_paths</code></a> should use the <a href="http://web.mit.edu/dimitrib/www/SLF.pdf">D&#39;Esopo-Pape algorithm</a>. No fields are specified or required.</p><p><strong>Implementation Notes</strong></p><p><code>DEsopoPape</code> supports the following shortest-path functionality:</p><ul><li>non-negative distance matrices / weights</li><li>all destinations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/559404d193e901c67c63fc84168872f65889e4eb/src/Experimental/ShortestPaths/desopo-pape.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.Experimental.ShortestPaths.Dijkstra" href="#Graphs.Experimental.ShortestPaths.Dijkstra"><code>Graphs.Experimental.ShortestPaths.Dijkstra</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Dijkstra &lt;: ShortestPathAlgorithm</code></pre><p>The structure used to configure and specify that <a href="#Graphs.Experimental.ShortestPaths.shortest_paths-Tuple{AbstractGraph, Any, Graphs.Experimental.ShortestPaths.ShortestPathAlgorithm}"><code>shortest_paths</code></a> should use <a href="http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">Dijkstra&#39;s algorithm</a> to compute shortest paths. Optional fields for this structure include</p><ul><li>all_paths::Bool - set to <code>true</code> to calculate all (redundant, equivalent) paths to a given destination</li><li>track_vertices::Bool - set to <code>true</code> to keep a running list of visited vertices (used for specific centrality calculations; generally not needed).</li></ul><p><code>Dijkstra</code> is the default algorithm used when a distance matrix is specified.</p><p><strong>Implementation Notes</strong></p><p><code>Dijkstra</code> supports the following shortest-path functionality:</p><ul><li>non-negative distance matrices / weights</li><li>(optional) multiple sources</li><li>all destinations</li><li>redundant equivalent path tracking</li><li>vertex tracking</li></ul><p><strong>Performance</strong></p><p>If using a sparse matrix for <code>distmx</code> in <a href="#Graphs.Experimental.ShortestPaths.shortest_paths-Tuple{AbstractGraph, Any, Graphs.Experimental.ShortestPaths.ShortestPathAlgorithm}"><code>shortest_paths</code></a>, you <em>may</em> achieve better performance by passing in a transpose of its sparse transpose. That is, assuming <code>D</code> is the sparse distance matrix:</p><pre><code class="nohighlight hljs">D = transpose(sparse(transpose(D)))</code></pre><p>Be aware that realizing the sparse transpose of <code>D</code> incurs a heavy one-time penalty, so this strategy should only be used when multiple calls to <a href="#Graphs.Experimental.ShortestPaths.shortest_paths-Tuple{AbstractGraph, Any, Graphs.Experimental.ShortestPaths.ShortestPathAlgorithm}"><code>shortest_paths</code></a> with the distance matrix are planned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/559404d193e901c67c63fc84168872f65889e4eb/src/Experimental/ShortestPaths/dijkstra.jl#L9-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.Experimental.ShortestPaths.FloydWarshall" href="#Graphs.Experimental.ShortestPaths.FloydWarshall"><code>Graphs.Experimental.ShortestPaths.FloydWarshall</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct FloydWarshall &lt;: ShortestPathAlgorithm</code></pre><p>The structure used to configure and specify that <a href="#Graphs.Experimental.ShortestPaths.shortest_paths-Tuple{AbstractGraph, Any, Graphs.Experimental.ShortestPaths.ShortestPathAlgorithm}"><code>shortest_paths</code></a> should use the <a href="http://en.wikipedia.org/wiki/Floyd–Warshall_algorithm">Floyd-Warshall algorithm</a>. No additional configuration parameters are specified or required.</p><p><code>FloydWarshall</code> is the default all-pairs algorithm used when no source is specified.</p><p><strong>Implementation Notes</strong></p><p><code>FloydWarshall</code> supports the following shortest-path functionality:</p><ul><li>non-negative distance matrices / weights</li><li>all-pairs shortest paths</li></ul><p><strong>Performance</strong></p><p>Space complexity is on the order of <span>$\mathcal{O}(|V|^2)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/559404d193e901c67c63fc84168872f65889e4eb/src/Experimental/ShortestPaths/floyd-warshall.jl#L4-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.Experimental.ShortestPaths.Johnson" href="#Graphs.Experimental.ShortestPaths.Johnson"><code>Graphs.Experimental.ShortestPaths.Johnson</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Johnson &lt;: ShortestPathAlgorithm</code></pre><p>The structure used to configure and specify that <a href="#Graphs.Experimental.ShortestPaths.shortest_paths-Tuple{AbstractGraph, Any, Graphs.Experimental.ShortestPaths.ShortestPathAlgorithm}"><code>shortest_paths</code></a> should use the <a href="https://en.wikipedia.org/wiki/Johnson%27s_algorithm">Johnson algorithm</a>. No additional configuration parameters are specified or required.</p><p><strong>Implementation Notes</strong></p><p><code>Johnson</code> supports the following shortest-path functionality:</p><ul><li>non-negative distance matrices / weights</li><li>all-pairs shortest paths</li></ul><p><strong>Performance</strong></p><p>Complexity: O(|V|*|E|)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/559404d193e901c67c63fc84168872f65889e4eb/src/Experimental/ShortestPaths/johnson.jl#L5-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.Experimental.ShortestPaths.ShortestPathAlgorithm" href="#Graphs.Experimental.ShortestPaths.ShortestPathAlgorithm"><code>Graphs.Experimental.ShortestPaths.ShortestPathAlgorithm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ShortestPathAlgorithm &lt;: AbstractGraphAlgorithm</code></pre><p>Concrete subtypes of <code>ShortestPathAlgorithm</code> are used to specify the type of shortest path calculation used by <a href="#Graphs.Experimental.ShortestPaths.shortest_paths-Tuple{AbstractGraph, Any, Graphs.Experimental.ShortestPaths.ShortestPathAlgorithm}"><code>shortest_paths</code></a>. Some concrete subtypes (most notably <a href="#Graphs.Experimental.ShortestPaths.Dijkstra"><code>Dijkstra</code></a> have fields that specify algorithm parameters.</p><p>See <a href="#Graphs.Experimental.ShortestPaths.AStar"><code>AStar</code></a>, <a href="#Graphs.Experimental.ShortestPaths.BellmanFord"><code>BellmanFord</code></a>, <a href="#Graphs.Experimental.ShortestPaths.BFS"><code>BFS</code></a>, <a href="#Graphs.Experimental.ShortestPaths.DEsopoPape"><code>DEsopoPape</code></a>, <a href="#Graphs.Experimental.ShortestPaths.Dijkstra"><code>Dijkstra</code></a>, <a href="#Graphs.Experimental.ShortestPaths.FloydWarshall"><code>FloydWarshall</code></a>, <a href="#Graphs.Experimental.ShortestPaths.Johnson"><code>Johnson</code></a>, and <a href="#Graphs.Experimental.ShortestPaths.SPFA"><code>SPFA</code></a> for specific requirements and usage details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/559404d193e901c67c63fc84168872f65889e4eb/src/Experimental/ShortestPaths/ShortestPaths.jl#L36-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.Experimental.ShortestPaths.ShortestPathResult" href="#Graphs.Experimental.ShortestPaths.ShortestPathResult"><code>Graphs.Experimental.ShortestPaths.ShortestPathResult</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ShortestPathResult &lt;: AbstractGraphResult</code></pre><p>Concrete subtypes of <code>ShortestPathResult</code> contain the results of a shortest-path calculation using a specific <a href="#Graphs.Experimental.ShortestPaths.ShortestPathAlgorithm"><code>ShortestPathAlgorithm</code></a>.</p><p>In general, the fields in these structs should not be accessed directly; use the <a href="#Graphs.Experimental.ShortestPaths.dists-Tuple{Graphs.Experimental.ShortestPaths.ShortestPathResult, Integer}"><code>dists</code></a> and <a href="#Graphs.Experimental.ShortestPaths.paths-Tuple{Graphs.Experimental.ShortestPaths.ShortestPathResult, AbstractVector{&lt;:Integer}}"><code>paths</code></a> functions to obtain the results of the calculation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/559404d193e901c67c63fc84168872f65889e4eb/src/Experimental/ShortestPaths/ShortestPaths.jl#L22-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.Experimental.ShortestPaths.dists-Tuple{Graphs.Experimental.ShortestPaths.ShortestPathResult, Integer}" href="#Graphs.Experimental.ShortestPaths.dists-Tuple{Graphs.Experimental.ShortestPaths.ShortestPathResult, Integer}"><code>Graphs.Experimental.ShortestPaths.dists</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dists(state[, v])</code></pre><p>Given the output of a <a href="#Graphs.Experimental.ShortestPaths.shortest_paths-Tuple{AbstractGraph, Any, Graphs.Experimental.ShortestPaths.ShortestPathAlgorithm}"><code>shortest_paths</code></a> calculation of type <a href="#Graphs.Experimental.ShortestPaths.ShortestPathResult"><code>ShortestPathResult</code></a>, return a vector (indexed by vertex) of the distances between the source vertex used to compute the shortest path and a single destination vertex <code>v</code> or the entire graph.</p><p>For <a href="#Graphs.Experimental.ShortestPaths.ShortestPathAlgorithm"><code>ShortestPathAlgorithm</code></a>s that compute all-pairs shortest paths, <code>dists(state)</code> will return a matrix (indexed by source and destination vertices) of distances.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/559404d193e901c67c63fc84168872f65889e4eb/src/Experimental/ShortestPaths/ShortestPaths.jl#L161-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.Experimental.ShortestPaths.has_negative_weight_cycle" href="#Graphs.Experimental.ShortestPaths.has_negative_weight_cycle"><code>Graphs.Experimental.ShortestPaths.has_negative_weight_cycle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">has_negative_weight_cycle(g[, distmx=weights(g), alg=BellmanFord()])</code></pre><p>Given a graph <code>g</code>, an optional distance matrix <code>distmx</code>, and an optional algorithm <code>alg</code> (one of <a href="#Graphs.Experimental.ShortestPaths.BellmanFord"><code>BellmanFord</code></a> or <a href="#Graphs.Experimental.ShortestPaths.SPFA"><code>SPFA</code></a>), return <code>true</code> if any cycle detected in the graph has a negative weight.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; using Graphs

julia&gt; g = complete_graph(3);

julia&gt; d = [1 -3 1; -3 1 1; 1 1 1];

julia&gt; has_negative_weight_cycle(g, d)
true

julia&gt; g = complete_graph(4);

julia&gt; d = [1 1 -1 1; 1 1 -1 1; 1 1 1 1; 1 1 1 1];

julia&gt; has_negative_weight_cycle(g, d, SPFA())
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/559404d193e901c67c63fc84168872f65889e4eb/src/Experimental/ShortestPaths/ShortestPaths.jl#L176-L201">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.Experimental.ShortestPaths.paths-Tuple{Graphs.Experimental.ShortestPaths.ShortestPathResult, AbstractVector{&lt;:Integer}}" href="#Graphs.Experimental.ShortestPaths.paths-Tuple{Graphs.Experimental.ShortestPaths.ShortestPathResult, AbstractVector{&lt;:Integer}}"><code>Graphs.Experimental.ShortestPaths.paths</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">paths(state[, v])
paths(state[, vs])
paths(state[, v, d]))</code></pre><p>Given the output of a <a href="#Graphs.Experimental.ShortestPaths.shortest_paths-Tuple{AbstractGraph, Any, Graphs.Experimental.ShortestPaths.ShortestPathAlgorithm}"><code>shortest_paths</code></a> calculation of type <a href="#Graphs.Experimental.ShortestPaths.ShortestPathResult"><code>ShortestPathResult</code></a>, return a vector (indexed by vertex) of the paths between the source vertex used to compute the shortest path and a single destination vertex <code>v</code>, a vector of destination vertices <code>vs</code>, or the entire graph.</p><p>For multiple destination vertices, each path is represented by a vector of vertices on the path between the source and the destination. Nonexistent paths will be indicated by an empty vector. For single destinations, the path is represented by a single vector of vertices, and will be length 0 if the path does not exist.</p><p>For <a href="#Graphs.Experimental.ShortestPaths.ShortestPathAlgorithm"><code>ShortestPathAlgorithm</code></a>s that compute all shortest paths for all pairs of vertices, <code>paths(state)</code> will return a vector (indexed by source vertex) of vectors (indexed by destination vertex) of paths. <code>paths(state, v)</code> will return a vector (indexed by destination vertex) of paths from source <code>v</code> to all other vertices. In addition, <code>paths(state, v, d)</code> will return a vector representing the path from vertex <code>v</code> to vertex <code>d</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/559404d193e901c67c63fc84168872f65889e4eb/src/Experimental/ShortestPaths/ShortestPaths.jl#L114-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.Experimental.ShortestPaths.shortest_paths-Tuple{AbstractGraph, Any, Graphs.Experimental.ShortestPaths.ShortestPathAlgorithm}" href="#Graphs.Experimental.ShortestPaths.shortest_paths-Tuple{AbstractGraph, Any, Graphs.Experimental.ShortestPaths.ShortestPathAlgorithm}"><code>Graphs.Experimental.ShortestPaths.shortest_paths</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">shortest_paths(g, s, distmx, alg)
shortest_paths(g, s, t, alg)
shortest_paths(g, s, alg)
shortest_paths(g, s)
shortest_paths(g)</code></pre><p>Return a <code>ShortestPathResult</code> that allows construction of the shortest path between sets of vertices in graph <code>g</code>. Depending on the algorithm specified, other information may be required: (e.g., a distance matrix <code>distmx</code>, and/or a target vertex <code>t</code>). Some algorithms will accept multiple source vertices <code>s</code>; algorithms that do not accept any source vertex <code>s</code> produce all-pairs shortest paths.</p><p>See <code>ShortestPathAlgorithm</code> for more details on the algorithm specifications.</p><p><strong>Implementation Notes</strong></p><p>The elements of <code>distmx</code> may be of any type that has a <a href="https://en.m.wikipedia.org/wiki/Total_order">Total Ordering</a> and valid comparator, <code>zero</code> and <code>typemax</code> functions. Concretely, this means that distance matrices containing complex numbers are invalid.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">g = path_graph(4)
w = zeros(4, 4)
for i in 1:3
    w[i, i+1] = 1.0
    w[i+1, i] = 1.0
end

s1 = shortest_paths(g)                   # `alg` defaults to `FloydWarshall`
s2 = shortest_paths(g, 1)                # `alg` defaults to `BFS`
s3 = shortest_paths(g, 1, w)             # `alg` defaults to `Dijkstra`
s4 = shortest_paths(g, 1, BellmanFord())
s5 = shortest_paths(g, 1, w, DEsopoPape())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/559404d193e901c67c63fc84168872f65889e4eb/src/Experimental/ShortestPaths/ShortestPaths.jl#L64-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.Experimental.ShortestPaths.SPFA" href="#Graphs.Experimental.ShortestPaths.SPFA"><code>Graphs.Experimental.ShortestPaths.SPFA</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct SPFA &lt;: ShortestPathAlgorithm</code></pre><p>The structure used to configure and specify that <a href="#Graphs.Experimental.ShortestPaths.shortest_paths-Tuple{AbstractGraph, Any, Graphs.Experimental.ShortestPaths.ShortestPathAlgorithm}"><code>shortest_paths</code></a> should use the <a href="https://en.wikipedia.org/wiki/Shortest_Path_Faster_Algorithm">Shortest Path Faster Algorithm</a>. No additional configuration parameters are specified or required.</p><p><strong>Implementation Notes</strong></p><p><code>SPFA</code> supports the following shortest-path functionality:</p><ul><li>non-negative distance matrices / weights</li><li>all destinations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/559404d193e901c67c63fc84168872f65889e4eb/src/Experimental/ShortestPaths/spfa.jl#L11-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.Experimental.ShortestPaths.has_negative_weight_cycle-Tuple{AbstractGraph, AbstractMatrix, Graphs.Experimental.ShortestPaths.SPFA}" href="#Graphs.Experimental.ShortestPaths.has_negative_weight_cycle-Tuple{AbstractGraph, AbstractMatrix, Graphs.Experimental.ShortestPaths.SPFA}"><code>Graphs.Experimental.ShortestPaths.has_negative_weight_cycle</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Function which returns true if there is any negative weight cycle in the graph.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; using Graphs

julia&gt; g = complete_graph(3);

julia&gt; d = [1 -3 1; -3 1 1; 1 1 1];

julia&gt; has_negative_weight_cycle(g, d, SPFA())
true

julia&gt; g = complete_graph(4);

julia&gt; d = [1 1 -1 1; 1 1 -1 1; 1 1 1 1; 1 1 1 1];

julia&gt; has_negative_weight_cycle(g, d, SPFA());
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/559404d193e901c67c63fc84168872f65889e4eb/src/Experimental/ShortestPaths/spfa.jl#L79-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.Experimental.Parallel.gdistances!-Union{Tuple{T}, Tuple{AbstractGraph{T}, Vector{&lt;:Integer}, Vector{T}}} where T&lt;:Integer" href="#Graphs.Experimental.Parallel.gdistances!-Union{Tuple{T}, Tuple{AbstractGraph{T}, Vector{&lt;:Integer}, Vector{T}}} where T&lt;:Integer"><code>Graphs.Experimental.Parallel.gdistances!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gdistances!(g, sources, vert_level; queue_segment_size=20)
gdistances!(g, source, vert_level; queue_segment_size=20)</code></pre><p>Parallel implementation of <a href="../../algorithms/traversals/#Graphs.gdistances!-Union{Tuple{T}, Tuple{AbstractGraph{T}, Any, Any}} where T"><code>Graphs.gdistances!</code></a> with dynamic load balancing.</p><p><strong>Optional Arguments</strong></p><ul><li><code>queue_segment_size = 20</code>: It is the number of vertices a thread can claim from a queue</li></ul><p>at a time. For graphs with uniform degree, a larger value of <code>queue_segment_size</code> could improve performance.</p><p><strong>References</strong></p><ul><li>[Avoiding Locks and Atomic Instructions in Shared-Memory Parallel BFS Using Optimistic</li></ul><p>Parallelization](https://www.computer.org/csdl/proceedings/ipdpsw/2013/4979/00/4979b628-abs.html).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/559404d193e901c67c63fc84168872f65889e4eb/src/Experimental/Parallel/traversals/gdistances.jl#L23-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.Experimental.Parallel.gdistances-Union{Tuple{T}, Tuple{AbstractGraph{T}, Vector{&lt;:Integer}}} where T&lt;:Integer" href="#Graphs.Experimental.Parallel.gdistances-Union{Tuple{T}, Tuple{AbstractGraph{T}, Vector{&lt;:Integer}}} where T&lt;:Integer"><code>Graphs.Experimental.Parallel.gdistances</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gdistances(g, sources; queue_segment_size=20)
gdistances(g, source; queue_segment_size=20)</code></pre><p>Parallel implementation of <a href="../../algorithms/traversals/#Graphs.gdistances!-Union{Tuple{T}, Tuple{AbstractGraph{T}, Any, Any}} where T"><code>Graphs.gdistances!</code></a> with dynamic load balancing.</p><p><strong>Optional Arguments</strong></p><ul><li><code>queue_segment_size = 20</code>: It is the number of vertices a thread can claim from a queue at a time.</li></ul><p>For denser graphs, a smaller value of <code>queue_segment_size</code> could improve performance.</p><p><strong>References</strong></p><ul><li>[Avoiding Locks and Atomic Instructions in Shared-Memory Parallel BFS Using Optimistic</li></ul><p>Parallelization](https://www.computer.org/csdl/proceedings/ipdpsw/2013/4979/00/4979b628-abs.html).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/559404d193e901c67c63fc84168872f65889e4eb/src/Experimental/Parallel/traversals/gdistances.jl#L130-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.Experimental.Parallel.partition_sources!-Union{Tuple{T}, Tuple{Array{Vector{T}, 1}, Vector{&lt;:Integer}, Vector{Bool}}} where T&lt;:Integer" href="#Graphs.Experimental.Parallel.partition_sources!-Union{Tuple{T}, Tuple{Array{Vector{T}, 1}, Vector{&lt;:Integer}, Vector{Bool}}} where T&lt;:Integer"><code>Graphs.Experimental.Parallel.partition_sources!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">partition_sources!(queue_list, sources)</code></pre><p>Partition <code>sources</code> using <a href="../../algorithms/utils/#Graphs.unweighted_contiguous_partition-Tuple{Integer, Integer}"><code>Graphs.unweighted_contiguous_partition</code></a> and place the i^{th} partition  into <code>queue_list[i]</code> and set to empty_list[i] to true if the i^{th} partition is empty.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/559404d193e901c67c63fc84168872f65889e4eb/src/Experimental/Parallel/traversals/gdistances.jl#L6-L12">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../errorhandling/">« Error handling</a><a class="docs-footer-nextpage" href="../parallel/">Parallel algorithms »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Thursday 21 September 2023 19:12">Thursday 21 September 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
