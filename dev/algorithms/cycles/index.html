<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Cycles · Graphs.jl</title><meta name="title" content="Cycles · Graphs.jl"/><meta property="og:title" content="Cycles · Graphs.jl"/><meta property="twitter:title" content="Cycles · Graphs.jl"/><meta name="description" content="Documentation for Graphs.jl."/><meta property="og:description" content="Documentation for Graphs.jl."/><meta property="twitter:description" content="Documentation for Graphs.jl."/><meta property="og:url" content="https://gdalle.github.io/Graphs.jl/algorithms/cycles/"/><meta property="twitter:url" content="https://gdalle.github.io/Graphs.jl/algorithms/cycles/"/><link rel="canonical" href="https://gdalle.github.io/Graphs.jl/algorithms/cycles/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Graphs.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Graphs.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><input class="collapse-toggle" id="menuitem-1" type="checkbox"/><label class="tocitem" for="menuitem-1"><span class="docs-label">First steps</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../">Graphs.jl</a></li><li><a class="tocitem" href="../../first_steps/theory/">Basics of graph theory</a></li><li><a class="tocitem" href="../../first_steps/construction/">Graph construction</a></li><li><a class="tocitem" href="../../first_steps/access/">Graph access</a></li><li><a class="tocitem" href="../../first_steps/paths_traversal/">Paths and traversal</a></li><li><a class="tocitem" href="../../first_steps/plotting/">Graph plotting</a></li><li><a class="tocitem" href="../../first_steps/persistence/">Reading and writing graphs</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Ecosystem</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../ecosystem/graphtypes/">Graph types</a></li><li><a class="tocitem" href="../../ecosystem/interface/">Creating your own graph format</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Core API</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../core_functions/core/">Core functions</a></li><li><a class="tocitem" href="../../core_functions/interface/">AbstractGraph interface</a></li><li><a class="tocitem" href="../../core_functions/module/">Module</a></li><li><a class="tocitem" href="../../core_functions/operators/">Operators</a></li><li><a class="tocitem" href="../../core_functions/persistence/">Reading and writing files</a></li><li><a class="tocitem" href="../../core_functions/simplegraphs_generators/">Generators for common graphs</a></li><li><a class="tocitem" href="../../core_functions/simplegraphs/">SimpleGraphs formats</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4"><span class="docs-label">Algorithms API</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../biconnectivity/">Biconnected graphs</a></li><li><a class="tocitem" href="../centrality/">Centrality measures</a></li><li><a class="tocitem" href="../community/">Community structures</a></li><li><a class="tocitem" href="../connectivity/">Connected components</a></li><li><a class="tocitem" href="../cut/">Cuts</a></li><li class="is-active"><a class="tocitem" href>Cycles</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Full-docs"><span>Full docs</span></a></li></ul></li><li><a class="tocitem" href="../trees/">Trees</a></li><li><a class="tocitem" href="../degeneracy/">Degeneracy</a></li><li><a class="tocitem" href="../digraph/">Directed graphs</a></li><li><a class="tocitem" href="../distance/">Distance</a></li><li><a class="tocitem" href="../dominatingset/">Dominating sets</a></li><li><a class="tocitem" href="../editdist/">Edit distance</a></li><li><a class="tocitem" href="../independentset/">Independent sets</a></li><li><a class="tocitem" href="../linalg/">Linear algebra</a></li><li><a class="tocitem" href="../shortestpaths/">Shortest paths</a></li><li><a class="tocitem" href="../spanningtrees/">Spanning trees</a></li><li><a class="tocitem" href="../steinertree/">Steiner tree</a></li><li><a class="tocitem" href="../traversals/">Traversals and coloring</a></li><li><a class="tocitem" href="../utils/">Utilities</a></li><li><a class="tocitem" href="../vertexcover/">Vertex cover</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">For advanced users</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../advanced/errorhandling/">Error handling</a></li><li><a class="tocitem" href="../../advanced/test/">Test graphs</a></li><li><a class="tocitem" href="../../advanced/experimental/">Experimental algorithms</a></li><li><a class="tocitem" href="../../advanced/parallel/">Parallel algorithms</a></li><li><a class="tocitem" href="../../contributing/">Contributor Guide</a></li><li><a class="tocitem" href="../../license/">License information</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Algorithms API</a></li><li class="is-active"><a href>Cycles</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Cycles</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaGraphs/Graphs.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaGraphs/Graphs.jl/blob/master/docs/src/algorithms/cycles.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Cycles"><a class="docs-heading-anchor" href="#Cycles">Cycles</a><a id="Cycles-1"></a><a class="docs-heading-anchor-permalink" href="#Cycles" title="Permalink"></a></h1><p><em>Graphs.jl</em> contains numerous algorithms related to <a href="https://en.wikipedia.org/wiki/Cycle_(graph_theory)">cycles</a>.</p><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#Graphs.DenseGraphICT_BFGT_N"><code>Graphs.DenseGraphICT_BFGT_N</code></a></li><li><a href="#Graphs.IncrementalCycleTracker"><code>Graphs.IncrementalCycleTracker</code></a></li><li><a href="#Graphs.JohnsonVisitor"><code>Graphs.JohnsonVisitor</code></a></li><li><a href="#Graphs.TransactionalVector"><code>Graphs.TransactionalVector</code></a></li><li><a href="#Graphs.add_edge_checked!"><code>Graphs.add_edge_checked!</code></a></li><li><a href="#Graphs.circuit"><code>Graphs.circuit</code></a></li><li><a href="#Graphs.circuit_iter"><code>Graphs.circuit_iter</code></a></li><li><a href="#Graphs.circuit_recursive!"><code>Graphs.circuit_recursive!</code></a></li><li><a href="#Graphs.cycle_basis"><code>Graphs.cycle_basis</code></a></li><li><a href="#Graphs.itercycles"><code>Graphs.itercycles</code></a></li><li><a href="#Graphs.karp_minimum_cycle_mean"><code>Graphs.karp_minimum_cycle_mean</code></a></li><li><a href="#Graphs.maxsimplecycles"><code>Graphs.maxsimplecycles</code></a></li><li><a href="#Graphs.maxsimplecycles-Tuple{Integer}"><code>Graphs.maxsimplecycles</code></a></li><li><a href="#Graphs.ncycles_n_i-Tuple{Integer, Integer}"><code>Graphs.ncycles_n_i</code></a></li><li><a href="#Graphs.resetB!-Tuple{Any}"><code>Graphs.resetB!</code></a></li><li><a href="#Graphs.resetblocked!-Tuple{Any}"><code>Graphs.resetblocked!</code></a></li><li><a href="#Graphs.simplecycles"><code>Graphs.simplecycles</code></a></li><li><a href="#Graphs.simplecycles_hawick_james"><code>Graphs.simplecycles_hawick_james</code></a></li><li><a href="#Graphs.simplecycles_iter"><code>Graphs.simplecycles_iter</code></a></li><li><a href="#Graphs.simplecycles_limited_length-Union{Tuple{T}, Tuple{AbstractGraph{T}, Int64}, Tuple{AbstractGraph{T}, Int64, Any}} where T"><code>Graphs.simplecycles_limited_length</code></a></li><li><a href="#Graphs.simplecyclescount"><code>Graphs.simplecyclescount</code></a></li><li><a href="#Graphs.simplecycleslength"><code>Graphs.simplecycleslength</code></a></li><li><a href="#Graphs.unblock!-Union{Tuple{T}, Tuple{T, BitVector, Array{Set{T}, 1}}} where T&lt;:Integer"><code>Graphs.unblock!</code></a></li><li><a href="#Graphs.unblock!-Union{Tuple{T}, Tuple{T, AbstractVector, Array{Vector{T}, 1}}} where T"><code>Graphs.unblock!</code></a></li></ul><h2 id="Full-docs"><a class="docs-heading-anchor" href="#Full-docs">Full docs</a><a id="Full-docs-1"></a><a class="docs-heading-anchor-permalink" href="#Full-docs" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Graphs.cycle_basis" href="#Graphs.cycle_basis"><code>Graphs.cycle_basis</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">cycle_basis(g, root=nothing)</code></pre><p>Return a list of cycles which form a basis for cycles of the undirected graph <code>g</code>, optionally starting at node <code>root</code>.</p><p>A basis for cycles of a network is a minimal collection of cycles such that any cycle in the network can be written as a sum of cycles in the basis.  Here summation of cycles is defined as &quot;exclusive or&quot; of the edges. Cycle bases are useful, e.g. when deriving equations for electric circuits using Kirchhoff&#39;s Laws.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Graphs

julia&gt; elist = [(1,2),(2,3),(2,4),(3,4),(4,1),(1,5)];

julia&gt; g = SimpleGraph(Graphs.SimpleEdge.(elist));

julia&gt; cycle_basis(g)
2-element Vector{Vector{Int64}}:
 [2, 4, 1]
 [2, 3, 4]</code></pre><p><strong>References</strong></p><ul><li>Paton, K. An algorithm for finding a fundamental set of cycles of a graph. Comm. ACM 12, 9 (Sept 1969), 514-518. [https://dl.acm.org/citation.cfm?id=363232]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/4e10bf396fb7a1631461003de683a7979ddee996/src/cycles/basis.jl#L3-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Graphs.circuit_recursive!" href="#Graphs.circuit_recursive!"><code>Graphs.circuit_recursive!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">circuit_recursive!(g, v1, v2, blocked, B, stack, cycles)</code></pre><p>Find circuits in <code>g</code> recursively starting from v1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/4e10bf396fb7a1631461003de683a7979ddee996/src/cycles/hawick-james.jl#L42-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Graphs.resetB!-Tuple{Any}" href="#Graphs.resetB!-Tuple{Any}"><code>Graphs.resetB!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">resetB!(B)</code></pre><p>Reset B work structure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/4e10bf396fb7a1631461003de683a7979ddee996/src/cycles/hawick-james.jl#L28-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Graphs.resetblocked!-Tuple{Any}" href="#Graphs.resetblocked!-Tuple{Any}"><code>Graphs.resetblocked!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">resetblocked!(blocked)</code></pre><p>Reset vector of <code>blocked</code> vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/4e10bf396fb7a1631461003de683a7979ddee996/src/cycles/hawick-james.jl#L35-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Graphs.simplecycles_hawick_james" href="#Graphs.simplecycles_hawick_james"><code>Graphs.simplecycles_hawick_james</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">simplecycles_hawick_james(g)</code></pre><p>Find circuits (including self-loops) in <code>g</code> using the algorithm of Hawick &amp; James.</p><p><strong>References</strong></p><ul><li>Hawick &amp; James, &quot;Enumerating Circuits and Loops in Graphs with Self-Arcs and Multiple-Arcs&quot;, 2008</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/4e10bf396fb7a1631461003de683a7979ddee996/src/cycles/hawick-james.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Graphs.unblock!-Union{Tuple{T}, Tuple{T, AbstractVector, Array{Vector{T}, 1}}} where T" href="#Graphs.unblock!-Union{Tuple{T}, Tuple{T, AbstractVector, Array{Vector{T}, 1}}} where T"><code>Graphs.unblock!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unblock!(v, blocked, B)</code></pre><p>Unblock the value <code>v</code> from the <code>blocked</code> list and remove from <code>B</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/4e10bf396fb7a1631461003de683a7979ddee996/src/cycles/hawick-james.jl#L85-L89">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Graphs.DenseGraphICT_BFGT_N" href="#Graphs.DenseGraphICT_BFGT_N"><code>Graphs.DenseGraphICT_BFGT_N</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct DenseGraphICT_BFGT_N</code></pre><p>Implements the &quot;Naive&quot; (Algorithm N) Bender-Fineman-Gilbert-Tarjan one-way line search incremental cycle detector for dense graphs from BFGT15 (Section 3).</p><p><strong>References</strong></p><p>BFGT15: Michael A. Bender, Jeremy T. Fineman, Seth Gilbert, and Robert E. Tarjan. 2015     A New Approach to Incremental Cycle Detection and Related Problems.     ACM Trans. Algorithms 12, 2, Article 14 (December 2015), 22 pages.     DOI: http://dx.doi.org/10.1145/2756553</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/4e10bf396fb7a1631461003de683a7979ddee996/src/cycles/incremental.jl#L172-L179">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Graphs.IncrementalCycleTracker" href="#Graphs.IncrementalCycleTracker"><code>Graphs.IncrementalCycleTracker</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type IncrementalCycleTracker</code></pre><p>The supertype for incremental cycle detection problems. The abstract type constructor IncrementalCycleTracker(G) may be used to automatically select a specific incremental cycle detection algorithm. See <a href="#Graphs.add_edge_checked!"><code>add_edge_checked!</code></a> for a usage example.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/4e10bf396fb7a1631461003de683a7979ddee996/src/cycles/incremental.jl#L5-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Graphs.TransactionalVector" href="#Graphs.TransactionalVector"><code>Graphs.TransactionalVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct TransactionalVector</code></pre><p>A vector with one checkpoint that may be reverted to by calling <code>revert!</code>. The setpoint itself is set by calling <code>commit!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/4e10bf396fb7a1631461003de683a7979ddee996/src/cycles/incremental.jl#L94-L99">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Graphs.add_edge_checked!" href="#Graphs.add_edge_checked!"><code>Graphs.add_edge_checked!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_edge_checked!([f!,], ict::IncrementalCycleTracker, v, w)</code></pre><p>Using the incremental cycle tracker, ict, check whether adding the edge <code>v=&gt;w</code> would introduce a cycle in the underlying graph. If so, return false and leave the ict intact. If not, update the underlying graph and return true.</p><p><strong>Optional <code>f!</code> Argument</strong></p><p>By default the <code>add_edge!</code> function is used to update the underlying graph. However, for more complicated graphs, users may wish to manually specify the graph update operation. This may be accomplished by passing the optional <code>f!</code> callback argument. This callback is called on the underlying graph when no cycle is detected and is required to modify the underlying graph in order to effectuate the proposed edge addition.</p><p><strong>Batched edge additions</strong></p><p>Optionally, either <code>v</code> or <code>w</code> (depending on the <code>in_out_reverse</code> flag) may be a collection of vertices representing a batched addition of vertices sharing a common source or target more efficiently than individual updates.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Graphs

julia&gt; G = SimpleDiGraph(3)
{3, 0} directed simple Int64 graph

julia&gt; ict = IncrementalCycleTracker(G)
BFGT_N cycle tracker on SimpleDiGraph{Int64}(0, [Int64[], Int64[], Int64[]], [Int64[], Int64[], Int64[]])

julia&gt; add_edge_checked!(ict, 1, 2)
true

julia&gt; collect(edges(G))
1-element Vector{Graphs.SimpleGraphs.SimpleEdge{Int64}}:
 Edge 1 =&gt; 2

julia&gt; add_edge_checked!(ict, 2, 3)
true

julia&gt; collect(edges(G))
2-element Vector{Graphs.SimpleGraphs.SimpleEdge{Int64}}:
 Edge 1 =&gt; 2
 Edge 2 =&gt; 3

julia&gt; add_edge_checked!(ict, 3, 1) # Would add a cycle
false

julia&gt; collect(edges(G))
2-element Vector{Graphs.SimpleGraphs.SimpleEdge{Int64}}:
 Edge 1 =&gt; 2
 Edge 2 =&gt; 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/4e10bf396fb7a1631461003de683a7979ddee996/src/cycles/incremental.jl#L24-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Graphs.JohnsonVisitor" href="#Graphs.JohnsonVisitor"><code>Graphs.JohnsonVisitor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">type JohnsonVisitor{T&lt;:Integer} &lt;: Visitor{T}
    stack::Vector{T}
    blocked::BitVector
    blockedmap::Vector{Set{T}}
end

JohnsonVisitor(dg::::IsDirected)
</code></pre><p>Composite type that regroups the information needed for Johnson&#39;s algorithm.</p><p><code>stack</code> is the stack of visited vertices. <code>blocked</code> is a boolean for each vertex that tells whether it is blocked or not. <code>blockedmap</code> tells which vertices to unblock if the key vertex is unblocked.</p><p><code>JohnsonVisitor</code> may also be constructed directly from the directed graph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/4e10bf396fb7a1631461003de683a7979ddee996/src/cycles/johnson.jl#L58-L77">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Graphs.circuit" href="#Graphs.circuit"><code>Graphs.circuit</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">circuit{T&lt;:Integer}(v::T, dg::::IsDirected, vis::JohnsonVisitor{T},
allcycles::Vector{Vector{T}}, vmap::Vector{T}, startnode::T = v)</code></pre><p>Return one step of the recursive version of simple cycle detection, using a DFS algorithm.</p><ul><li><code>v</code>: the vertex considered in this iteration of the DFS</li><li><code>dg</code>: the digraph from which cycles are computed</li><li><code>visitor</code>: Informations needed for the cycle computation, contains:<ul><li><code>stack</code>: the stack of parent vertices</li><li><code>blocked</code>: tells whether a vertex has already been explored or not</li><li><code>blockedmap</code>: mapping of the blocking / unblocking consequences</li></ul></li><li><code>allcycles</code>: output containing the cycles already detected</li><li><code>vmap</code>: vector map containing the link from the old to the new nodes of the directed graph</li><li><code>startnode = v</code>: optional argument giving the starting node. In the first iteration,</li></ul><p>the same as v, otherwise it should be passed.</p><p><strong>Implementation Notes</strong></p><p>Implements Johnson&#39;s CIRCUIT function. This is a recursive version. Modifies the vector of cycles, when needed.</p><p><strong>References</strong></p><ul><li><a href="http://epubs.siam.org/doi/abs/10.1137/0204007">Johnson</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/4e10bf396fb7a1631461003de683a7979ddee996/src/cycles/johnson.jl#L110-L135">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Graphs.circuit_iter" href="#Graphs.circuit_iter"><code>Graphs.circuit_iter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">circuit_iter{T&lt;:Integer}(v::T, dg::::IsDirected, vis::JohnsonVisitor{T},
vmap::Vector{T}, cycle::Channel, startnode::T = v)</code></pre><p>Execute one step of the recursive version of simple cycle detection, using a DFS algorithm. Return <code>true</code> if a circuit has been found in the current exploration.</p><p><strong>Arguments</strong></p><ul><li>v: the vertex considered in this iteration of the DFS</li><li>dg: the digraph from which cycles are computed</li><li>visitor: information needed for the cycle computation, contains:<ul><li>stack: the stack of parent vertices</li><li>blocked: tells whether a vertex has already been explored or not</li><li>blockedmap: mapping of the blocking / unblocking consequences</li></ul></li><li><code>vmap</code>: vector map containing the link from the old to the new nodes of the directed graph</li><li><code>cycle</code>: storage of the channel</li><li>startnode = v: optional argument giving the starting node. In the first iteration,</li></ul><p>the same as v, otherwise it should be passed.</p><p><strong>Implementation Notes</strong></p><p>Implements the CIRCUIT function from Johnson&#39;s algorithm, recursive and iterative version. Produces a cycle when needed. Can be used only inside a <code>Channel</code>.</p><p><strong>References</strong></p><ul><li><a href="http://epubs.siam.org/doi/abs/10.1137/0204007">Johnson</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/4e10bf396fb7a1631461003de683a7979ddee996/src/cycles/johnson.jl#L214-L239">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Graphs.itercycles" href="#Graphs.itercycles"><code>Graphs.itercycles</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">itercycles(dg::::IsDirected, cycle::Channel)</code></pre><p>Compute all cycles of the given directed graph, using Johnson&#39;s algorithm.</p><p><strong>Implementation Notes</strong></p><p>Iterative version of the algorithm, using <code>Channel</code>s to stop the exploration after a given number of cycles.</p><p><strong>References</strong></p><ul><li><a href="http://epubs.siam.org/doi/abs/10.1137/0204007">Johnson</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/4e10bf396fb7a1631461003de683a7979ddee996/src/cycles/johnson.jl#L273-L284">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Graphs.maxsimplecycles" href="#Graphs.maxsimplecycles"><code>Graphs.maxsimplecycles</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">maxsimplecycles(dg::::IsDirected, byscc::Bool = true)</code></pre><p>Compute the theoretical maximum number of cycles in the directed graph <code>dg</code>.</p><p>The computation can be performed assuming the graph is complete or taking into account the decomposition in strongly connected components (<code>byscc</code> parameter).</p><p><strong>Performance</strong></p><p>A more efficient version is possible.</p><p><strong>References</strong></p><ul><li><a href="http://epubs.siam.org/doi/abs/10.1137/0204007">Johnson</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/4e10bf396fb7a1631461003de683a7979ddee996/src/cycles/johnson.jl#L28-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Graphs.maxsimplecycles-Tuple{Integer}" href="#Graphs.maxsimplecycles-Tuple{Integer}"><code>Graphs.maxsimplecycles</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">maxsimplecycles(n::Integer)</code></pre><p>Compute the theoretical maximum number of cycles in a directed graph of <code>n</code> vertices, assuming there are no self-loops.</p><p><strong>References</strong></p><ul><li><a href="http://epubs.siam.org/doi/abs/10.1137/0204007">Johnson</a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/4e10bf396fb7a1631461003de683a7979ddee996/src/cycles/johnson.jl#L17-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Graphs.ncycles_n_i-Tuple{Integer, Integer}" href="#Graphs.ncycles_n_i-Tuple{Integer, Integer}"><code>Graphs.ncycles_n_i</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ncycles_n_i(n::Integer, i::Integer)</code></pre><p>Compute the theoretical maximum number of cycles of size <code>i</code> in a directed graph of <code>n</code>  vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/4e10bf396fb7a1631461003de683a7979ddee996/src/cycles/johnson.jl#L7-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Graphs.simplecycles" href="#Graphs.simplecycles"><code>Graphs.simplecycles</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">simplecycles(dg::::IsDirected)</code></pre><p>Compute and return all cycles of the given directed graph using Johnson&#39;s algorithm.</p><p><strong>Performance</strong></p><p>The number of cycles grows more than exponentially with the number of vertices, you might want to use the algorithm with a ceiling – <a href="#Graphs.simplecycles_iter"><code>simplecycles_iter</code></a> – on large directed graphs (slightly slower). If you want to have an idea of the possible number of cycles, look at function <code>maxsimplecycles(dg::DiGraph, byscc::Bool = true)</code>. If you only need short cycles of a limited length, <a href="#Graphs.simplecycles_limited_length-Union{Tuple{T}, Tuple{AbstractGraph{T}, Int64}, Tuple{AbstractGraph{T}, Int64, Any}} where T"><code>simplecycles_limited_length</code></a> can be more efficient.</p><p><strong>References</strong></p><ul><li><a href="http://epubs.siam.org/doi/abs/10.1137/0204007">Johnson</a></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Graphs

julia&gt; simplecycles(complete_digraph(3))
5-element Vector{Vector{Int64}}:
 [1, 2]
 [1, 2, 3]
 [1, 3]
 [1, 3, 2]
 [2, 3]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/4e10bf396fb7a1631461003de683a7979ddee996/src/cycles/johnson.jl#L169-L196">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Graphs.simplecycles_iter" href="#Graphs.simplecycles_iter"><code>Graphs.simplecycles_iter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">simplecycles_iter(dg::DiGraph, ceiling = 10^6)</code></pre><p>Search all cycles of the given directed graph, using Johnson&#39;s algorithm, up to the ceiling (to avoid memory overload).</p><p><strong>Implementation Notes</strong></p><p>If the graph is small, the ceiling will not be reached and <code>simplecycles(dg::DiGraph)</code> is more efficient. It avoids the overhead of the counting and testing if the ceiling is reached. It returns all the cycles of the directed graph if the <code>ceiling</code> is not reached, a subset of them otherwise.</p><p>To get an idea of the possible number of cycles, use function `maxsimplecycles(dg::DiGraph, byscc::Bool = true) on the directed graph.</p><p><strong>References</strong></p><ul><li><a href="http://epubs.siam.org/doi/abs/10.1137/0204007">Johnson</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/4e10bf396fb7a1631461003de683a7979ddee996/src/cycles/johnson.jl#L336-L353">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Graphs.simplecyclescount" href="#Graphs.simplecyclescount"><code>Graphs.simplecyclescount</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">simplecyclescount(dg::DiGraph, ceiling = 10^6)</code></pre><p>Count the number of cycles in a directed graph, using Johnson&#39;s algorithm. Return the minimum of the ceiling and the number of cycles.</p><p><strong>Implementation Notes</strong></p><p>The <code>ceiling</code> is here to avoid memory overload if there are a lot of cycles in the graph. Default value is 10^6, but it can be higher or lower. You can use the function <code>maxsimplecycles(dg::DiGraph, byscc::Bool = true)</code> to get an idea of the theoretical maximum number or cycles.</p><p><strong>References</strong></p><ul><li><a href="http://epubs.siam.org/doi/abs/10.1137/0204007">Johnson</a></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Graphs

julia&gt; simplecyclescount(complete_digraph(6))
409</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/4e10bf396fb7a1631461003de683a7979ddee996/src/cycles/johnson.jl#L300-L322">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Graphs.simplecycleslength" href="#Graphs.simplecycleslength"><code>Graphs.simplecycleslength</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">simplecycleslength(dg::DiGraph, ceiling = 10^6)</code></pre><p>Search all cycles of the given directed graph, using Johnson&#39;s algorithm, and return a tuple representing the cycle length and the number of cycles.</p><p><strong>Implementation Notes</strong></p><p>To get an idea of the possible number of cycles, using function <code>maxsimplecycles(dg::DiGraph, byscc::Bool = true)</code> on the directed graph.</p><p>If the <code>ceiling</code> is reached (<code>ncycles = ceiling</code>), the output is only a subset of the cycles lengths.</p><p><strong>References</strong></p><ul><li><a href="http://epubs.siam.org/doi/abs/10.1137/0204007">Johnson</a></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Graphs

julia&gt; simplecycleslength(complete_digraph(16))
([0, 1, 1, 1, 1, 1, 2, 10, 73, 511, 3066, 15329, 61313, 183939, 367876, 367876], 1000000)

julia&gt; simplecycleslength(wheel_digraph(16))
([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/4e10bf396fb7a1631461003de683a7979ddee996/src/cycles/johnson.jl#L363-L389">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Graphs.unblock!-Union{Tuple{T}, Tuple{T, BitVector, Array{Set{T}, 1}}} where T&lt;:Integer" href="#Graphs.unblock!-Union{Tuple{T}, Tuple{T, BitVector, Array{Set{T}, 1}}} where T&lt;:Integer"><code>Graphs.unblock!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unblock!{T&lt;:Integer}(v::T, blocked::BitVector, B::Vector{Set{T}})</code></pre><p>Unblock the vertices recursively.</p><p><code>v</code> is the vertex to unblock, <code>blocked</code> tells whether a vertex is blocked or not and <code>B</code> is the map that tells if the unblocking of one vertex should unblock other vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/4e10bf396fb7a1631461003de683a7979ddee996/src/cycles/johnson.jl#L91-L99">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Graphs.karp_minimum_cycle_mean" href="#Graphs.karp_minimum_cycle_mean"><code>Graphs.karp_minimum_cycle_mean</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">karp_minimum_cycle_mean(g[, distmx])</code></pre><p>Return minimum cycle mean of the directed graph <code>g</code> with optional edge weights contained in <code>distmx</code>.</p><p><strong>References</strong></p><ul><li><a href="http://dx.doi.org/10.1016/0012-365X(78)90011-0">Karp</a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/4e10bf396fb7a1631461003de683a7979ddee996/src/cycles/karp.jl#L86-L93">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Graphs.simplecycles_limited_length-Union{Tuple{T}, Tuple{AbstractGraph{T}, Int64}, Tuple{AbstractGraph{T}, Int64, Any}} where T" href="#Graphs.simplecycles_limited_length-Union{Tuple{T}, Tuple{AbstractGraph{T}, Int64}, Tuple{AbstractGraph{T}, Int64, Any}} where T"><code>Graphs.simplecycles_limited_length</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">simplecycles_limited_length(g, n, ceiling=10^6)</code></pre><p>Compute and return at most <code>ceiling</code> cycles of length at most <code>n</code> of the given graph. Both directed and undirected graphs are supported.</p><p><strong>Performance</strong></p><p>The number of cycles grows very fast with the number of vertices and the allowed length of the cycles. This function is intended for finding short cycles. If you want to find cycles of any length in a directed graph, <a href="#Graphs.simplecycles"><code>simplecycles</code></a> or <a href="#Graphs.simplecycles_iter"><code>simplecycles_iter</code></a> may be more efficient.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/4e10bf396fb7a1631461003de683a7979ddee996/src/cycles/limited_length.jl#L1-L13">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../cut/">« Cuts</a><a class="docs-footer-nextpage" href="../trees/">Trees »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Wednesday 3 April 2024 05:07">Wednesday 3 April 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
