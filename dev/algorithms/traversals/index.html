<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Traversals and coloring · Graphs.jl</title><link rel="canonical" href="https://gdalle.github.io/Graphs.jl/algorithms/traversals/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Graphs.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Graphs.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><input class="collapse-toggle" id="menuitem-1" type="checkbox"/><label class="tocitem" for="menuitem-1"><span class="docs-label">First steps</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../">Graphs.jl</a></li><li><a class="tocitem" href="../../first_steps/theory/">Basics of graph theory</a></li><li><a class="tocitem" href="../../first_steps/construction/">Graph construction</a></li><li><a class="tocitem" href="../../first_steps/access/">Graph access</a></li><li><a class="tocitem" href="../../first_steps/paths_traversal/">Paths and traversal</a></li><li><a class="tocitem" href="../../first_steps/plotting/">Graph plotting</a></li><li><a class="tocitem" href="../../first_steps/persistence/">Reading and writing graphs</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Ecosystem</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../ecosystem/graphtypes/">Graph types</a></li><li><a class="tocitem" href="../../ecosystem/interface/">Creating your own graph format</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Core API</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../core_functions/core/">Core functions</a></li><li><a class="tocitem" href="../../core_functions/interface/">AbstractGraph interface</a></li><li><a class="tocitem" href="../../core_functions/module/">Module</a></li><li><a class="tocitem" href="../../core_functions/operators/">Operators</a></li><li><a class="tocitem" href="../../core_functions/persistence/">Reading and writing files</a></li><li><a class="tocitem" href="../../core_functions/simplegraphs_generators/">Generators for common graphs</a></li><li><a class="tocitem" href="../../core_functions/simplegraphs/">SimpleGraphs formats</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4"><span class="docs-label">Algorithms API</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../biconnectivity/">Biconnected graphs</a></li><li><a class="tocitem" href="../centrality/">Centrality measures</a></li><li><a class="tocitem" href="../community/">Community structures</a></li><li><a class="tocitem" href="../connectivity/">Connected components</a></li><li><a class="tocitem" href="../cut/">Cuts</a></li><li><a class="tocitem" href="../cycles/">Cycles</a></li><li><a class="tocitem" href="../degeneracy/">Degeneracy</a></li><li><a class="tocitem" href="../digraph/">Directed graphs</a></li><li><a class="tocitem" href="../distance/">Distance</a></li><li><a class="tocitem" href="../dominatingset/">Dominating sets</a></li><li><a class="tocitem" href="../editdist/">Edit distance</a></li><li><a class="tocitem" href="../independentset/">Independent sets</a></li><li><a class="tocitem" href="../linalg/">Linear algebra</a></li><li><a class="tocitem" href="../shortestpaths/">Shortest paths</a></li><li><a class="tocitem" href="../spanningtrees/">Spanning trees</a></li><li><a class="tocitem" href="../steinertree/">Steiner tree</a></li><li class="is-active"><a class="tocitem" href>Traversals and coloring</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Full-docs"><span>Full docs</span></a></li></ul></li><li><a class="tocitem" href="../utils/">Utilities</a></li><li><a class="tocitem" href="../vertexcover/">Vertex cover</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">For advanced users</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../advanced/errorhandling/">Error handling</a></li><li><a class="tocitem" href="../../advanced/experimental/">Experimental algorithms</a></li><li><a class="tocitem" href="../../advanced/parallel/">Parallel algorithms</a></li><li><a class="tocitem" href="../../contributing/">Contributor Guide</a></li><li><a class="tocitem" href="../../license/">License information</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Algorithms API</a></li><li class="is-active"><a href>Traversals and coloring</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Traversals and coloring</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaGraphs/Graphs.jl/blob/master/docs/src/algorithms/traversals.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Traversals-and-coloring"><a class="docs-heading-anchor" href="#Traversals-and-coloring">Traversals and coloring</a><a id="Traversals-and-coloring-1"></a><a class="docs-heading-anchor-permalink" href="#Traversals-and-coloring" title="Permalink"></a></h1><p><em>Graphs.jl</em> includes various routines for exploring graphs.</p><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#Graphs.Coloring"><code>Graphs.Coloring</code></a></li><li><a href="#Graphs.bfs_parents-Tuple{AbstractGraph, Integer}"><code>Graphs.bfs_parents</code></a></li><li><a href="#Graphs.bfs_tree-Tuple{AbstractGraph, Integer}"><code>Graphs.bfs_tree</code></a></li><li><a href="#Graphs.bipartite_map-Union{Tuple{AbstractGraph{T}}, Tuple{T}} where T"><code>Graphs.bipartite_map</code></a></li><li><a href="#Graphs.degree_greedy_color-Union{Tuple{AbstractGraph{T}}, Tuple{T}} where T&lt;:Integer"><code>Graphs.degree_greedy_color</code></a></li><li><a href="#Graphs.dfs_parents-Tuple{AbstractGraph, Integer}"><code>Graphs.dfs_parents</code></a></li><li><a href="#Graphs.dfs_tree-Tuple{AbstractGraph, Integer}"><code>Graphs.dfs_tree</code></a></li><li><a href="#Graphs.diffusion-Union{Tuple{T}, Tuple{AbstractGraph{T}, Real, Integer}} where T"><code>Graphs.diffusion</code></a></li><li><a href="#Graphs.diffusion_rate-Union{Tuple{Array{Vector{T}, 1}}, Tuple{T}} where T&lt;:Integer"><code>Graphs.diffusion_rate</code></a></li><li><a href="#Graphs.gdistances-Union{Tuple{T}, Tuple{AbstractGraph{T}, Any}} where T"><code>Graphs.gdistances</code></a></li><li><a href="#Graphs.gdistances!-Union{Tuple{T}, Tuple{AbstractGraph{T}, Any, Any}} where T"><code>Graphs.gdistances!</code></a></li><li><a href="#Graphs.greedy_color-Union{Tuple{AbstractGraph{U}}, Tuple{U}} where U&lt;:Integer"><code>Graphs.greedy_color</code></a></li><li><a href="#Graphs.has_path-Union{Tuple{T}, Tuple{AbstractGraph{T}, Integer, Integer}} where T"><code>Graphs.has_path</code></a></li><li><a href="#Graphs.is_bipartite-Tuple{AbstractGraph}"><code>Graphs.is_bipartite</code></a></li><li><a href="#Graphs.is_cyclic"><code>Graphs.is_cyclic</code></a></li><li><a href="#Graphs.maximum_adjacency_visit-Union{Tuple{T}, Tuple{U}, Tuple{AbstractGraph{U}, AbstractMatrix{T}}, Tuple{AbstractGraph{U}, AbstractMatrix{T}, Bool}, Tuple{AbstractGraph{U}, AbstractMatrix{T}, Bool, IO}, Tuple{AbstractGraph{U}, AbstractMatrix{T}, Bool, IO, U}} where {U, T&lt;:Real}"><code>Graphs.maximum_adjacency_visit</code></a></li><li><a href="#Graphs.mincut-Union{Tuple{AbstractGraph}, Tuple{T}, Tuple{AbstractGraph, AbstractMatrix{T}}} where T&lt;:Real"><code>Graphs.mincut</code></a></li><li><a href="#Graphs.non_backtracking_randomwalk"><code>Graphs.non_backtracking_randomwalk</code></a></li><li><a href="#Graphs.perm_greedy_color-Union{Tuple{T}, Tuple{AbstractGraph, Vector{T}}} where T&lt;:Integer"><code>Graphs.perm_greedy_color</code></a></li><li><a href="#Graphs.random_greedy_color-Union{Tuple{T}, Tuple{AbstractGraph{T}, Integer}} where T&lt;:Integer"><code>Graphs.random_greedy_color</code></a></li><li><a href="#Graphs.randomwalk-Union{Tuple{AG}, Tuple{T}, Tuple{AG, Integer, Integer}} where {T, AG&lt;:AbstractGraph{T}}"><code>Graphs.randomwalk</code></a></li><li><a href="#Graphs.self_avoiding_walk-Union{Tuple{AG}, Tuple{T}, Tuple{AG, Integer, Integer}} where {T, AG&lt;:AbstractGraph{T}}"><code>Graphs.self_avoiding_walk</code></a></li><li><a href="#Graphs.topological_sort_by_dfs"><code>Graphs.topological_sort_by_dfs</code></a></li><li><a href="#Graphs.tree-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:Integer"><code>Graphs.tree</code></a></li></ul><h2 id="Full-docs"><a class="docs-heading-anchor" href="#Full-docs">Full docs</a><a id="Full-docs-1"></a><a class="docs-heading-anchor-permalink" href="#Full-docs" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Graphs.bfs_parents-Tuple{AbstractGraph, Integer}" href="#Graphs.bfs_parents-Tuple{AbstractGraph, Integer}"><code>Graphs.bfs_parents</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">bfs_parents(g, s[; dir=:out])</code></pre><p>Perform a breadth-first search of graph <code>g</code> starting from vertex <code>s</code>. Return a vector of parent vertices indexed by vertex. If <code>dir</code> is specified, use the corresponding edge direction (<code>:in</code> and <code>:out</code> are acceptable values).</p><p><strong>Performance</strong></p><p>This implementation is designed to perform well on large graphs. There are implementations which are marginally faster in practice for smaller graphs, but the performance improvements using this implementation on large graphs can be significant.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/6555e0df39ac1660027cef1419882deedb56de78/src/traversals/bfs.jl#L21-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.bfs_tree-Tuple{AbstractGraph, Integer}" href="#Graphs.bfs_tree-Tuple{AbstractGraph, Integer}"><code>Graphs.bfs_tree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">bfs_tree(g, s[; dir=:out])</code></pre><p>Provide a breadth-first traversal of the graph <code>g</code> starting with source vertex <code>s</code>, and return a directed acyclic graph of vertices in the order they were discovered. If <code>dir</code> is specified, use the corresponding edge direction (<code>:in</code> and <code>:out</code> are acceptable values).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/6555e0df39ac1660027cef1419882deedb56de78/src/traversals/bfs.jl#L68-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.gdistances!-Union{Tuple{T}, Tuple{AbstractGraph{T}, Any, Any}} where T" href="#Graphs.gdistances!-Union{Tuple{T}, Tuple{AbstractGraph{T}, Any, Any}} where T"><code>Graphs.gdistances!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gdistances!(g, source, dists; sort_alg=QuickSort)</code></pre><p>Fill <code>dists</code> with the geodesic distances of vertices in <code>g</code> from source vertex (or collection of vertices) <code>source</code>. <code>dists</code> should be a vector of length <code>nv(g)</code>  filled with <code>typemax(T)</code>. Return <code>dists</code>.</p><p>For vertices in disconnected components the default distance is <code>typemax(T)</code>.</p><p>An optional sorting algorithm may be specified (see Performance section).</p><p><strong>Performance</strong></p><p><code>gdistances</code> uses <code>QuickSort</code> internally for its default sorting algorithm, since it performs the best of the algorithms built into Julia Base. However, passing a <code>RadixSort</code> (available via <a href="https://github.com/JuliaCollections/SortingAlgorithms.jl">SortingAlgorithms.jl</a>) will provide significant performance improvements on larger graphs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/6555e0df39ac1660027cef1419882deedb56de78/src/traversals/bfs.jl#L78-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.gdistances-Union{Tuple{T}, Tuple{AbstractGraph{T}, Any}} where T" href="#Graphs.gdistances-Union{Tuple{T}, Tuple{AbstractGraph{T}, Any}} where T"><code>Graphs.gdistances</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gdistances(g, source; sort_alg=QuickSort)</code></pre><p>Return a vector filled with the geodesic distances of vertices in  <code>g</code> from <code>source</code>. If <code>source</code> is a collection of vertices each element should be unique. For vertices in disconnected components the default distance is <code>typemax(T)</code>.</p><p>An optional sorting algorithm may be specified (see Performance section).</p><p><strong>Performance</strong></p><p><code>gdistances</code> uses <code>QuickSort</code> internally for its default sorting algorithm, since it performs the best of the algorithms built into Julia Base. However, passing a <code>RadixSort</code> (available via <a href="https://github.com/JuliaCollections/SortingAlgorithms.jl">SortingAlgorithms.jl</a>) will provide significant performance improvements on larger graphs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/6555e0df39ac1660027cef1419882deedb56de78/src/traversals/bfs.jl#L126-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.has_path-Union{Tuple{T}, Tuple{AbstractGraph{T}, Integer, Integer}} where T" href="#Graphs.has_path-Union{Tuple{T}, Tuple{AbstractGraph{T}, Integer, Integer}} where T"><code>Graphs.has_path</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">has_path(g::AbstractGraph, u, v; exclude_vertices=Vector())</code></pre><p>Return <code>true</code> if there is a path from <code>u</code> to <code>v</code> in <code>g</code> (while avoiding vertices in <code>exclude_vertices</code>) or <code>u == v</code>. Return false if there is no such path or if <code>u</code> or <code>v</code> is in <code>excluded_vertices</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/6555e0df39ac1660027cef1419882deedb56de78/src/traversals/bfs.jl#L143-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.tree-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:Integer" href="#Graphs.tree-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:Integer"><code>Graphs.tree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">tree(parents)</code></pre><p>Convert a parents array into a directed graph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/6555e0df39ac1660027cef1419882deedb56de78/src/traversals/bfs.jl#L5-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.bipartite_map-Union{Tuple{AbstractGraph{T}}, Tuple{T}} where T" href="#Graphs.bipartite_map-Union{Tuple{AbstractGraph{T}}, Tuple{T}} where T"><code>Graphs.bipartite_map</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">bipartite_map(g) -&gt; Vector{UInt8}</code></pre><p>For a bipartite graph <code>g</code>, return a vector <code>c</code> of size <span>$|V|$</span> containing the assignment of each vertex to one of the two sets (<span>$c_i == 1$</span> or <span>$c_i == 2$</span>). If <code>g</code> is not bipartite, return an empty vector.</p><p><strong>Implementation Notes</strong></p><p>Note that an empty vector does not necessarily indicate non-bipartiteness. An empty graph will return an empty vector but is bipartite.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Graphs

julia&gt; g = SimpleGraph(3);

julia&gt; bipartite_map(g)
3-element Array{UInt8,1}:
 0x01
 0x01
 0x01

julia&gt; add_vertices!(g, 3);

julia&gt; add_edge!(g, 1, 2);

julia&gt; add_edge!(g, 2, 3);

julia&gt; bipartite_map(g)
3-element Array{UInt8,1}:
 0x01
 0x02
 0x01</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/6555e0df39ac1660027cef1419882deedb56de78/src/traversals/bipartition.jl#L1-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.is_bipartite-Tuple{AbstractGraph}" href="#Graphs.is_bipartite-Tuple{AbstractGraph}"><code>Graphs.is_bipartite</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_bipartite(g)</code></pre><p>Return <code>true</code> if graph <code>g</code> is <a href="https://en.wikipedia.org/wiki/Bipartite_graph">bipartite</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Graphs

julia&gt; g = SimpleGraph(3);

julia&gt; add_edge!(g, 1, 2);

julia&gt; add_edge!(g, 2, 3);

julia&gt; is_bipartite(g)
true

julia&gt; add_edge!(g, 1, 3);

julia&gt; is_bipartite(g)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/6555e0df39ac1660027cef1419882deedb56de78/src/traversals/bipartition.jl#L67-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.dfs_parents-Tuple{AbstractGraph, Integer}" href="#Graphs.dfs_parents-Tuple{AbstractGraph, Integer}"><code>Graphs.dfs_parents</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dfs_parents(g, s[; dir=:out])</code></pre><p>Perform a depth-first search of graph <code>g</code> starting from vertex <code>s</code>. Return a vector of parent vertices indexed by vertex. If <code>dir</code> is specified, use the corresponding edge direction (<code>:in</code> and <code>:out</code> are acceptable values).</p><p><strong>Implementation Notes</strong></p><p>This version of DFS is iterative.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/6555e0df39ac1660027cef1419882deedb56de78/src/traversals/dfs.jl#L92-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.dfs_tree-Tuple{AbstractGraph, Integer}" href="#Graphs.dfs_tree-Tuple{AbstractGraph, Integer}"><code>Graphs.dfs_tree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dfs_tree(g, s)</code></pre><p>Return an ordered vector of vertices representing a directed acyclic graph based on depth-first traversal of the graph <code>g</code> starting with source vertex <code>s</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/6555e0df39ac1660027cef1419882deedb56de78/src/traversals/dfs.jl#L84-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.is_cyclic" href="#Graphs.is_cyclic"><code>Graphs.is_cyclic</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_cyclic(g)</code></pre><p>Return <code>true</code> if graph <code>g</code> contains a cycle.</p><p><strong>Implementation Notes</strong></p><p>Uses DFS.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/6555e0df39ac1660027cef1419882deedb56de78/src/traversals/dfs.jl#L4-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.topological_sort_by_dfs" href="#Graphs.topological_sort_by_dfs"><code>Graphs.topological_sort_by_dfs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">topological_sort_by_dfs(g)</code></pre><p>Return a <a href="https://en.wikipedia.org/wiki/Topological_sorting">topological sort</a> of a directed graph <code>g</code> as a vector of vertices in topological order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/6555e0df39ac1660027cef1419882deedb56de78/src/traversals/dfs.jl#L45-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.diffusion-Union{Tuple{T}, Tuple{AbstractGraph{T}, Real, Integer}} where T" href="#Graphs.diffusion-Union{Tuple{T}, Tuple{AbstractGraph{T}, Real, Integer}} where T"><code>Graphs.diffusion</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">diffusion(g, p, n)</code></pre><p>Run diffusion simulation on <code>g</code> for <code>n</code> steps with spread probabilities based on <code>p</code>. Return a vector with the set of new vertices reached at each step of the simulation.</p><p><strong>Optional Arguments</strong></p><ul><li><code>initial_infections=sample(vertices(g), 1)</code>: A list of vertices that</li></ul><p>are infected at the start of the simulation.</p><ul><li><code>watch=Vector()</code>: While simulation is always run on the full graph,</li></ul><p>specifying <code>watch</code> limits reporting to a specific set of vertices reached during the simulation. If left empty, all vertices will be watched.</p><ul><li><code>normalize=false</code>: if <code>false</code>, set the probability of spread from a vertex <span>$i$</span> to</li></ul><p>each of the outneighbors of <span>$i$</span> to <span>$p$</span>. If <code>true</code>, set the probability of spread from a vertex <span>$i$</span> to each of the <code>outneighbors</code> of <span>$i$</span> to <span>$\frac{p}{outdegreee(g, i)}$</span>.</p><ul><li><code>rng=GLOBAL_RNG</code>: A random generator to sample from</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/6555e0df39ac1660027cef1419882deedb56de78/src/traversals/diffusion.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.diffusion_rate-Union{Tuple{Array{Vector{T}, 1}}, Tuple{T}} where T&lt;:Integer" href="#Graphs.diffusion_rate-Union{Tuple{Array{Vector{T}, 1}}, Tuple{T}} where T&lt;:Integer"><code>Graphs.diffusion_rate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">diffusion_rate(results)
diffusion_rate(g, p, n; ...)</code></pre><p>Given the results of a <code>diffusion</code> output or the parameters to the <code>diffusion</code> simulation itself, (run and) return the rate of diffusion as a vector representing the cumulative number of vertices infected at each simulation step, restricted to vertices included in <code>watch</code>, if specified.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/6555e0df39ac1660027cef1419882deedb56de78/src/traversals/diffusion.jl#L81-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.Coloring" href="#Graphs.Coloring"><code>Graphs.Coloring</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct Coloring{T}</code></pre><p>Store the number of colors used and mapping from vertex to color</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/6555e0df39ac1660027cef1419882deedb56de78/src/traversals/greedy_color.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.degree_greedy_color-Union{Tuple{AbstractGraph{T}}, Tuple{T}} where T&lt;:Integer" href="#Graphs.degree_greedy_color-Union{Tuple{AbstractGraph{T}}, Tuple{T}} where T&lt;:Integer"><code>Graphs.degree_greedy_color</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">degree_greedy_color(g)</code></pre><p>Color graph <code>g</code> iteratively in the descending order of the degree of the vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/6555e0df39ac1660027cef1419882deedb56de78/src/traversals/greedy_color.jl#L47-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.greedy_color-Union{Tuple{AbstractGraph{U}}, Tuple{U}} where U&lt;:Integer" href="#Graphs.greedy_color-Union{Tuple{AbstractGraph{U}}, Tuple{U}} where U&lt;:Integer"><code>Graphs.greedy_color</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">greedy_color(g; sort_degree=false, reps = 1)</code></pre><p>Color graph <code>g</code> based on <a href="https://en.wikipedia.org/wiki/Greedy_coloring">Greedy Coloring Heuristics</a></p><p>The heuristics can be described as choosing a permutation of the vertices and assigning the lowest color index available iteratively in that order.</p><p>If <code>sort_degree</code> is true then the permutation is chosen in reverse sorted order of the degree of the vertices. <code>parallel</code> and <code>reps</code> are irrelevant in this case.</p><p>If <code>sort_degree</code> is false then <code>reps</code> colorings are obtained based on random permutations and the one using least colors is chosen.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/6555e0df39ac1660027cef1419882deedb56de78/src/traversals/greedy_color.jl#L76-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.perm_greedy_color-Union{Tuple{T}, Tuple{AbstractGraph, Vector{T}}} where T&lt;:Integer" href="#Graphs.perm_greedy_color-Union{Tuple{T}, Tuple{AbstractGraph, Vector{T}}} where T&lt;:Integer"><code>Graphs.perm_greedy_color</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">perm_greedy_color(g, seq)</code></pre><p>Color graph <code>g</code> according to an order specified by <code>seq</code> using a greedy heuristic. <code>seq[i] = v</code> implies that vertex v is the <span>$i^{th}$</span> vertex to be colored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/6555e0df39ac1660027cef1419882deedb56de78/src/traversals/greedy_color.jl#L13-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.random_greedy_color-Union{Tuple{T}, Tuple{AbstractGraph{T}, Integer}} where T&lt;:Integer" href="#Graphs.random_greedy_color-Union{Tuple{T}, Tuple{AbstractGraph{T}, Integer}} where T&lt;:Integer"><code>Graphs.random_greedy_color</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">random_greedy_color(g, reps)</code></pre><p>Color the graph <code>g</code> iteratively in a random order using a greedy heuristic and choose the best coloring out of <code>reps</code> such random colorings.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/6555e0df39ac1660027cef1419882deedb56de78/src/traversals/greedy_color.jl#L58-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.maximum_adjacency_visit-Union{Tuple{T}, Tuple{U}, Tuple{AbstractGraph{U}, AbstractMatrix{T}}, Tuple{AbstractGraph{U}, AbstractMatrix{T}, Bool}, Tuple{AbstractGraph{U}, AbstractMatrix{T}, Bool, IO}, Tuple{AbstractGraph{U}, AbstractMatrix{T}, Bool, IO, U}} where {U, T&lt;:Real}" href="#Graphs.maximum_adjacency_visit-Union{Tuple{T}, Tuple{U}, Tuple{AbstractGraph{U}, AbstractMatrix{T}}, Tuple{AbstractGraph{U}, AbstractMatrix{T}, Bool}, Tuple{AbstractGraph{U}, AbstractMatrix{T}, Bool, IO}, Tuple{AbstractGraph{U}, AbstractMatrix{T}, Bool, IO, U}} where {U, T&lt;:Real}"><code>Graphs.maximum_adjacency_visit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">maximum_adjacency_visit(g[, distmx][, log][, io][, s])
maximum_adjacency_visit(g[, s])</code></pre><p>Return the vertices in <code>g</code> traversed by maximum adjacency search, optionally starting from vertex <code>s</code> (default <code>1</code>). An optional <code>distmx</code> matrix may be specified; if omitted, edge distances are assumed to be 1. If <code>log</code> (default <code>false</code>) is <code>true</code>, visitor events will be printed to <code>io</code>, which defaults to <code>STDOUT</code>; otherwise, no event information will be displayed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/6555e0df39ac1660027cef1419882deedb56de78/src/traversals/maxadjvisit.jl#L73-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.mincut-Union{Tuple{AbstractGraph}, Tuple{T}, Tuple{AbstractGraph, AbstractMatrix{T}}} where T&lt;:Real" href="#Graphs.mincut-Union{Tuple{AbstractGraph}, Tuple{T}, Tuple{AbstractGraph, AbstractMatrix{T}}} where T&lt;:Real"><code>Graphs.mincut</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mincut(g, distmx=weights(g))</code></pre><p>Return a tuple <code>(parity, bestcut)</code>, where <code>parity</code> is a vector of integer values that determines the partition in <code>g</code> (1 or 2) and <code>bestcut</code> is the weight of the cut that makes this partition. An optional <code>distmx</code> matrix may be specified; if omitted, edge distances are assumed to be 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/6555e0df39ac1660027cef1419882deedb56de78/src/traversals/maxadjvisit.jl#L11-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.non_backtracking_randomwalk" href="#Graphs.non_backtracking_randomwalk"><code>Graphs.non_backtracking_randomwalk</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">non_backtracking_randomwalk(g, s, niter; seed=-1)</code></pre><p>Perform a non-backtracking random walk on directed graph <code>g</code> starting at vertex <code>s</code> and continuing for a maximum of <code>niter</code> steps. Return a vector of vertices visited in order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/6555e0df39ac1660027cef1419882deedb56de78/src/traversals/randomwalks.jl#L24-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.randomwalk-Union{Tuple{AG}, Tuple{T}, Tuple{AG, Integer, Integer}} where {T, AG&lt;:AbstractGraph{T}}" href="#Graphs.randomwalk-Union{Tuple{AG}, Tuple{T}, Tuple{AG, Integer, Integer}} where {T, AG&lt;:AbstractGraph{T}}"><code>Graphs.randomwalk</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">randomwalk(g, s, niter; seed=-1)</code></pre><p>Perform a random walk on graph <code>g</code> starting at vertex <code>s</code> and continuing for a maximum of <code>niter</code> steps. Return a vector of vertices visited in order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/6555e0df39ac1660027cef1419882deedb56de78/src/traversals/randomwalks.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.self_avoiding_walk-Union{Tuple{AG}, Tuple{T}, Tuple{AG, Integer, Integer}} where {T, AG&lt;:AbstractGraph{T}}" href="#Graphs.self_avoiding_walk-Union{Tuple{AG}, Tuple{T}, Tuple{AG, Integer, Integer}} where {T, AG&lt;:AbstractGraph{T}}"><code>Graphs.self_avoiding_walk</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">self_avoiding_walk(g, s, niter; seed=-1)</code></pre><p>Perform a <a href="https://en.wikipedia.org/wiki/Self-avoiding_walk">self-avoiding walk</a> on graph <code>g</code> starting at vertex <code>s</code> and continuing for a maximum of <code>niter</code> steps. Return a vector of vertices visited in order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/6555e0df39ac1660027cef1419882deedb56de78/src/traversals/randomwalks.jl#L95-L101">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../steinertree/">« Steiner tree</a><a class="docs-footer-nextpage" href="../utils/">Utilities »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 20 August 2022 11:10">Saturday 20 August 2022</span>. Using Julia version 1.8.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
