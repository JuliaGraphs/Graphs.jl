var documenterSearchIndex = {"docs":
[{"location":"ecosystem/interface/#Creating-your-own-graph-format","page":"Creating your own graph format","title":"Creating your own graph format","text":"","category":"section"},{"location":"ecosystem/interface/","page":"Creating your own graph format","title":"Creating your own graph format","text":"This section is designed to guide developers who wish to write their own graph structures.","category":"page"},{"location":"ecosystem/interface/","page":"Creating your own graph format","title":"Creating your own graph format","text":"All Graphs.jl functions rely on a standard API to function. As long as your graph structure is a subtype of AbstractGraph and implements the following API functions with the given return values, all functions within the Graphs.jl package should just work:","category":"page"},{"location":"ecosystem/interface/","page":"Creating your own graph format","title":"Creating your own graph format","text":"edges\nBase.eltype\nedgetype (example: edgetype(g::CustomGraph) = Graphs.SimpleEdge{eltype(g)}))\nhas_edge\nhas_vertex\ninneighbors\nne\nnv\noutneighbors\nvertices\nis_directed: Note that since Graphs uses traits to determine directedness, is_directed for a CustomGraph type should be implemented with both of the following signatures:\nis_directed(::Type{CustomGraph})::Bool (example: is_directed(::Type{<:CustomGraph}) = false)\nis_directed(g::CustomGraph)::Bool","category":"page"},{"location":"ecosystem/interface/","page":"Creating your own graph format","title":"Creating your own graph format","text":"If the graph structure is designed to represent weights on edges, the weights function should also be defined. Note that the output does not necessarily have to be a dense matrix, but it must be a subtype of AbstractMatrix{<:Real} and indexable via [u, v].","category":"page"},{"location":"ecosystem/interface/","page":"Creating your own graph format","title":"Creating your own graph format","text":"Note on inheriting from AbstractSimpleGraph","category":"page"},{"location":"ecosystem/interface/","page":"Creating your own graph format","title":"Creating your own graph format","text":"Every subtype of AbstractSimpleGraph must have vertices forming a UnitRange starting from 1 and return neighbors in ascending order. The extend to which code for graph types other than subtypes of AbstractSimpleGraph does not rely on AbstractSimpleGraph assumptions needs to be carefully checked, though in principle the requirement is only part of the AbstractSimpleGraph API.","category":"page"},{"location":"algorithms/editdist/#Edit-distance","page":"Edit distance","title":"Edit distance","text":"","category":"section"},{"location":"algorithms/editdist/","page":"Edit distance","title":"Edit distance","text":"Graphs.jl allows computation of the graph edit distance.","category":"page"},{"location":"algorithms/editdist/#Index","page":"Edit distance","title":"Index","text":"","category":"section"},{"location":"algorithms/editdist/","page":"Edit distance","title":"Edit distance","text":"Pages = [\"editdist.md\"]","category":"page"},{"location":"algorithms/editdist/#Full-docs","page":"Edit distance","title":"Full docs","text":"","category":"section"},{"location":"algorithms/editdist/","page":"Edit distance","title":"Edit distance","text":"Modules = [Graphs]\nPages = [\"editdist.jl\"]","category":"page"},{"location":"algorithms/editdist/#Graphs.BoundedMinkowskiCost-Tuple{AbstractVector, AbstractVector}","page":"Edit distance","title":"Graphs.BoundedMinkowskiCost","text":"BoundedMinkowskiCost(μ₁, μ₂)\n\nReturn value similar to MinkowskiCost, but ensure costs smaller than 2τ.\n\nOptional Arguments\n\np=1: the p value for p-norm calculation. τ=1: value specifying half of the upper limit of the Minkowski cost.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/editdist/#Graphs.MinkowskiCost-Tuple{AbstractVector, AbstractVector}","page":"Edit distance","title":"Graphs.MinkowskiCost","text":"MinkowskiCost(μ₁, μ₂; p::Real=1)\n\nFor labels μ₁ on the vertices of graph G₁ and labels μ₂ on the vertices of graph G₂, compute the p-norm cost of substituting vertex u ∈ G₁ by vertex v ∈ G₂.\n\nOptional Arguments\n\np=1: the p value for p-norm calculation.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/editdist/#Graphs.edit_distance-Tuple{AbstractGraph, AbstractGraph}","page":"Edit distance","title":"Graphs.edit_distance","text":"edit_distance(G₁::AbstractGraph, G₂::AbstractGraph)\n\nCompute the edit distance between graphs G₁ and G₂. Return the minimum edit cost and edit path to transform graph G₁ into graph G₂. An edit path consists of a sequence of pairs of vertices(u,v) ∈ [0,|G₁|] × [0,|G₂|]` representing vertex operations:\n\n(0v): insertion of vertex v  G₂\n(u0): deletion of vertex u  G₁\n(u0v0): substitution of vertex u  G₁ by vertex v  G₂\n\nOptional Arguments\n\ninsert_cost::Function=v->1.0\ndelete_cost::Function=u->1.0\nsubst_cost::Function=(u,v)->0.5\n\nBy default, the algorithm uses constant operation costs. The user can provide classical Minkowski costs computed from vertex labels μ₁ (for G₁) and μ₂ (for G₂) in order to further guide the search, for example:\n\nedit_distance(G₁, G₂, subst_cost=MinkowskiCost(μ₁, μ₂))\n\nheuristic::Function=DefaultEditHeuristic: a custom heuristic provided to the A*\n\nsearch in case the default heuristic is not satisfactory.\n\nPerformance\n\nGiven two graphs G₁  G₂, edit_distance(G₁, G₂) is faster to\n\ncompute than edit_distance(G₂, G₁). Consider swapping the arguments if involved costs are equivalent.\n\nThe use of simple Minkowski costs can improve performance considerably.\nExploit vertex attributes when designing operation costs.\n\nReferences\n\nRIESEN, K., 2015. Structural Pattern Recognition with Graph Edit Distance: Approximation Algorithms and Applications. (Chapter 2)\n\nAuthor\n\nJúlio Hoffimann Mendes (juliohm@stanford.edu)\n\nExamples\n\njulia> g1 = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);\n\njulia> g2 = SimpleDiGraph([0 1 0; 0 0 1; 1 0 0]);\n\njulia> edit_distance(g1, g2)\n(3.5, Tuple[(1, 2), (2, 1), (3, 0), (4, 3), (5, 0)])\n\n\n\n\n\n","category":"method"},{"location":"contributing/#Contributor-Guide","page":"Contributor Guide","title":"Contributor Guide","text":"","category":"section"},{"location":"contributing/","page":"Contributor Guide","title":"Contributor Guide","text":"We welcome all possible contributors and ask that you read these guidelines before starting to work on this project. Following these guidelines will reduce friction and improve the speed at which your code gets merged.","category":"page"},{"location":"contributing/#Bug-reports","page":"Contributor Guide","title":"Bug reports","text":"","category":"section"},{"location":"contributing/","page":"Contributor Guide","title":"Contributor Guide","text":"If you notice code that crashes, is incorrect, or is too slow, please file a bug report. The report should be raised as a github issue with a minimal working example that reproduces the condition. The example should include any data needed. If the problem is incorrectness, then please post the correct result along with an incorrect result.","category":"page"},{"location":"contributing/","page":"Contributor Guide","title":"Contributor Guide","text":"Please include version numbers of all relevant libraries and Julia itself.","category":"page"},{"location":"contributing/#Development-guidelines","page":"Contributor Guide","title":"Development guidelines","text":"","category":"section"},{"location":"contributing/","page":"Contributor Guide","title":"Contributor Guide","text":"Correctness is a necessary requirement; efficiency is desirable. Once you have a correct implementation, make a Pull Request (PR) so we can help improve performance.\nPRs should contain one logical enhancement to the codebase.\nSquash commits in a PR.\nIf you want to introduce a new feature, open an issue to discuss a feature before you start coding (this maximizes the likelihood of patch acceptance).\nMinimize dependencies on external packages, and avoid introducing new dependencies that would increase the compilation time by a lot.\nPut type assertions on all function arguments where conflict may arise (use abstract types, Union, or Any if necessary).\nIf the algorithm was presented in a paper, include a reference to the paper (e.g., a proper academic citation along with an eprint link).\nTake steps to ensure that code works correctly and efficiently on edge cases (disconnected graphs, empty graphs, ...).\nWe can accept code that does not work for directed graphs as long as it comes with an explanation of what it would take to make it work for directed graphs.\nPrefer the short circuiting conditional over if/else when convenient, and where state is not explicitly being mutated (e.g., condition && error(\"message\") is good; condition && i += 1 is not).\nWrite code to reuse memory wherever possible. For example:","category":"page"},{"location":"contributing/","page":"Contributor Guide","title":"Contributor Guide","text":"function f(g, v)\n    storage = Vector{Int}(undef, nv(g))\n    # some code operating on storage, g, and v.\n    for i in 1:nv(g)\n        storage[i] = v-i\n    end\n    return sum(storage)\nend","category":"page"},{"location":"contributing/","page":"Contributor Guide","title":"Contributor Guide","text":"should be rewritten as two functions","category":"page"},{"location":"contributing/","page":"Contributor Guide","title":"Contributor Guide","text":"function f(g::AbstractGraph, v::Integer)\n    storage = Vector{Int}(undef, nv(g))\n    return f!(g, v, storage)\nend\n\nfunction f!(g::AbstractGraph, v::Integer, storage::AbstractVector{Int})\n    # some code operating on storage, g, and v.\n    for i in 1:nv(g)\n        storage[i] = v-i\n    end\n    return sum(storage)\nend","category":"page"},{"location":"contributing/","page":"Contributor Guide","title":"Contributor Guide","text":"This gives users the option of reusing memory and improving performance.","category":"page"},{"location":"contributing/#Minimizing-use-of-internal-struct-fields","page":"Contributor Guide","title":"Minimizing use of internal struct fields","text":"","category":"section"},{"location":"contributing/","page":"Contributor Guide","title":"Contributor Guide","text":"Since Graphs supports multiple implementations of the graph data structure using the AbstractGraph type, you should refrain from using the internal fields of structs such as fadjlist. Instead, you should use the functions provided in the API. Code that is instrumental to defining a concrete graph type can use the internal structure of that type.","category":"page"},{"location":"contributing/#Git-usage","page":"Contributor Guide","title":"Git usage","text":"","category":"section"},{"location":"contributing/#Getting-started-on-a-package-contribution","page":"Contributor Guide","title":"Getting started on a package contribution","text":"","category":"section"},{"location":"contributing/","page":"Contributor Guide","title":"Contributor Guide","text":"In order to make it easier for you to contribute and review Pull Requests (PRs), it would be better to be familiar with git fundamentals.","category":"page"},{"location":"contributing/","page":"Contributor Guide","title":"Contributor Guide","text":"Most importantly:","category":"page"},{"location":"contributing/","page":"Contributor Guide","title":"Contributor Guide","text":"clone the repository from JuliaGraphs/Graphs.jl\nfork the repository on your own github account\nmake the modification to the repository, test and document all your changes\npush to the fork you created\nopen a PR.","category":"page"},{"location":"contributing/","page":"Contributor Guide","title":"Contributor Guide","text":"See the JuMP documentation for a more detailed guide.","category":"page"},{"location":"contributing/#Advanced:-visualize-opened-PRs-locally:","page":"Contributor Guide","title":"Advanced: visualize opened PRs locally:","text":"","category":"section"},{"location":"contributing/","page":"Contributor Guide","title":"Contributor Guide","text":"In order to make it easier for you to review Pull Requests (PRs), you can add this to your git config file, which should be located at PACKAGE_LOCATION/.git/config, where PACKAGE_LOCATION is where the Graphs.jl was cloned. If you added the package with the ] dev command, it is likely at $HOME/.julia/dev/Graphs.","category":"page"},{"location":"contributing/","page":"Contributor Guide","title":"Contributor Guide","text":"These instructions were taken from this gist.","category":"page"},{"location":"contributing/","page":"Contributor Guide","title":"Contributor Guide","text":"Locate the section for your github remote in the .git/config file. It looks like this:","category":"page"},{"location":"contributing/","page":"Contributor Guide","title":"Contributor Guide","text":"[remote \"origin\"]\n    fetch = +refs/heads/*:refs/remotes/origin/*\n    url = git@github.com:JuliaGraphs/Graphs.jl.git","category":"page"},{"location":"contributing/","page":"Contributor Guide","title":"Contributor Guide","text":"Now add the line fetch = +refs/pull/*/head:refs/remotes/origin/pr/* to this section. Obviously, change the github url to match your project's URL. It ends up looking like this:","category":"page"},{"location":"contributing/","page":"Contributor Guide","title":"Contributor Guide","text":"[remote \"origin\"]\n    fetch = +refs/heads/*:refs/remotes/origin/*\n    url = git@github.com:JuliaGraphs/Graphs.jl.git\n    fetch = +refs/pull/*/head:refs/remotes/origin/pr/*","category":"page"},{"location":"contributing/","page":"Contributor Guide","title":"Contributor Guide","text":"Now fetch all the pull requests:","category":"page"},{"location":"contributing/","page":"Contributor Guide","title":"Contributor Guide","text":"$ git fetch origin\nFrom github.com:JuliaGraphs/Graphs.jl\n * [new ref]         refs/pull/1000/head -> origin/pr/1000\n * [new ref]         refs/pull/1002/head -> origin/pr/1002\n * [new ref]         refs/pull/1004/head -> origin/pr/1004\n * [new ref]         refs/pull/1009/head -> origin/pr/1009\n...","category":"page"},{"location":"contributing/","page":"Contributor Guide","title":"Contributor Guide","text":"To check out a particular pull request:","category":"page"},{"location":"contributing/","page":"Contributor Guide","title":"Contributor Guide","text":"$ git checkout pr/999\nBranch pr/999 set up to track remote branch pr/999 from origin.\nSwitched to a new branch 'pr/999'","category":"page"},{"location":"contributing/","page":"Contributor Guide","title":"Contributor Guide","text":"Now you can test a PR by running git fetch && git checkout pr/PRNUMBER && julia -e 'using Pkg; Pkg.test(\"Graphs\")'","category":"page"},{"location":"algorithms/biconnectivity/#Biconnected-graphs","page":"Biconnected graphs","title":"Biconnected graphs","text":"","category":"section"},{"location":"algorithms/biconnectivity/","page":"Biconnected graphs","title":"Biconnected graphs","text":"Graphs.jl contains several algorithms to study biconnectivity.","category":"page"},{"location":"algorithms/biconnectivity/#Index","page":"Biconnected graphs","title":"Index","text":"","category":"section"},{"location":"algorithms/biconnectivity/","page":"Biconnected graphs","title":"Biconnected graphs","text":"Pages = [\"biconnectivity.md\"]","category":"page"},{"location":"algorithms/biconnectivity/#Full-docs","page":"Biconnected graphs","title":"Full docs","text":"","category":"section"},{"location":"algorithms/biconnectivity/","page":"Biconnected graphs","title":"Biconnected graphs","text":"Modules = [Graphs]\nPages = [\n    \"biconnectivity/articulation.jl\",\n    \"biconnectivity/biconnect.jl\",\n    \"biconnectivity/bridge.jl\",\n]\n","category":"page"},{"location":"algorithms/biconnectivity/#Graphs.articulation","page":"Biconnected graphs","title":"Graphs.articulation","text":"articulation(g)\n\nCompute the articulation points of a connected graph g and return an array containing all cut vertices.\n\nExamples\n\njulia> using Graphs\n\njulia> articulation(star_graph(5))\n1-element Array{Int64,1}:\n 1\n\njulia> articulation(path_graph(5))\n3-element Array{Int64,1}:\n 2\n 3\n 4\n\n\n\n\n\n","category":"function"},{"location":"algorithms/biconnectivity/#Graphs.Biconnections","page":"Biconnected graphs","title":"Graphs.Biconnections","text":"Biconnections\n\nA state type for depth-first search that finds the biconnected components.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/biconnectivity/#Graphs.biconnected_components","page":"Biconnected graphs","title":"Graphs.biconnected_components","text":"biconnected_components(g) -> Vector{Vector{Edge{eltype(g)}}}\n\nCompute the biconnected components of an undirected graph gand return a vector of vectors containing each biconnected component.\n\nPerformance: Time complexity is mathcalO(V).\n\nExamples\n\njulia> using Graphs\n\njulia> biconnected_components(star_graph(5))\n4-element Array{Array{Graphs.SimpleGraphs.SimpleEdge,1},1}:\n [Edge 1 => 3]\n [Edge 1 => 4]\n [Edge 1 => 5]\n [Edge 1 => 2]\n\njulia> biconnected_components(cycle_graph(5))\n1-element Array{Array{Graphs.SimpleGraphs.SimpleEdge,1},1}:\n [Edge 1 => 5, Edge 4 => 5, Edge 3 => 4, Edge 2 => 3, Edge 1 => 2]\n\n\n\n\n\n","category":"function"},{"location":"algorithms/biconnectivity/#Graphs.visit!-Union{Tuple{E}, Tuple{AbstractGraph, Graphs.Biconnections{E}, Integer, Integer}} where E","page":"Biconnected graphs","title":"Graphs.visit!","text":"visit!(g, state, u, v)\n\nPerform a DFS visit storing the depth and low-points of each vertex.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/biconnectivity/#Graphs.bridges","page":"Biconnected graphs","title":"Graphs.bridges","text":"bridges(g)\n\nCompute the bridges of a connected graph g and return an array containing all bridges, i.e edges whose deletion increases the number of connected components of the graph.\n\nExamples\n\njulia> using Graphs\n\njulia> bridges(star_graph(5))\n8-element Array{Graphs.SimpleGraphs.SimpleEdge{Int64},1}:\n Edge 1 => 2\n Edge 1 => 3\n Edge 1 => 4\n Edge 1 => 5\n\njulia> bridges(path_graph(5))\n8-element Array{Graphs.SimpleGraphs.SimpleEdge{Int64},1}:\n Edge 4 => 5\n Edge 3 => 4\n Edge 2 => 3\n Edge 1 => 2\n\n\n\n\n\n","category":"function"},{"location":"algorithms/linalg/#Linear-algebra","page":"Linear algebra","title":"Linear algebra","text":"","category":"section"},{"location":"algorithms/linalg/","page":"Linear algebra","title":"Linear algebra","text":"Graphs.jl provides numerous matrix operations on both directed and undirected graphs, as part of the LinAlg submodule.","category":"page"},{"location":"algorithms/linalg/#Index","page":"Linear algebra","title":"Index","text":"","category":"section"},{"location":"algorithms/linalg/","page":"Linear algebra","title":"Linear algebra","text":"Pages   = [\"linalg.md\"]","category":"page"},{"location":"algorithms/linalg/#Full-docs","page":"Linear algebra","title":"Full docs","text":"","category":"section"},{"location":"algorithms/linalg/","page":"Linear algebra","title":"Linear algebra","text":"Modules = [Graphs.LinAlg]\nPages   = [\n    \"linalg/graphmatrices.jl\",\n    \"linalg/LinAlg.jl\",\n    \"linalg/nonbacktracking.jl\",\n    \"linalg/spectral.jl\"\n]\n","category":"page"},{"location":"algorithms/linalg/#Graphs.LinAlg","page":"Linear algebra","title":"Graphs.LinAlg","text":"LinAlg\n\nA package for using the type system to check types of graph matrices.\n\n\n\n\n\n","category":"module"},{"location":"algorithms/linalg/#Graphs.LinAlg.Adjacency","page":"Linear algebra","title":"Graphs.LinAlg.Adjacency","text":"Adjacency{T}\n\nThe core Adjacency matrix structure. Keeps the vertex degrees around. Subtypes are used to represent the different normalizations of the adjacency matrix. Laplacian and its subtypes are used for the different Laplacian matrices.\n\nAdjacency(lapl::Laplacian) provides a generic function for getting the adjacency matrix of a Laplacian matrix. If your subtype of Laplacian does not provide a field A for the Adjacency instance, then attach another method to this function to provide an Adjacency{T} representation of the Laplacian. The Adjacency matrix here is the final subtype that corresponds to this type of Laplacian.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/linalg/#Graphs.LinAlg.AveragingAdjacency","page":"Linear algebra","title":"Graphs.LinAlg.AveragingAdjacency","text":"AveragingAdjacency{T}\n\nThe matrix whose action is to average over each neighborhood.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/linalg/#Graphs.LinAlg.AveragingLaplacian","page":"Linear algebra","title":"Graphs.LinAlg.AveragingLaplacian","text":"AveragingLaplacian{T}\n\nLaplacian version of the AveragingAdjacency matrix.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/linalg/#Graphs.LinAlg.CombinatorialAdjacency","page":"Linear algebra","title":"Graphs.LinAlg.CombinatorialAdjacency","text":"CombinatorialAdjacency{T,S,V}\n\nThe standard adjacency matrix.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/linalg/#Graphs.LinAlg.GraphMatrix","page":"Linear algebra","title":"Graphs.LinAlg.GraphMatrix","text":"GraphMatrix{T}\n\nAn abstract type to allow opertions on any type of graph matrix\n\n\n\n\n\n","category":"type"},{"location":"algorithms/linalg/#Graphs.LinAlg.Noop","page":"Linear algebra","title":"Graphs.LinAlg.Noop","text":"Noop\n\nA type that represents no action.\n\nImplementation Notes\n\nThe purpose of Noop is to help write more general code for the\n\ndifferent scaled GraphMatrix types.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/linalg/#Graphs.LinAlg.NormalizedAdjacency","page":"Linear algebra","title":"Graphs.LinAlg.NormalizedAdjacency","text":"NormalizedAdjacency{T}\n\nThe normalized adjacency matrix is hatA = D^-12 A D^-12. If A is symmetric, then the normalized adjacency is also symmetric with real eigenvalues bounded by [-1, 1].\n\n\n\n\n\n","category":"type"},{"location":"algorithms/linalg/#Graphs.LinAlg.NormalizedLaplacian","page":"Linear algebra","title":"Graphs.LinAlg.NormalizedLaplacian","text":"NormalizedLaplacian{T}\n\nThe normalized Laplacian is hatL = I - D^-12 A D^-12. If A is symmetric, then the normalized Laplacian is also symmetric with positive eigenvalues bounded by 2.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/linalg/#Graphs.LinAlg.StochasticAdjacency","page":"Linear algebra","title":"Graphs.LinAlg.StochasticAdjacency","text":"StochasticAdjacency{T}\n\nA transition matrix for the random walk.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/linalg/#Graphs.LinAlg.StochasticLaplacian","page":"Linear algebra","title":"Graphs.LinAlg.StochasticLaplacian","text":"StochasticLaplacian{T}\n\nLaplacian version of the StochasticAdjacency matrix.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/linalg/#Graphs.LinAlg.degrees-Tuple{Graphs.LinAlg.CombinatorialAdjacency}","page":"Linear algebra","title":"Graphs.LinAlg.degrees","text":"degrees(adjmat)\n\nReturn the degrees of a graph represented by the CombinatorialAdjacency adjmat.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/linalg/#Graphs.LinAlg.degrees-Tuple{Graphs.LinAlg.GraphMatrix}","page":"Linear algebra","title":"Graphs.LinAlg.degrees","text":"degrees(graphmx)\n\nReturn the degrees of a graph represented by the graph matrix graphmx.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/linalg/#Graphs.LinAlg.symmetrize","page":"Linear algebra","title":"Graphs.LinAlg.symmetrize","text":"symmetrize(A::SparseMatrix, which=:or)\n\nReturn a symmetric version of graph (represented by sparse matrix A) as a sparse matrix. which may be one of :triu, :tril, :sum, or :or. Use :sum for weighted graphs.\n\n\n\n\n\n","category":"function"},{"location":"algorithms/linalg/#Graphs.LinAlg.symmetrize-2","page":"Linear algebra","title":"Graphs.LinAlg.symmetrize","text":"symmetrize(adjmat, which=:or)\n\nReturn a symmetric version of graph (represented by CombinatorialAdjacency adjmat) as a CombinatorialAdjacency. which may be one of :triu, :tril, :sum, or :or. Use :sum for weighted graphs.\n\nImplementation Notes\n\nOnly works on Adjacency because the normalizations don't commute with symmetrization.\n\n\n\n\n\n","category":"function"},{"location":"algorithms/linalg/#Graphs.LinAlg.Nonbacktracking","page":"Linear algebra","title":"Graphs.LinAlg.Nonbacktracking","text":"Nonbacktracking{G}\n\nA compact representation of the nonbacktracking operator.\n\nThe Nonbacktracking operator can be used for community detection. This representation is compact in that it uses only ne(g) additional storage and provides an implicit representation of the matrix B_g defined below.\n\nGiven two arcs A_i j and A_k l in g the non-backtraking matrixB`` is defined as\n\nB_A_i j A_k l = δ_j k * (1 - δ_i l)\n\nThis type is in the style of GraphMatrices.jl and supports the necessary operations for computed eigenvectors and conducting linear solves.\n\nAdditionally the contract!(vertexspace, nbt, edgespace) method takes vectors represented in the domain of B and represents them in the domain of the adjacency matrix of g.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/linalg/#Graphs.LinAlg.contract!-Tuple{Vector, Nonbacktracking, Vector}","page":"Linear algebra","title":"Graphs.LinAlg.contract!","text":"contract!(vertexspace, nbt, edgespace)\n\nThe mutating version of contract(nbt, edgespace). Modifies vertexspace.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/linalg/#Graphs.LinAlg.contract-Tuple{Nonbacktracking, Vector}","page":"Linear algebra","title":"Graphs.LinAlg.contract","text":"contract(nbt, edgespace)\n\nIntegrate out the edges by summing over the edges incident to each vertex.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/linalg/#Graphs.LinAlg.non_backtracking_matrix-Tuple{AbstractGraph}","page":"Linear algebra","title":"Graphs.LinAlg.non_backtracking_matrix","text":"non_backtracking_matrix(g)\n\nReturn a non-backtracking matrix B and an edgemap storing the oriented edges' positions in B.\n\nGiven two arcs A_i j and A_k l in g the non-backtracking matrixB`` is defined as\n\nB_A_i j A_k l = δ_j k * (1 - δ_i l)\n\n\n\n\n\n","category":"method"},{"location":"algorithms/linalg/#Graphs.LinAlg.adjacency_matrix","page":"Linear algebra","title":"Graphs.LinAlg.adjacency_matrix","text":"adjacency_matrix(g[, T=Int; dir=:out])\n\nReturn a sparse adjacency matrix for a graph, indexed by [u, v] vertices. Non-zero values indicate an edge from u to v. Users may override the default data type (Int) and specify an optional direction.\n\nOptional Arguments\n\ndir=:out: :in, :out, or :both are currently supported.\n\nImplementation Notes\n\nThis function is optimized for speed and directly manipulates CSC sparse matrix fields.\n\n\n\n\n\n","category":"function"},{"location":"algorithms/linalg/#Graphs.LinAlg.adjacency_spectrum","page":"Linear algebra","title":"Graphs.LinAlg.adjacency_spectrum","text":"adjacency_spectrum(g[, T=Int; dir=:unspec])\n\nReturn the eigenvalues of the adjacency matrix for a graph g, indexed by vertex. Default values for T are the same as those in adjacency_matrix.\n\nOptional Arguments\n\ndir=:unspec: Options for dir are the same as those in laplacian_matrix.\n\nPerformance\n\nConverts the matrix to dense with nv^2 memory usage.\n\nImplementation Notes\n\nUse eigvals(Matrix(adjacency_matrix(g, args...))) to compute some of the eigenvalues/eigenvectors.\n\n\n\n\n\n","category":"function"},{"location":"algorithms/linalg/#Graphs.LinAlg.incidence_matrix","page":"Linear algebra","title":"Graphs.LinAlg.incidence_matrix","text":"incidence_matrix(g[, T=Int; oriented=false])\n\nReturn a sparse node-arc incidence matrix for a graph, indexed by [v, i], where i is in 1:ne(g), indexing an edge e. For directed graphs, a value of -1 indicates that src(e) == v, while a value of 1 indicates that dst(e) == v. Otherwise, the value is 0. For undirected graphs, both entries are 1 by default (this behavior can be overridden by the oriented optional argument).\n\nIf oriented (default false) is true, for an undirected graph g, the matrix will contain arbitrary non-zero values representing connectivity between v and i.\n\n\n\n\n\n","category":"function"},{"location":"algorithms/linalg/#Graphs.LinAlg.laplacian_matrix-Union{Tuple{AbstractGraph{U}}, Tuple{U}, Tuple{AbstractGraph{U}, DataType}} where U","page":"Linear algebra","title":"Graphs.LinAlg.laplacian_matrix","text":"laplacian_matrix(g[, T=Int; dir=:unspec])\n\nReturn a sparse Laplacian matrix for a graph g, indexed by [u, v] vertices. T defaults to Int for both graph types.\n\nOptional Arguments\n\ndir=:unspec: :unspec, :both, :in, and:outare currently supported. For undirected graphs,dirdefaults to:out; for directed graphs,dirdefaults to:both`.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/linalg/#Graphs.LinAlg.laplacian_spectrum","page":"Linear algebra","title":"Graphs.LinAlg.laplacian_spectrum","text":"laplacian_spectrum(g[, T=Int; dir=:unspec])\n\nReturn the eigenvalues of the Laplacian matrix for a graph g, indexed by vertex. Default values for T are the same as those in laplacian_matrix.\n\nOptional Arguments\n\ndir=:unspec: Options for dir are the same as those in laplacian_matrix.\n\nPerformance\n\nConverts the matrix to dense with nv^2 memory usage.\n\nImplementation Notes\n\nUse eigvals(Matrix(laplacian_matrix(g, args...))) to compute some of the eigenvalues/eigenvectors.\n\n\n\n\n\n","category":"function"},{"location":"algorithms/linalg/#Graphs.LinAlg.spectral_distance","page":"Linear algebra","title":"Graphs.LinAlg.spectral_distance","text":"spectral_distance(G₁, G₂ [, k])\n\nCompute the spectral distance between undirected n-vertex graphs G₁ and G₂ using the top k greatest eigenvalues. If k is ommitted, uses full spectrum.\n\nReferences\n\nJOVANOVIC, I.; STANIC, Z., 2014. Spectral Distances of Graphs Based on their Different Matrix Representations\n\n\n\n\n\n","category":"function"},{"location":"algorithms/utils/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"algorithms/utils/","page":"Utilities","title":"Utilities","text":"Here are a few useful functions that didn't fit in the other categories.","category":"page"},{"location":"algorithms/utils/#Index","page":"Utilities","title":"Index","text":"","category":"section"},{"location":"algorithms/utils/","page":"Utilities","title":"Utilities","text":"Pages = [\"utils.md\"]","category":"page"},{"location":"algorithms/utils/#Full-docs","page":"Utilities","title":"Full docs","text":"","category":"section"},{"location":"algorithms/utils/","page":"Utilities","title":"Utilities","text":"Modules = [Graphs]\nPages = [\"utils.jl\"]\n","category":"page"},{"location":"algorithms/utils/#Graphs.deepcopy_adjlist-Union{Tuple{Array{Vector{T}, 1}}, Tuple{T}} where T","page":"Utilities","title":"Graphs.deepcopy_adjlist","text":"deepcopy_adjlist(adjlist::Vector{Vector{T}})\n\nInternal utility function for copying adjacency lists. On adjacency lists this function is more efficient than deepcopy for two reasons:\n\nAs of Julia v1.0.2, deepcopy is not typestable.\ndeepcopy needs to track all references when traversing a recursive data structure   in order to ensure that references to the same location do need get assigned to   different locations in the copy. Because we can assume that all lists in our   adjacency list are different, we don't need to keep track of them.\n\nIf T is not a bitstype (e.g. BigInt), we use the standard deepcopy.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/utils/#Graphs.findall!-Union{Tuple{T}, Tuple{Union{BitVector, Vector{Bool}}, Vector{T}}} where T<:Integer","page":"Utilities","title":"Graphs.findall!","text":"findall!(A, B)\n\nSet the B[1:|I|] to I where I is the set of indices A[I] returns true. \n\nAssumes length(B) >= |I|.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/utils/#Graphs.greedy_contiguous_partition-Union{Tuple{U}, Tuple{Vector{<:Integer}, Integer}, Tuple{Vector{<:Integer}, Integer, U}} where U<:Integer","page":"Utilities","title":"Graphs.greedy_contiguous_partition","text":"greedy_contiguous_partition(weight, required_partitions, num_items=length(weight))\n\nPartition 1:num_items into atmost required_partitions number of contiguous partitions with  the objective of minimising the largest partition. The size of a partition is equal to the num of the weight of its elements. weight[i] > 0.\n\nPerformance\n\nTime: O(numitems+requiredpartitions) Requires only one iteration over weight but may not output the optimal partition.\n\nImplementation Notes\n\nBalance(wt, left, right, n_items, n_part) =  max(sum(wt[left:right])*(n_part-1), sum(wt[right+1:n_items])). Find right that minimises Balance(weight, 1, right, num_items, required_partitions). Set the first partition as 1:right. Repeat on indices right+1:num_items and one less partition.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/utils/#Graphs.insorted-Tuple{Any, Any}","page":"Utilities","title":"Graphs.insorted","text":"insorted(item, collection)\n\nReturn true if item is in sorted collection collection.\n\nImplementation Notes\n\nDoes not verify that collection is sorted.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/utils/#Graphs.isbounded-Tuple{Integer}","page":"Utilities","title":"Graphs.isbounded","text":"isbounded(n)\n\nReturns true if typemax(n) of an integer n exists.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/utils/#Graphs.isbounded-Union{Tuple{Type{T}}, Tuple{T}} where T<:Integer","page":"Utilities","title":"Graphs.isbounded","text":"isbounded(T)\n\nReturns true if typemax(T) of a type T <: Integer exists.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/utils/#Graphs.optimal_contiguous_partition-Union{Tuple{U}, Tuple{Vector{<:Integer}, Integer}, Tuple{Vector{<:Integer}, Integer, U}} where U<:Integer","page":"Utilities","title":"Graphs.optimal_contiguous_partition","text":"optimal_contiguous_partition(weight, required_partitions, num_items=length(weight))\n\nPartition 1:num_items into atmost required_partitions number of contiguous partitions such that the largest partition is minimised. The size of a partition is equal to the sum of the weight of its elements. weight[i] > 0.\n\nPerformance\n\nTime: O(num_items*log(sum(weight)))\n\nImplementation Notes\n\nBinary Search for the partitioning over [fld(sum(weight)-1, required_partitions), sum(weight)]. \n\n\n\n\n\n","category":"method"},{"location":"algorithms/utils/#Graphs.rng_from_rng_or_seed-Tuple{Union{Nothing, Random.AbstractRNG}, Union{Nothing, Integer}}","page":"Utilities","title":"Graphs.rng_from_rng_or_seed","text":"rng_from_rng_or_seed(rng, seed)\n\nHelper function for randomized functions that can take a random generator as well as a seed argument.\n\nCurrently most randomized functions in this package take a seed integer as an argument. As modern randomized Julia functions tend to take a random generator instead of a seed, this function helps with the transition by taking rng and seed as an argument and always returning a random number generator. At least one of these arguments must be nothing.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/utils/#Graphs.sample!-Tuple{Random.AbstractRNG, AbstractVector, Integer}","page":"Utilities","title":"Graphs.sample!","text":"sample!([rng, ]a, k)\n\nSample k element from array a without repetition and eventually excluding elements in exclude.\n\nOptional Arguments\n\nexclude=(): elements in a to exclude from sampling.\n\nImplementation Notes\n\nChanges the order of the elements in a. For a non-mutating version, see sample.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/utils/#Graphs.sample-Tuple{AbstractVector, Integer}","page":"Utilities","title":"Graphs.sample","text":"sample([rng,] r, k)\n\nSample k element from unit range r without repetition and eventually excluding elements in exclude.\n\nOptional Arguments\n\nexclude=(): elements in a to exclude from sampling.\n\nImplementation Notes\n\nUnlike sample!, does not produce side effects.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/utils/#Graphs.unweighted_contiguous_partition-Tuple{Integer, Integer}","page":"Utilities","title":"Graphs.unweighted_contiguous_partition","text":"unweighted_contiguous_partition(num_items, required_partitions)\n\nPartition 1:num_items into required_partitions number of partitions such that the difference in length of the largest and smallest partition is atmost 1.\n\nPerformance\n\nTime: O(required_partitions)\n\n\n\n\n\n","category":"method"},{"location":"ecosystem/graphtypes/#Graph-types","page":"Graph types","title":"Graph types","text":"","category":"section"},{"location":"ecosystem/graphtypes/#Defined-by-Graphs.jl","page":"Graph types","title":"Defined by Graphs.jl","text":"","category":"section"},{"location":"ecosystem/graphtypes/","page":"Graph types","title":"Graph types","text":"Graphs.jl provides two concrete graph types: SimpleGraph is an undirected graph, and SimpleDiGraph is its directed counterpart. Both of these types can be parameterized to specify how vertices are identified (by default, SimpleGraph and SimpleDiGraph use the system default integer type, usually Int64).","category":"page"},{"location":"ecosystem/graphtypes/","page":"Graph types","title":"Graph types","text":"A graph G is described by a set of vertices V and edges E: G = {V, E}. V is an integer range 1:n; E is represented using forward (and, for directed graphs, backward) adjacency lists indexed by vertices. Edges may also be accessed via an iterator that yields Edge types containing (src<:Integer, dst<:Integer) values. Both vertices and edges may be integers of any type, and the smallest type that fits the data is recommended in order to save memory.","category":"page"},{"location":"ecosystem/graphtypes/","page":"Graph types","title":"Graph types","text":"Graphs are created using SimpleGraph() or SimpleDiGraph(), see Graph construction for details.","category":"page"},{"location":"ecosystem/graphtypes/","page":"Graph types","title":"Graph types","text":"Multiple edges between two given vertices are not allowed: an attempt to add an edge that already exists in a graph will not raise an error. This event can be detected using the return value of add_edge!.","category":"page"},{"location":"ecosystem/graphtypes/","page":"Graph types","title":"Graph types","text":"Note that graphs in which the number of vertices equals or approaches the typemax of the underlying graph element (e.g., a SimpleGraph{UInt8} with 127 vertices) may encounter arithmetic overflow errors in some functions, which should be reported as bugs. To be safe, please ensure that your graph is sized with some capacity to spare.","category":"page"},{"location":"ecosystem/graphtypes/#Available-in-the-wider-ecosystem","page":"Graph types","title":"Available in the wider ecosystem","text":"","category":"section"},{"location":"ecosystem/graphtypes/","page":"Graph types","title":"Graph types","text":"In addition to providing SimpleGraph and SimpleDiGraph implementations, Graphs.jl also serves as an interface for custom graph types (see AbstractGraph interface).","category":"page"},{"location":"ecosystem/graphtypes/","page":"Graph types","title":"Graph types","text":"Currently, several other packages implement alternative graph types:","category":"page"},{"location":"ecosystem/graphtypes/","page":"Graph types","title":"Graph types","text":"SimpleWeightedGraphs.jl provides a structure for (un)directed graphs with the ability to specify weights on edges.\nMetaGraphs.jl provides a structure for (un)directed graphs that supports user-defined properties on the graph, vertices, and edges.\nMetaGraphsNext.jl does the same but in a type-stable manner, and with a slightly different interface.\nStaticGraphs.jl supports very large graph structures in a space- and time-efficient manner, but as the name implies, does not allow modification of the graph once created.","category":"page"},{"location":"ecosystem/graphtypes/#Which-graph-type-should-I-use?","page":"Graph types","title":"Which graph type should I use?","text":"","category":"section"},{"location":"ecosystem/graphtypes/","page":"Graph types","title":"Graph types","text":"These are general guidelines to help you select the proper graph type.","category":"page"},{"location":"ecosystem/graphtypes/","page":"Graph types","title":"Graph types","text":"In general, prefer the native SimpleGraphs/SimpleDiGraphs structures in Graphs.jl.\nIf you need edge weights and don't require large numbers of graph modifications, use SimpleWeightedGraphs.jl.\nIf you need labeling of vertices or edges, use MetaGraphs.jl or MetaGraphsNext.jl.\nIf you work with very large graphs (billions to tens of billions of edges) and don't need mutability, use StaticGraphs.jl.","category":"page"},{"location":"first_steps/plotting/#Graph-plotting","page":"Graph plotting","title":"Graph plotting","text":"","category":"section"},{"location":"first_steps/plotting/","page":"Graph plotting","title":"Graph plotting","text":"Graphs.jl integrates with several other Julia packages for plotting. Here are a few examples.","category":"page"},{"location":"first_steps/plotting/#[TikzGraphs.jl](https://github.com/sisl/TikzGraphs.jl)","page":"Graph plotting","title":"TikzGraphs.jl","text":"","category":"section"},{"location":"first_steps/plotting/","page":"Graph plotting","title":"Graph plotting","text":"Another nice graph visualization package. (TikzPictures.jl required to render/save):","category":"page"},{"location":"first_steps/plotting/","page":"Graph plotting","title":"Graph plotting","text":"julia> g = wheel_graph(10); t = plot(g)\n\njulia> save(SVG(\"wheel10.svg\"), t)","category":"page"},{"location":"first_steps/plotting/","page":"Graph plotting","title":"Graph plotting","text":"producing a graph like this:","category":"page"},{"location":"first_steps/plotting/","page":"Graph plotting","title":"Graph plotting","text":"(Image: Wheel Graph)","category":"page"},{"location":"first_steps/plotting/#[GraphPlot.jl](https://github.com/afternone/GraphPlot.jl)","page":"Graph plotting","title":"GraphPlot.jl","text":"","category":"section"},{"location":"first_steps/plotting/","page":"Graph plotting","title":"Graph plotting","text":"Another graph visualization package that is very simple to use. Compose.jl is required for most rendering functionality:","category":"page"},{"location":"first_steps/plotting/","page":"Graph plotting","title":"Graph plotting","text":"julia> using GraphPlot, Compose\n\njulia> g = wheel_graph(10)\n\njulia> draw(PNG(\"/tmp/wheel10.png\", 16cm, 16cm), gplot(g))","category":"page"},{"location":"first_steps/plotting/#[SGtSNEpi.jl](https://github.com/fcdimitr/SGtSNEpi.jl)","page":"Graph plotting","title":"SGtSNEpi.jl","text":"","category":"section"},{"location":"first_steps/plotting/","page":"Graph plotting","title":"Graph plotting","text":"SGtSNEpi.jl is a high-performance software for swift embedding of a large, sparse graph into a d-dimensional space (d = 1,2,3). The Makie plotting ecosystem is used for interactive plots.","category":"page"},{"location":"first_steps/plotting/","page":"Graph plotting","title":"Graph plotting","text":"using GLMakie, SGtSNEpi, SNAPDatasets\n\nGLMakie.activate!()\n\ng = loadsnap(:as_caida)\ny = sgtsnepi(g);\nshow_embedding(y;\n  A = adjacency_matrix(g),        # show edges on embedding\n  mrk_size = 1,                   # control node sizes\n  lwd_in = 0.01, lwd_out = 0.001, # control edge widths\n  edge_alpha = 0.03 )             # control edge transparency","category":"page"},{"location":"first_steps/plotting/","page":"Graph plotting","title":"Graph plotting","text":"The above code produces the following output:","category":"page"},{"location":"first_steps/plotting/","page":"Graph plotting","title":"Graph plotting","text":"(Image: alt tag)","category":"page"},{"location":"first_steps/plotting/","page":"Graph plotting","title":"Graph plotting","text":"SGtSNEpi.jl enables 3D graph embedding as well. The 3D embedding of the weighted undirected graph MLGraph/optdigits10NN is shown below. It consists of 26,475 nodes and 53,381 edges. Nodes are colored according to labels provided with the dataset.","category":"page"},{"location":"first_steps/plotting/","page":"Graph plotting","title":"Graph plotting","text":"(Image: alt tag)","category":"page"},{"location":"first_steps/plotting/#[GraphRecipes.jl](https://github.com/JuliaPlots/GraphRecipes.jl)","page":"Graph plotting","title":"GraphRecipes.jl","text":"","category":"section"},{"location":"first_steps/plotting/","page":"Graph plotting","title":"Graph plotting","text":"GraphRecipes.jl contains several recipes for plotting networks using the Plots.jl ecosystem. There are a lot of different recipes and styles to choose from, check out the examples page to see more of them.","category":"page"},{"location":"first_steps/plotting/","page":"Graph plotting","title":"Graph plotting","text":"using Plots, GraphRecipes\ng = wheel_graph(10)\ngraphplot(g, curves=false)","category":"page"},{"location":"first_steps/plotting/","page":"Graph plotting","title":"Graph plotting","text":"(Image: wheel graph with GraphRecipes.jl)","category":"page"},{"location":"first_steps/plotting/#[GraphMakie.jl](https://github.com/JuliaPlots/GraphMakie.jl)","page":"Graph plotting","title":"GraphMakie.jl","text":"","category":"section"},{"location":"first_steps/plotting/","page":"Graph plotting","title":"Graph plotting","text":"GraphMakie.jl is a graph plotting recipe for the Makie.jl ecosystem. It uses NetworkLayout.jl for the node placement and supports 2D and 3D plots. Check out the docs for more examples and tutorials.","category":"page"},{"location":"first_steps/plotting/","page":"Graph plotting","title":"Graph plotting","text":"using GLMakie, GraphMakie\nusing GraphMakie.NetworkLayout\n\ng = smallgraph(:dodecahedral)\ngraphplot(g; layout=Stress(dim=3))","category":"page"},{"location":"first_steps/plotting/","page":"Graph plotting","title":"Graph plotting","text":"(Image: GraphMakie example plot)","category":"page"},{"location":"algorithms/connectivity/#Connected-components","page":"Connected components","title":"Connected components","text":"","category":"section"},{"location":"algorithms/connectivity/","page":"Connected components","title":"Connected components","text":"Graphs.jl includes several functions dealing with connected components.","category":"page"},{"location":"algorithms/connectivity/#Index","page":"Connected components","title":"Index","text":"","category":"section"},{"location":"algorithms/connectivity/","page":"Connected components","title":"Connected components","text":"Pages = [\"connectivity.md\"]","category":"page"},{"location":"algorithms/connectivity/#Full-docs","page":"Connected components","title":"Full docs","text":"","category":"section"},{"location":"algorithms/connectivity/","page":"Connected components","title":"Connected components","text":"Modules = [Graphs]\nPages = [\n    \"connectivity.jl\",\n]\n","category":"page"},{"location":"algorithms/connectivity/#Graphs.attracting_components","page":"Connected components","title":"Graphs.attracting_components","text":"attracting_components(g)\n\nReturn a vector of vectors of integers representing lists of attracting components in the directed graph g.\n\nThe attracting components are a subset of the strongly connected components in which the components do not have any leaving edges.\n\nExamples\n\njulia> g = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0])\n{5, 6} directed simple Int64 graph\n\njulia> strongly_connected_components(g)\n2-element Array{Array{Int64,1},1}:\n [4, 5]\n [1, 2, 3]\n\njulia> attracting_components(g)\n1-element Array{Array{Int64,1},1}:\n [4, 5]\n\n\n\n\n\n","category":"function"},{"location":"algorithms/connectivity/#Graphs.components-Union{Tuple{Vector{T}}, Tuple{T}} where T<:Integer","page":"Connected components","title":"Graphs.components","text":"components(labels)\n\nGiven a vector of component labels, return a vector of vectors representing the vertices associated with a given component id.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/connectivity/#Graphs.components_dict-Union{Tuple{Vector{T}}, Tuple{T}} where T<:Integer","page":"Connected components","title":"Graphs.components_dict","text":"components_dict(labels)\n\nConvert an array of labels to a map of component id to vertices, and return a map with each key corresponding to a given component id and each value containing the vertices associated with that component.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/connectivity/#Graphs.condensation","page":"Connected components","title":"Graphs.condensation","text":"condensation(g[, scc])\n\nReturn the condensation graph of the strongly connected components scc in the directed graph g. If scc is missing, generate the strongly connected components first.\n\nExamples\n\njulia> g = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0])\n{5, 6} directed simple Int64 graph\n\njulia> strongly_connected_components(g)\n2-element Array{Array{Int64,1},1}:\n [4, 5]\n [1, 2, 3]\n\njulia> foreach(println, edges(condensation(g)))\nEdge 2 => 1\n\n\n\n\n\n","category":"function"},{"location":"algorithms/connectivity/#Graphs.connected_components!-Union{Tuple{T}, Tuple{AbstractVector, AbstractGraph{T}}} where T","page":"Connected components","title":"Graphs.connected_components!","text":"connected_components!(label, g)\n\nFill label with the id of the connected component in the undirected graph g to which it belongs. Return a vector representing the component assigned to each vertex. The component value is the smallest vertex ID in the component.\n\nPerformance\n\nThis algorithm is linear in the number of edges of the graph.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/connectivity/#Graphs.connected_components-Union{Tuple{AbstractGraph{T}}, Tuple{T}} where T","page":"Connected components","title":"Graphs.connected_components","text":"connected_components(g)\n\nReturn the connected components of an undirected graph g as a vector of components, with each element a vector of vertices belonging to the component.\n\nFor directed graphs, see strongly_connected_components and weakly_connected_components.\n\nExamples\n\njulia> g = SimpleGraph([0 1 0; 1 0 1; 0 1 0]);\n\njulia> connected_components(g)\n1-element Array{Array{Int64,1},1}:\n [1, 2, 3]\n\njulia> g = SimpleGraph([0 1 0 0 0; 1 0 1 0 0; 0 1 0 0 0; 0 0 0 0 1; 0 0 0 1 0]);\n\njulia> connected_components(g)\n2-element Array{Array{Int64,1},1}:\n [1, 2, 3]\n [4, 5]\n\n\n\n\n\n","category":"method"},{"location":"algorithms/connectivity/#Graphs.is_connected-Tuple{AbstractGraph}","page":"Connected components","title":"Graphs.is_connected","text":"is_connected(g)\n\nReturn true if graph g is connected. For directed graphs, return true if graph g is weakly connected.\n\nExamples\n\njulia> g = SimpleGraph([0 1 0; 1 0 1; 0 1 0]);\n\njulia> is_connected(g)\ntrue\n\njulia> g = SimpleGraph([0 1 0 0 0; 1 0 1 0 0; 0 1 0 0 0; 0 0 0 0 1; 0 0 0 1 0]);\n\njulia> is_connected(g)\nfalse\n\njulia> g = SimpleDiGraph([0 1 0; 0 0 1; 1 0 0]);\n\njulia> is_connected(g)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"algorithms/connectivity/#Graphs.is_strongly_connected","page":"Connected components","title":"Graphs.is_strongly_connected","text":"is_strongly_connected(g)\n\nReturn true if directed graph g is strongly connected.\n\nExamples\n\njulia> g = SimpleDiGraph([0 1 0; 0 0 1; 1 0 0]);\n\njulia> is_strongly_connected(g)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"algorithms/connectivity/#Graphs.is_weakly_connected-Tuple{Any}","page":"Connected components","title":"Graphs.is_weakly_connected","text":"is_weakly_connected(g)\n\nReturn true if the graph g is weakly connected. If g is undirected, this function is equivalent to is_connected(g).\n\nExamples\n\njulia> g = SimpleDiGraph([0 1 0; 0 0 1; 1 0 0]);\n\njulia> is_weakly_connected(g)\ntrue\n\njulia> g = SimpleDiGraph([0 1 0; 1 0 1; 0 0 0]);\n\njulia> is_connected(g)\ntrue\n\njulia> is_strongly_connected(g)\nfalse\n\njulia> is_weakly_connected(g)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"algorithms/connectivity/#Graphs.isgraphical-Tuple{Vector{<:Integer}}","page":"Connected components","title":"Graphs.isgraphical","text":"isgraphical(degs)\n\nReturn true if the degree sequence degs is graphical. A sequence of integers is called graphical, if there exists a graph where the degrees of its vertices form that same sequence.\n\nPerformance\n\nTime complexity: mathcalO(degs*log(degs)).\n\nImplementation Notes\n\nAccording to Erdös-Gallai theorem, a degree sequence d_1 d_n (sorted in descending order) is graphic iff the sum of vertex degrees is even and the sequence obeys the property -\n\nsum_i=1^r d_i leq r(r-1) + sum_i=r+1^n min(rd_i)\n\nfor each integer r <= n-1\n\n\n\n\n\n","category":"method"},{"location":"algorithms/connectivity/#Graphs.neighborhood-Union{Tuple{T}, Tuple{U}, Tuple{AbstractGraph{T}, Integer, Any}, Tuple{AbstractGraph{T}, Integer, Any, AbstractMatrix{U}}} where {U<:Real, T<:Integer}","page":"Connected components","title":"Graphs.neighborhood","text":"neighborhood(g, v, d, distmx=weights(g))\n\nReturn a vector of each vertex in g at a geodesic distance less than or equal to d, where distances may be specified by distmx.\n\nOptional Arguments\n\ndir=:out: If g is directed, this argument specifies the edge direction\n\nwith respect to v of the edges to be considered. Possible values: :in or :out.\n\nExamples\n\njulia> g = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);\n\njulia> neighborhood(g, 1, 2)\n3-element Array{Int64,1}:\n 1\n 2\n 3\n\njulia> neighborhood(g, 1, 3)\n4-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n\njulia> neighborhood(g, 1, 3, [0 1 0 0 0; 0 0 1 0 0; 1 0 0 0.25 0; 0 0 0 0 0.25; 0 0 0 0.25 0])\n5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n\n\n\n\n\n","category":"method"},{"location":"algorithms/connectivity/#Graphs.neighborhood_dists-Union{Tuple{T}, Tuple{U}, Tuple{AbstractGraph{T}, Integer, Any}, Tuple{AbstractGraph{T}, Integer, Any, AbstractMatrix{U}}} where {U<:Real, T<:Integer}","page":"Connected components","title":"Graphs.neighborhood_dists","text":"neighborhood_dists(g, v, d, distmx=weights(g))\n\nReturn a a vector of tuples representing each vertex which is at a geodesic distance less than or equal to d, along with its distance from v. Non-negative distances may be specified by distmx.\n\nOptional Arguments\n\ndir=:out: If g is directed, this argument specifies the edge direction\n\nwith respect to v of the edges to be considered. Possible values: :in or :out.\n\nExamples\n\njulia> g = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);\n\njulia> neighborhood_dists(g, 1, 3)\n4-element Array{Tuple{Int64,Int64},1}:\n (1, 0)\n (2, 1)\n (3, 2)\n (4, 3)\n\njulia> neighborhood_dists(g, 1, 3, [0 1 0 0 0; 0 0 1 0 0; 1 0 0 0.25 0; 0 0 0 0 0.25; 0 0 0 0.25 0])\n5-element Array{Tuple{Int64,Float64},1}:\n (1, 0.0)\n (2, 1.0)\n (3, 2.0)\n (4, 2.25)\n (5, 2.5)\n\njulia> neighborhood_dists(g, 4, 3)\n2-element Array{Tuple{Int64,Int64},1}:\n (4, 0)\n (5, 1)\n\njulia> neighborhood_dists(g, 4, 3, dir=:in)\n5-element Array{Tuple{Int64,Int64},1}:\n (4, 0)\n (3, 1)\n (5, 1)\n (2, 2)\n (1, 3)\n\n\n\n\n\n","category":"method"},{"location":"algorithms/connectivity/#Graphs.period","page":"Connected components","title":"Graphs.period","text":"period(g)\n\nReturn the (common) period for all vertices in a strongly connected directed graph. Will throw an error if the graph is not strongly connected.\n\nExamples\n\njulia> g = SimpleDiGraph([0 1 0; 0 0 1; 1 0 0]);\n\njulia> period(g)\n3\n\n\n\n\n\n","category":"function"},{"location":"algorithms/connectivity/#Graphs.strongly_connected_components","page":"Connected components","title":"Graphs.strongly_connected_components","text":"strongly_connected_components(g)\n\nCompute the strongly connected components of a directed graph g.\n\nReturn an array of arrays, each of which is the entire connected component.\n\nImplementation Notes\n\nThe order of the components is not part of the API contract.\n\nExamples\n\njulia> g = SimpleDiGraph([0 1 0; 1 0 1; 0 0 0]);\n\njulia> strongly_connected_components(g)\n2-element Array{Array{Int64,1},1}:\n [3]\n [1, 2]\n\n\njulia> g=SimpleDiGraph(11)\n{11, 0} directed simple Int64 graph\n\njulia> edge_list=[(1,2),(2,3),(3,4),(4,1),(3,5),(5,6),(6,7),(7,5),(5,8),(8,9),(9,8),(10,11),(11,10)];\n\njulia> g = SimpleDiGraph(Edge.(edge_list))\n{11, 13} directed simple Int64 graph\n\njulia> strongly_connected_components(g)\n4-element Array{Array{Int64,1},1}:\n [8, 9]\n [5, 6, 7]\n [1, 2, 3, 4]\n [10, 11]\n\n\n\n\n\n\n","category":"function"},{"location":"algorithms/connectivity/#Graphs.strongly_connected_components_kosaraju","page":"Connected components","title":"Graphs.strongly_connected_components_kosaraju","text":"strongly_connected_components_kosaraju(g)\n\nCompute the strongly connected components of a directed graph g using Kosaraju's Algorithm. (https://en.wikipedia.org/wiki/Kosaraju%27s_algorithm).\n\nReturn an array of arrays, each of which is the entire connected component.\n\nPerformance\n\nTime Complexity : O(|E|+|V|) Space Complexity : O(|V|) {Excluding the memory required for storing graph}\n\n|V| = Number of vertices |E| = Number of edges\n\nExamples\n\n\njulia> g=SimpleDiGraph(3)\n{3, 0} directed simple Int64 graph\n\njulia> g = SimpleDiGraph([0 1 0 ; 0 0 1; 0 0 0])\n{3, 2} directed simple Int64 graph\n\njulia> strongly_connected_components_kosaraju(g)\n3-element Array{Array{Int64,1},1}:\n [1]\n [2]\n [3]\n\n\njulia> g=SimpleDiGraph(11)\n{11, 0} directed simple Int64 graph\n\njulia> edge_list=[(1,2),(2,3),(3,4),(4,1),(3,5),(5,6),(6,7),(7,5),(5,8),(8,9),(9,8),(10,11),(11,10)]\n13-element Array{Tuple{Int64,Int64},1}:\n (1, 2)\n (2, 3)\n (3, 4)\n (4, 1)\n (3, 5)\n (5, 6)\n (6, 7)\n (7, 5)\n (5, 8)\n (8, 9)\n (9, 8)\n (10, 11)\n (11, 10)\n\njulia> g = SimpleDiGraph(Edge.(edge_list))\n{11, 13} directed simple Int64 graph\n\njulia> strongly_connected_components_kosaraju(g)\n4-element Array{Array{Int64,1},1}:\n [11, 10]\n [2, 3, 4, 1]\n [6, 7, 5]\n [9, 8]\n\n\n\n\n\n\n","category":"function"},{"location":"algorithms/connectivity/#Graphs.weakly_connected_components-Tuple{Any}","page":"Connected components","title":"Graphs.weakly_connected_components","text":"weakly_connected_components(g)\n\nReturn the weakly connected components of the graph g. This is equivalent to the connected components of the undirected equivalent of g. For undirected graphs this is equivalent to the connected_components of g.\n\nExamples\n\njulia> g = SimpleDiGraph([0 1 0; 1 0 1; 0 0 0]);\n\njulia> weakly_connected_components(g)\n1-element Array{Array{Int64,1},1}:\n [1, 2, 3]\n\n\n\n\n\n","category":"method"},{"location":"first_steps/construction/#Graph-construction","page":"Graph construction","title":"Graph construction","text":"","category":"section"},{"location":"first_steps/construction/","page":"Graph construction","title":"Graph construction","text":"Graphs.jl provides a number of methods for creating a graph. These include tools for building and modifying graph objects, a wide array of graph generator functions, and the ability to read and write graphs from files (using GraphIO.jl).","category":"page"},{"location":"first_steps/construction/#Creating-graphs","page":"Graph construction","title":"Creating graphs","text":"","category":"section"},{"location":"first_steps/construction/#Standard-generators","page":"Graph construction","title":"Standard generators","text":"","category":"section"},{"location":"first_steps/construction/","page":"Graph construction","title":"Graph construction","text":"Graphs.jl implements numerous graph generators, including random graph generators, constructors for classic graphs, numerous small graphs with familiar topologies, and random and static graphs embedded in Euclidean space. See Generators for common graphs for a complete list of available templates.","category":"page"},{"location":"first_steps/construction/#Datasets","page":"Graph construction","title":"Datasets","text":"","category":"section"},{"location":"first_steps/construction/","page":"Graph construction","title":"Graph construction","text":"Other notorious graphs and integration with the MatrixDepot.jl package are available in the Datasets submodule of the companion package LightGraphsExtras.jl. Selected graphs from the Stanford Large Network Dataset Collection may be found in the SNAPDatasets.jl package.","category":"page"},{"location":"first_steps/construction/#Modifying-graphs","page":"Graph construction","title":"Modifying graphs","text":"","category":"section"},{"location":"first_steps/construction/","page":"Graph construction","title":"Graph construction","text":"Starting from a (possibly empty) graph g, one can modify it using the following functions:","category":"page"},{"location":"first_steps/construction/","page":"Graph construction","title":"Graph construction","text":"add_vertex!(g) adds one vertex to g\nadd_vertices!(g, n) adds n vertices to g\nadd_edge!(g, s, d) adds the edge (s, d) to g\nrem_vertex!(g, v) removes vertex v from g\nrem_edge!(g, s, d) removes edge (s, d) from g","category":"page"},{"location":"first_steps/construction/","page":"Graph construction","title":"Graph construction","text":"If an iterator of edges edgelist is available, then one can directly use SimpleGraphFromIterator(edgelist) or SimpleDiGraphFromIterator(edgelist).","category":"page"},{"location":"first_steps/construction/","page":"Graph construction","title":"Graph construction","text":"In addition to these core functions, more advanced operators can be found in Operators.","category":"page"},{"location":"core_functions/persistence/#Reading-and-writing-files","page":"Reading and writing files","title":"Reading and writing files","text":"","category":"section"},{"location":"core_functions/persistence/","page":"Reading and writing files","title":"Reading and writing files","text":"Graphs.jl includes functions for working with graphs stored in various file formats/","category":"page"},{"location":"core_functions/persistence/#Index","page":"Reading and writing files","title":"Index","text":"","category":"section"},{"location":"core_functions/persistence/","page":"Reading and writing files","title":"Reading and writing files","text":"Pages = [\"persistence.md\"]","category":"page"},{"location":"core_functions/persistence/#Full-docs","page":"Reading and writing files","title":"Full docs","text":"","category":"section"},{"location":"core_functions/persistence/","page":"Reading and writing files","title":"Reading and writing files","text":"Modules = [Graphs]\nPages = [\"persistence/common.jl\", \"persistence/lg.jl\"]\n","category":"page"},{"location":"core_functions/persistence/#Graphs.loadgraph-Tuple{AbstractString, AbstractString, Graphs.AbstractGraphFormat}","page":"Reading and writing files","title":"Graphs.loadgraph","text":"loadgraph(file, gname=\"graph\", format=LGFormat())\n\nRead a graph named gname from file in the format format.\n\nImplementation Notes\n\ngname is graph-format dependent and is only used if the file contains multiple graphs; if the file format does not support multiple graphs, this value is ignored. The default value may change in the future.\n\n\n\n\n\n","category":"method"},{"location":"core_functions/persistence/#Graphs.loadgraphs-Tuple{AbstractString, Graphs.AbstractGraphFormat}","page":"Reading and writing files","title":"Graphs.loadgraphs","text":"loadgraphs(file, format=LGFormat())\n\nLoad multiple graphs from file in the format format. Return a dictionary mapping graph name to graph.\n\nImplementation Notes\n\nFor unnamed graphs the default name \"graph\" will be used. This default may change in the future.\n\n\n\n\n\n","category":"method"},{"location":"core_functions/persistence/#Graphs.savegraph-Tuple{AbstractString, AbstractGraph, AbstractString, Graphs.AbstractGraphFormat}","page":"Reading and writing files","title":"Graphs.savegraph","text":"savegraph(file, g, gname=\"graph\", format=LGFormat)\n\nSaves a graph g with name gname to file in the format format. Return the number of graphs written.\n\nImplementation Notes\n\nThe default graph name assigned to gname may change in the future.\n\n\n\n\n\n","category":"method"},{"location":"core_functions/persistence/#Graphs.savegraph-Union{Tuple{T}, Tuple{U}, Tuple{AbstractString, Dict{T, U}, Graphs.AbstractGraphFormat}} where {U<:AbstractGraph, T<:AbstractString}","page":"Reading and writing files","title":"Graphs.savegraph","text":"savegraph(file, g, d, format=LGFormat)\n\nSave a dictionary of graphname => graph to file in the format format. Return the number of graphs written.\n\nImplementation Notes\n\nWill only work if the file format supports multiple graph types.\n\n\n\n\n\n","category":"method"},{"location":"core_functions/persistence/#Graphs.loadlg_mult-Tuple{IO}","page":"Reading and writing files","title":"Graphs.loadlg_mult","text":"loadlg_mult(io)\n\nReturn a dictionary of (name=>graph) loaded from IO stream io.\n\n\n\n\n\n","category":"method"},{"location":"core_functions/persistence/#Graphs.savelg-Union{Tuple{T}, Tuple{IO, AbstractGraph{T}, String}} where T","page":"Reading and writing files","title":"Graphs.savelg","text":"savelg(io, g, gname)\n\nWrite a graph g with name gname in a proprietary format to the IO stream designated by io. Return 1 (number of graphs written).\n\n\n\n\n\n","category":"method"},{"location":"core_functions/persistence/#Graphs.savelg_mult-Tuple{IO, Dict}","page":"Reading and writing files","title":"Graphs.savelg_mult","text":"savelg_mult(io, graphs)\n\nWrite a dictionary of (name=>graph) to an IO stream io, with default GZip compression. Return number of graphs written.\n\n\n\n\n\n","category":"method"},{"location":"first_steps/theory/#Basics-of-graph-theory","page":"Basics of graph theory","title":"Basics of graph theory","text":"","category":"section"},{"location":"first_steps/theory/","page":"Basics of graph theory","title":"Basics of graph theory","text":"In construction, for now see the Wikipedia page.","category":"page"},{"location":"first_steps/persistence/#Reading-and-writing-graphs","page":"Reading and writing graphs","title":"Reading and writing graphs","text":"","category":"section"},{"location":"first_steps/persistence/#Saving-using-custom-LG-format.","page":"Reading and writing graphs","title":"Saving using custom LG format.","text":"","category":"section"},{"location":"first_steps/persistence/","page":"Reading and writing graphs","title":"Reading and writing graphs","text":"Graphs may be written to I/O streams and files using the savegraph function, and they can be read with the loadgraph function. The default graph format is a bespoke compressed format called LG, defined by Graphs.jl.","category":"page"},{"location":"first_steps/persistence/#Example","page":"Reading and writing graphs","title":"Example","text":"","category":"section"},{"location":"first_steps/persistence/","page":"Reading and writing graphs","title":"Reading and writing graphs","text":"\ng = erdos_renyi(5, 0.2)\n\nsavegraph(\"mygraph.lgz\", g)\nreloaded_g = loadgraph(\"mygraph.lgz\")","category":"page"},{"location":"first_steps/persistence/","page":"Reading and writing graphs","title":"Reading and writing graphs","text":"In addition, graphs can also be saved in an uncompressed format using the compress=false option.","category":"page"},{"location":"first_steps/persistence/","page":"Reading and writing graphs","title":"Reading and writing graphs","text":"\nsavegraph(\"mygraph.lg\", g, compress=false)\n\nreloaded_g = loadgraph(\"mygraph.lg\")","category":"page"},{"location":"first_steps/persistence/","page":"Reading and writing graphs","title":"Reading and writing graphs","text":"Finally, dictionaries of graphs can also be saved and subsequently re-loaded one by one.","category":"page"},{"location":"first_steps/persistence/","page":"Reading and writing graphs","title":"Reading and writing graphs","text":"graph_dict = {\"g1\" => erdos_renyi(5, 0.1),\n              \"g2\" => erdos_renyi(10, 0.2),\n              \"g3\" => erdos_renyi(2, 0.9)}\n\nsavegraph(\"mygraph_dict.lg\", graph_dict)\n\n# Re-load only graph g1\nreloaded_g1 = loadgraph(\"mygraph_dict.lg\", \"g1\")","category":"page"},{"location":"first_steps/persistence/#GraphIO-for-other-formats","page":"Reading and writing graphs","title":"GraphIO for other formats","text":"","category":"section"},{"location":"first_steps/persistence/","page":"Reading and writing graphs","title":"Reading and writing graphs","text":"The GraphIO.jl library provides tools for importing and exporting graph objects using common file types like edgelists, GraphML, Pajek NET, and more.","category":"page"},{"location":"algorithms/shortestpaths/#Shortest-paths","page":"Shortest paths","title":"Shortest paths","text":"","category":"section"},{"location":"algorithms/shortestpaths/","page":"Shortest paths","title":"Shortest paths","text":"Graphs.jl includes standard algorithms for shortest paths.","category":"page"},{"location":"algorithms/shortestpaths/#Index","page":"Shortest paths","title":"Index","text":"","category":"section"},{"location":"algorithms/shortestpaths/","page":"Shortest paths","title":"Shortest paths","text":"Pages = [\"shortestpaths.md\"]","category":"page"},{"location":"algorithms/shortestpaths/#Full-docs","page":"Shortest paths","title":"Full docs","text":"","category":"section"},{"location":"algorithms/shortestpaths/","page":"Shortest paths","title":"Shortest paths","text":"Modules = [Graphs]\nPages = [\n    \"shortestpaths/astar.jl\",\n    \"shortestpaths/bellman-ford.jl\",\n    \"shortestpaths/desopo-pape.jl\",\n    \"shortestpaths/dijkstra.jl\",\n    \"shortestpaths/floyd-warshall.jl\",\n    \"shortestpaths/johnson.jl\",\n    \"shortestpaths/spfa.jl\",\n    \"shortestpaths/yen.jl\",\n]\n","category":"page"},{"location":"algorithms/shortestpaths/#Graphs.a_star-Union{Tuple{E}, Tuple{U}, Tuple{T}, Tuple{AbstractGraph{U}, Integer, Integer}, Tuple{AbstractGraph{U}, Integer, Integer, AbstractMatrix{T}}, Tuple{AbstractGraph{U}, Integer, Integer, AbstractMatrix{T}, Function}, Tuple{AbstractGraph{U}, Integer, Integer, AbstractMatrix{T}, Function, Type{E}}} where {T, U, E<:AbstractEdge}","page":"Shortest paths","title":"Graphs.a_star","text":"a_star(g, s, t[, distmx][, heuristic][, edgetype_to_return])\n\nCompute a shortest path using the A* search algorithm.\n\nArguments\n\ng::AbstractGraph: the graph\ns::Integer: the source vertex\nt::Integer: the target vertex\ndistmx::AbstractMatrix: an optional (possibly sparse) n × n matrix of edge weights. It is set to weights(g) by default (which itself falls back on Graphs.DefaultDistance).\nheuristic::Function: an optional function mapping each vertex to a lower estimate of the remaining distance from v to t. It is set to v -> 0 by default (which corresponds to Dijkstra's algorithm)\nedgetype_to_return::Type{E}: the eltype E<:AbstractEdge of the vector of edges returned. It is set to edgetype(g) by default. Note that the two-argument constructor E(u, v) must be defined, even for weighted edges: if it isn't, consider using E = Graphs.SimpleEdge.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/shortestpaths/#Graphs.BellmanFordState","page":"Shortest paths","title":"Graphs.BellmanFordState","text":"BellmanFordState{T, U}\n\nAn AbstractPathState designed for Bellman-Ford shortest-paths calculations.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/shortestpaths/#Graphs.bellman_ford_shortest_paths-Union{Tuple{T}, Tuple{U}, Tuple{AbstractGraph{U}, AbstractVector{<:Integer}}, Tuple{AbstractGraph{U}, AbstractVector{<:Integer}, AbstractMatrix{T}}} where {U<:Integer, T<:Real}","page":"Shortest paths","title":"Graphs.bellman_ford_shortest_paths","text":"bellman_ford_shortest_paths(g, s, distmx=weights(g))\nbellman_ford_shortest_paths(g, ss, distmx=weights(g))\n\nCompute shortest paths between a source s (or list of sources ss) and all other nodes in graph g using the Bellman-Ford algorithm. Return a Graphs.BellmanFordState with relevant traversal information.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/shortestpaths/#Graphs.enumerate_paths-Tuple{Graphs.AbstractPathState, AbstractVector{<:Integer}}","page":"Shortest paths","title":"Graphs.enumerate_paths","text":"enumerate_paths(state[, vs])\n\nGiven a path state state of type AbstractPathState, return a vector (indexed by vertex) of the paths between the source vertex used to compute the path state and a single destination vertex, a list of destination vertices, or the entire graph. For multiple destination vertices, each path is represented by a vector of vertices on the path between the source and the destination. Nonexistent paths will be indicated by an empty vector. For single destinations, the path is represented by a single vector of vertices, and will be length 0 if the path does not exist.\n\nImplementation Notes\n\nFor Floyd-Warshall path states, please note that the output is a bit different, since this algorithm calculates all shortest paths for all pairs of vertices: enumerate_paths(state) will return a vector (indexed by source vertex) of vectors (indexed by destination vertex) of paths. enumerate_paths(state, v) will return a vector (indexed by destination vertex) of paths from source v to all other vertices. In addition, enumerate_paths(state, v, d) will return a vector representing the path from vertex v to vertex d.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/shortestpaths/#Graphs.DEsopoPapeState","page":"Shortest paths","title":"Graphs.DEsopoPapeState","text":"struct DEposoPapeState{T, U}\n\nAn AbstractPathState designed for D`Esopo-Pape shortest-path calculations.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/shortestpaths/#Graphs.desopo_pape_shortest_paths-Union{Tuple{T}, Tuple{AbstractGraph, Integer}, Tuple{AbstractGraph, Integer, AbstractMatrix{T}}} where T<:Real","page":"Shortest paths","title":"Graphs.desopo_pape_shortest_paths","text":"desopo_pape_shortest_paths(g, src, distmx=weights(g))\n\nCompute shortest paths between a source src and all other nodes in graph g using the D'Esopo-Pape algorithm. Return a Graphs.DEsopoPapeState with relevant traversal information.\n\nExamples\n\njulia> using Graphs\n\njulia> ds = desopo_pape_shortest_paths(cycle_graph(5), 2);\n\njulia> ds.dists\n5-element Array{Int64,1}:\n 1\n 0\n 1\n 2\n 2\n\njulia> ds = desopo_pape_shortest_paths(path_graph(5), 2);\n\njulia> ds.dists\n5-element Array{Int64,1}:\n 1\n 0\n 1\n 2\n 3\n\n\n\n\n\n","category":"method"},{"location":"algorithms/shortestpaths/#Graphs.DijkstraState","page":"Shortest paths","title":"Graphs.DijkstraState","text":"struct DijkstraState{T, U}\n\nAn AbstractPathState designed for Dijkstra shortest-paths calculations.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/shortestpaths/#Graphs.dijkstra_shortest_paths-Union{Tuple{T}, Tuple{U}, Tuple{AbstractGraph, Vector{U}}, Tuple{AbstractGraph, Vector{U}, AbstractMatrix{T}}} where {U<:Integer, T<:Real}","page":"Shortest paths","title":"Graphs.dijkstra_shortest_paths","text":"dijkstra_shortest_paths(g, srcs, distmx=weights(g));\n\nPerform Dijkstra's algorithm on a graph, computing shortest distances between srcs and all other vertices. Return a Graphs.DijkstraState that contains various traversal information.\n\nOptional Arguments\n\nallpaths=false: If true, \n\nstate.predecessors holds a vector, indexed by vertex, of all the predecessors discovered during shortest-path calculations. This keeps track of all parents when there are multiple shortest paths available from the source.\n\nstate.pathcounts holds a vector, indexed by vertex, of the number of shortest paths from the source to that vertex.  The path count of a source vertex is always 1.0. The path count of an unreached vertex is always 0.0.\n\ntrackvertices=false: If true, \n\nstate.closest_vertices holds a vector of all vertices in the graph ordered from closest to farthest.\n\nPerformance\n\nIf using a sparse matrix for distmx, you may achieve better performance by passing in a transpose of its sparse transpose. That is, assuming D is the sparse distance matrix:\n\nD = transpose(sparse(transpose(D)))\n\nBe aware that realizing the sparse transpose of D incurs a heavy one-time penalty, so this strategy should only be used when multiple calls to dijkstra_shortest_paths with the distance matrix are planned.\n\nExamples\n\njulia> using Graphs\n\njulia> ds = dijkstra_shortest_paths(cycle_graph(5), 2);\n\njulia> ds.dists\n5-element Array{Int64,1}:\n 1\n 0\n 1\n 2\n 2\n\njulia> ds = dijkstra_shortest_paths(path_graph(5), 2);\n\njulia> ds.dists\n5-element Array{Int64,1}:\n 1\n 0\n 1\n 2\n 3\n\n\n\n\n\n","category":"method"},{"location":"algorithms/shortestpaths/#Graphs.FloydWarshallState","page":"Shortest paths","title":"Graphs.FloydWarshallState","text":"struct FloydWarshallState{T, U}\n\nAn AbstractPathState designed for Floyd-Warshall shortest-paths calculations.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/shortestpaths/#Graphs.floyd_warshall_shortest_paths-Union{Tuple{AbstractGraph{U}}, Tuple{T}, Tuple{U}, Tuple{AbstractGraph{U}, AbstractMatrix{T}}} where {U<:Integer, T<:Real}","page":"Shortest paths","title":"Graphs.floyd_warshall_shortest_paths","text":"floyd_warshall_shortest_paths(g, distmx=weights(g))\n\nUse the Floyd-Warshall algorithm to compute the shortest paths between all pairs of vertices in graph g using an optional distance matrix distmx. Return a Graphs.FloydWarshallState with relevant traversal information.\n\nPerformance\n\nSpace complexity is on the order of mathcalO(V^2).\n\n\n\n\n\n","category":"method"},{"location":"algorithms/shortestpaths/#Graphs.JohnsonState","page":"Shortest paths","title":"Graphs.JohnsonState","text":"struct JohnsonState{T, U}\n\nAn AbstractPathState designed for Johnson shortest-paths calculations.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/shortestpaths/#Graphs.johnson_shortest_paths-Union{Tuple{AbstractGraph{U}}, Tuple{T}, Tuple{U}, Tuple{AbstractGraph{U}, AbstractMatrix{T}}} where {U<:Integer, T<:Real}","page":"Shortest paths","title":"Graphs.johnson_shortest_paths","text":"johnson_shortest_paths(g, distmx=weights(g))\n\nUse the Johnson algorithm to compute the shortest paths between all pairs of vertices in graph g using an optional distance matrix distmx.\n\nReturn a Graphs.JohnsonState with relevant traversal information.\n\nPerformance\n\nComplexity: O(|V|*|E|)\n\n\n\n\n\n","category":"method"},{"location":"algorithms/shortestpaths/#Graphs.has_negative_edge_cycle_spfa-Union{Tuple{T}, Tuple{U}, Tuple{AbstractGraph{U}, AbstractMatrix{T}}} where {U<:Integer, T<:Real}","page":"Shortest paths","title":"Graphs.has_negative_edge_cycle_spfa","text":"Function which returns true if there is any negative weight cycle in the graph.\n\nExamples\n\njulia> g = complete_graph(3);\n\njulia> d = [1 -3 1; -3 1 1; 1 1 1];\n\njulia> has_negative_edge_cycle_spfa(g, d)\ntrue\n\njulia> g = complete_graph(4);\n\njulia> d = [1 1 -1 1; 1 1 -1 1; 1 1 1 1; 1 1 1 1];\n\njulia> has_negative_edge_cycle_spfa(g, d);\nfalse\n\n\n\n\n\n","category":"method"},{"location":"algorithms/shortestpaths/#Graphs.spfa_shortest_paths-Union{Tuple{T}, Tuple{U}, Tuple{AbstractGraph{U}, Integer}, Tuple{AbstractGraph{U}, Integer, AbstractMatrix{T}}} where {U<:Integer, T<:Real}","page":"Shortest paths","title":"Graphs.spfa_shortest_paths","text":"spfa_shortest_paths(g, s, distmx=weights(g))\n\nCompute shortest paths between a source s and all other nodes in graph g using the Shortest Path Faster Algorithm.\n\nExamples\n\njulia> g = complete_graph(3);\n\njulia> d = [1 -3 1; -3 1 1; 1 1 1];\n\njulia> spfa_shortest_paths(g, 1, d)\n\nERROR: Graphs.NegativeCycleError()\n\njulia> g = complete_graph(4);\n\njulia> d = [1 1 -1 1; 1 1 -1 1; 1 1 1 1; 1 1 1 1];\n\njulia> spfa_shortest_paths(gx, 1, d)\n\n4-element Array{Int64,1}:\n  0\n  0\n -1\n  0\n\n\n\n\n\n","category":"method"},{"location":"algorithms/shortestpaths/#Graphs.YenState","page":"Shortest paths","title":"Graphs.YenState","text":"struct YenState{T, U}\n\nDesigned for yen k-shortest-paths calculations.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/shortestpaths/#Graphs.yen_k_shortest_paths-Union{Tuple{T}, Tuple{U}, Tuple{AbstractGraph, U, U}, Tuple{AbstractGraph, U, U, AbstractMatrix{T}}, Tuple{AbstractGraph, U, U, AbstractMatrix{T}, Int64}} where {U<:Integer, T<:Real}","page":"Shortest paths","title":"Graphs.yen_k_shortest_paths","text":"yen_k_shortest_paths(g, source, target, distmx=weights(g), K=1; maxdist=Inf);\n\nPerform Yen's algorithm on a graph, computing k-shortest distances between source and target other vertices. Return a YenState that contains distances and paths.\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs/#SimpleGraphs-formats","page":"SimpleGraphs formats","title":"SimpleGraphs formats","text":"","category":"section"},{"location":"core_functions/simplegraphs/","page":"SimpleGraphs formats","title":"SimpleGraphs formats","text":"Graphs.jl provides two basic graph formats based on adjacency lists, along with many other functions defined in the Graphs.SimpleGraphs submodule.","category":"page"},{"location":"core_functions/simplegraphs/#Index","page":"SimpleGraphs formats","title":"Index","text":"","category":"section"},{"location":"core_functions/simplegraphs/","page":"SimpleGraphs formats","title":"SimpleGraphs formats","text":"Pages = [\"simplegraphs.md\"]","category":"page"},{"location":"core_functions/simplegraphs/#Full-docs","page":"SimpleGraphs formats","title":"Full docs","text":"","category":"section"},{"location":"core_functions/simplegraphs/","page":"SimpleGraphs formats","title":"SimpleGraphs formats","text":"Modules = [Graphs.SimpleGraphs]\nPages = [\n    \"SimpleGraphs/simpledigraph.jl\",\n    \"SimpleGraphs/simpleedge.jl\",\n    \"SimpleGraphs/simpleedgeiter.jl\",\n    \"SimpleGraphs/simplegraph.jl\",\n    \"SimpleGraphs/SimpleGraphs.jl\",\n    \"SimpleGraphs/specializations.jl\",\n]\n","category":"page"},{"location":"core_functions/simplegraphs/#Graphs.SimpleGraphs.SimpleDiGraph","page":"SimpleGraphs formats","title":"Graphs.SimpleGraphs.SimpleDiGraph","text":"SimpleDiGraph{T}\n\nA type representing a directed graph.\n\n\n\n\n\n","category":"type"},{"location":"core_functions/simplegraphs/#Graphs.SimpleGraphs.SimpleDiGraph-Tuple{AbstractMatrix}","page":"SimpleGraphs formats","title":"Graphs.SimpleGraphs.SimpleDiGraph","text":"SimpleDiGraph{T}(adjm::AbstractMatrix)\n\nConstruct a SimpleDiGraph{T} from the adjacency matrix adjm. If adjm[i][j] != 0, an edge (i, j) is inserted. adjm must be a square matrix. The element type T can be omitted.\n\nExamples\n\njulia> A1 = [false true; false false]\njulia> SimpleDiGraph(A1)\n{2, 1} directed simple Int64 graph\n\njulia> A2 = [2 7; 5 0]\njulia> SimpleDiGraph{Int16}(A2)\n{2, 3} directed simple Int16 graph\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs/#Graphs.SimpleGraphs.SimpleDiGraph-Tuple{Graphs.SimpleGraphs.AbstractSimpleGraph}","page":"SimpleGraphs formats","title":"Graphs.SimpleGraphs.SimpleDiGraph","text":"SimpleDiGraph(g::AbstractSimpleGraph)\n\nConstruct an directed SimpleDiGraph from a graph g. The element type is the same as for g.\n\nExamples\n\njulia> g = path_graph(Int8(5))\njulia> SimpleDiGraph(g)\n{5, 8} directed simple Int8 graph\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs/#Graphs.SimpleGraphs.SimpleDiGraph-Union{Tuple{Array{Graphs.SimpleGraphs.SimpleEdge{T}, 1}}, Tuple{T}} where T<:Integer","page":"SimpleGraphs formats","title":"Graphs.SimpleGraphs.SimpleDiGraph","text":"SimpleDiGraph(edge_list::Vector)\n\nConstruct a SimpleDiGraph from a vector of edges. The element type is taken from the edges in edge_list. The number of vertices is the highest that is used in an edge in edge_list.\n\nImplementation Notes\n\nThis constructor works the fastest when edge_list is sorted by the lexical ordering and does not contain any duplicates.\n\nSee also\n\nSimpleDiGraphFromIterator\n\nExamples\n\n\njulia> el = Edge.([ (1, 3), (1, 5), (3, 1) ])\njulia> SimpleDiGraph(el)\n{5, 3} directed simple Int64 graph\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs/#Graphs.SimpleGraphs.SimpleDiGraph-Union{Tuple{SimpleDiGraph}, Tuple{T}} where T<:Integer","page":"SimpleGraphs formats","title":"Graphs.SimpleGraphs.SimpleDiGraph","text":"SimpleDiGraph{T}(g::SimpleDiGraph)\n\nConstruct a copy of g. If the element type T is specified, the vertices of g are converted to this type. Otherwise the element type is the same as for g.\n\nExamples\n\njulia> g = complete_digraph(5)\njulia> SimpleDiGraph{UInt8}(g)\n{5, 20} directed simple UInt8 graph\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs/#Graphs.SimpleGraphs.SimpleDiGraph-Union{Tuple{Type{T}}, Tuple{T}} where T<:Integer","page":"SimpleGraphs formats","title":"Graphs.SimpleGraphs.SimpleDiGraph","text":"SimpleDiGraph(::Type{T})\n\nConstruct an empty SimpleDiGraph{T} with 0 vertices and 0 edges.\n\nExamples\n\njulia> SimpleDiGraph(UInt8)\n{0, 0} directed simple UInt8 graph\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs/#Graphs.SimpleGraphs.SimpleDiGraph-Union{Tuple{}, Tuple{Integer}, Tuple{T}} where T<:Integer","page":"SimpleGraphs formats","title":"Graphs.SimpleGraphs.SimpleDiGraph","text":"SimpleDiGraph{T}(n=0)\n\nConstruct a SimpleDiGraph{T} with n vertices and 0 edges. If not specified, the element type T is the type of n.\n\nExamples\n\njulia> SimpleDiGraph(UInt8(10))\n{10, 0} directed simple UInt8 graph\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs/#Graphs.SimpleGraphs.SimpleDiGraphFromIterator-Tuple{Any}","page":"SimpleGraphs formats","title":"Graphs.SimpleGraphs.SimpleDiGraphFromIterator","text":"SimpleDiGraphFromIterator(iter)\n\nCreate a SimpleDiGraph from an iterator iter. The elements in iter must be of type <: SimpleEdge.\n\nExamples\n\njulia> using Graphs\n\njulia> g = SimpleDiGraph(2);\n\njulia> add_edge!(g, 1, 2);\n\njulia> add_edge!(g, 2, 1);\n\njulia> h = SimpleDiGraphFromIterator(edges(g))\n{2, 2} directed simple Int64 graph\n\njulia> collect(edges(h))\n2-element Array{Graphs.SimpleGraphs.SimpleEdge{Int64},1}:\n Edge 1 => 2\n Edge 2 => 1\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs/#Graphs.SimpleGraphs.SimpleEdgeIter","page":"SimpleGraphs formats","title":"Graphs.SimpleGraphs.SimpleEdgeIter","text":"SimpleEdgeIter\n\nThe function edges returns a SimpleEdgeIter for AbstractSimpleGraphs. The iterates are in lexicographical order, smallest first. The iterator is valid for one pass over the edges, and is invalidated by changes to the graph.\n\nExamples\n\njulia> using Graphs\n\njulia> g = path_graph(3);\n\njulia> es = edges(g)\nSimpleEdgeIter 2\n\njulia> e_it = iterate(es)\n(Edge 1 => 2, SimpleEdgeIterState [2, 2])\n\njulia> iterate(es, e_it[2])\n(Edge 2 => 3, SimpleEdgeIterState [0, 1])\n\n\n\n\n\n","category":"type"},{"location":"core_functions/simplegraphs/#Graphs.SimpleGraphs.SimpleGraph","page":"SimpleGraphs formats","title":"Graphs.SimpleGraphs.SimpleGraph","text":"SimpleGraph{T}\n\nA type representing an undirected graph.\n\n\n\n\n\n","category":"type"},{"location":"core_functions/simplegraphs/#Graphs.SimpleGraphs.SimpleGraph-Tuple{AbstractMatrix}","page":"SimpleGraphs formats","title":"Graphs.SimpleGraphs.SimpleGraph","text":"SimpleGraph{T}(adjm::AbstractMatrix)\n\nConstruct a SimpleGraph{T} from the adjacency matrix adjm. If adjm[i][j] != 0, an edge (i, j) is inserted. adjm must be a square and symmetric matrix. The element type T can be omitted.\n\nExamples\n\njulia> A1 = [false true; true false]\njulia> SimpleGraph(A1)\n{2, 1} undirected simple Int64 graph\n\njulia> A2 = [2 7; 7 0]\njulia> SimpleGraph{Int16}(A2)\n{2, 2} undirected simple Int16 graph\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs/#Graphs.SimpleGraphs.SimpleGraph-Tuple{SimpleDiGraph}","page":"SimpleGraphs formats","title":"Graphs.SimpleGraphs.SimpleGraph","text":"SimpleGraph(g::SimpleDiGraph)\n\nConstruct an undirected SimpleGraph from a directed SimpleDiGraph. Every directed edge in g is added as an undirected edge. The element type is the same as for g.\n\nExamples\n\njulia> g = path_digraph(Int8(5))\njulia> SimpleGraph(g)\n{5, 4} undirected simple Int8 graph\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs/#Graphs.SimpleGraphs.SimpleGraph-Tuple{SimpleGraph}","page":"SimpleGraphs formats","title":"Graphs.SimpleGraphs.SimpleGraph","text":"SimpleGraph{T}(g::SimpleGraph)\n\nConstruct a copy of g. If the element type T is specified, the vertices of g are converted to this type. Otherwise the element type is the same as for g.\n\nExamples\n\njulia> g = complete_graph(5)\njulia> SimpleGraph{UInt8}(g)\n{5, 10} undirected simple UInt8 graph\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs/#Graphs.SimpleGraphs.SimpleGraph-Union{Tuple{Array{Graphs.SimpleGraphs.SimpleEdge{T}, 1}}, Tuple{T}} where T<:Integer","page":"SimpleGraphs formats","title":"Graphs.SimpleGraphs.SimpleGraph","text":"SimpleGraph(edge_list::Vector)\n\nConstruct a SimpleGraph from a vector of edges. The element type is taken from the edges in edge_list. The number of vertices is the highest that is used in an edge in edge_list.\n\nImplementation Notes\n\nThis constructor works the fastest when edge_list is sorted by the lexical ordering and does not contain any duplicates.\n\nSee also\n\nSimpleGraphFromIterator\n\nExamples\n\n\njulia> el = Edge.([ (1, 2), (1, 5) ])\njulia> SimpleGraph(el)\n{5, 2} undirected simple Int64 graph\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs/#Graphs.SimpleGraphs.SimpleGraph-Union{Tuple{Type{T}}, Tuple{T}} where T<:Integer","page":"SimpleGraphs formats","title":"Graphs.SimpleGraphs.SimpleGraph","text":"SimpleGraph(::Type{T})\n\nConstruct an empty SimpleGraph{T} with 0 vertices and 0 edges.\n\nExamples\n\njulia> SimpleGraph(UInt8)\n{0, 0} undirected simple UInt8 graph\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs/#Graphs.SimpleGraphs.SimpleGraph-Union{Tuple{}, Tuple{Integer}, Tuple{T}} where T<:Integer","page":"SimpleGraphs formats","title":"Graphs.SimpleGraphs.SimpleGraph","text":"SimpleGraph{T}(n=0)\n\nConstruct a SimpleGraph{T} with n vertices and 0 edges. If not specified, the element type T is the type of n.\n\nExamples\n\njulia> SimpleGraph(UInt8(10))\n{10, 0} undirected simple UInt8 graph\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs/#Graphs.SimpleGraphs.SimpleGraphFromIterator-Tuple{Any}","page":"SimpleGraphs formats","title":"Graphs.SimpleGraphs.SimpleGraphFromIterator","text":"SimpleGraphFromIterator(iter)\n\nCreate a SimpleGraph from an iterator iter. The elements in iter must be of type <: SimpleEdge.\n\nExamples\n\njulia> using Graphs\n\njulia> g = SimpleGraph(3);\n\njulia> add_edge!(g, 1, 2);\n\njulia> add_edge!(g, 2, 3);\n\njulia> h = SimpleGraphFromIterator(edges(g));\n\njulia> collect(edges(h))\n2-element Array{Graphs.SimpleGraphs.SimpleEdge{Int64},1}:\n Edge 1 => 2\n Edge 2 => 3\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs/#Graphs.SimpleGraphs.add_edge!-Union{Tuple{T}, Tuple{SimpleGraph{T}, Graphs.SimpleGraphs.SimpleEdge{T}}} where T","page":"SimpleGraphs formats","title":"Graphs.SimpleGraphs.add_edge!","text":"add_edge!(g, e)\n\nAdd an edge e to graph g. Return true if edge was added successfully, otherwise return false.\n\nExamples\n\njulia> using Graphs\n\njulia> g = SimpleGraph(2);\n\njulia> add_edge!(g, 1, 2)\ntrue\n\njulia> add_edge!(g, 2, 3)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs/#Graphs.SimpleGraphs.add_vertex!-Union{Tuple{SimpleGraph{T}}, Tuple{T}} where T","page":"SimpleGraphs formats","title":"Graphs.SimpleGraphs.add_vertex!","text":"add_vertex!(g)\n\nAdd a new vertex to the graph g. Return true if addition was successful.\n\nExamples\n\njulia> using Graphs\n\njulia> g = SimpleGraph(Int8(typemax(Int8) - 1))\n{126, 0} undirected simple Int8 graph\n\njulia> add_vertex!(g)\ntrue\n\njulia> add_vertex!(g)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs/#Graphs.SimpleGraphs.adj-Tuple{SimpleGraph}","page":"SimpleGraphs formats","title":"Graphs.SimpleGraphs.adj","text":"adj(g[, v])\n\nReturn the adjacency list of a graph. If v is specified, return only the adjacency list for that vertex.\n\nImplementation Notes\n\nReturns a reference to the current graph's internal structures, not a copy. Do not modify result. If the graph is modified, the behavior is undefined: the array behind this reference may be modified too, but this is not guaranteed.\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs/#Graphs.SimpleGraphs.badj-Tuple{SimpleGraph}","page":"SimpleGraphs formats","title":"Graphs.SimpleGraphs.badj","text":"badj(g::SimpleGraph[, v::Integer])\n\nReturn the backwards adjacency list of a graph. If v is specified, return only the adjacency list for that vertex.\n\n###Implementation Notes Returns a reference to the current graph's internal structures, not a copy. Do not modify result. If the graph is modified, the behavior is undefined: the array behind this reference may be modified too, but this is not guaranteed.\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs/#Graphs.SimpleGraphs.rem_edge!-Union{Tuple{T}, Tuple{SimpleGraph{T}, Graphs.SimpleGraphs.SimpleEdge{T}}} where T","page":"SimpleGraphs formats","title":"Graphs.SimpleGraphs.rem_edge!","text":"rem_edge!(g, e)\n\nRemove an edge e from graph g. Return true if edge was removed successfully, otherwise return false.\n\nImplementation Notes\n\nIf rem_edge! returns false, the graph may be in an indeterminate state, as there are multiple points where the function can exit with false.\n\nExamples\n\njulia> using Graphs\n\njulia> g = SimpleGraph(2);\n\njulia> add_edge!(g, 1, 2);\n\njulia> rem_edge!(g, 1, 2)\ntrue\n\njulia> rem_edge!(g, 1, 2)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs/#Graphs.SimpleGraphs.rem_vertices!-Union{Tuple{T}, Tuple{SimpleGraph{T}, AbstractVector{<:Integer}}} where T<:Integer","page":"SimpleGraphs formats","title":"Graphs.SimpleGraphs.rem_vertices!","text":"rem_vertices!(g, vs, keep_order=false) -> vmap\n\nRemove all vertices in vs from g. Return a vector vmap that maps the vertices in the modified graph to the ones in the unmodified graph. If keep_order is true, the vertices in the modified graph appear in the same order as they did in the unmodified graph. This might be slower.\n\nImplementation Notes\n\nThis function is not part of the official Graphs API and is subject to change/removal between major versions.\n\nExamples\n\njulia> using Graphs\n\njulia> g = complete_graph{5}\n{5, 10} undirected simple Int64 graph\n\njulia> vmap = rem_vertices!(g, [2, 4], keep_order=true);\n\njulia> vmap\n3-element Array{Int64,1}:\n 1\n 3\n 5\n\njulia> g\n{3, 3} undirected simple Int64 graph\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs/#Graphs.is_directed-Tuple{Type{<:SimpleGraph}}","page":"SimpleGraphs formats","title":"Graphs.is_directed","text":"is_directed(g)\n\nReturn true if g is a directed graph.\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs/#Graphs.SimpleGraphs.AbstractSimpleGraph","page":"SimpleGraphs formats","title":"Graphs.SimpleGraphs.AbstractSimpleGraph","text":"AbstractSimpleGraph\n\nAn abstract type representing a simple graph structure. AbstractSimpleGraphs must have the following elements:\n\nvertices::UnitRange{Integer}\nfadjlist::Vector{Vector{Integer}}\nne::Integer\n\n\n\n\n\n","category":"type"},{"location":"core_functions/simplegraphs/#Graphs.SimpleGraphs.rem_vertex!-Tuple{Graphs.SimpleGraphs.AbstractSimpleGraph, Integer}","page":"SimpleGraphs formats","title":"Graphs.SimpleGraphs.rem_vertex!","text":"rem_vertex!(g, v)\n\nRemove the vertex v from graph g. Return false if removal fails (e.g., if vertex is not in the graph); true otherwise.\n\nPerformance\n\nTime complexity is mathcalO(k^2), where k is the max of the degrees of vertex v and vertex V.\n\nImplementation Notes\n\nThis operation has to be performed carefully if one keeps external data structures indexed by edges or vertices in the graph, since internally the removal is performed swapping the vertices v  and V, and removing the last vertex V from the graph. After removal the vertices in g will be indexed by 1V-1.\n\nExamples\n\njulia> using Graphs\n\njulia> g = SimpleGraph(2);\n\njulia> rem_vertex!(g, 2)\ntrue\n\njulia> rem_vertex!(g, 2)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs/#Graphs.SimpleGraphs.throw_if_invalid_eltype-Tuple{Type{<:Integer}}","page":"SimpleGraphs formats","title":"Graphs.SimpleGraphs.throw_if_invalid_eltype","text":"throw_if_invalid_eltype(T)\n\nInternal function, throw a DomainError if T is not a concrete type Integer. Can be used in the constructor of AbstractSimpleGraphs, as Julia's typesystem does not enforce concrete types, which can lead to problems. E.g SimpleGraph{Signed}.\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs/#Graphs.squash-Tuple{Union{SimpleDiGraph, SimpleGraph}}","page":"SimpleGraphs formats","title":"Graphs.squash","text":"squash(g::Union{SimpleGraph, SimpleDiGraph}; alwayscopy=true)\n\nSpecialised version of Graphs.squash for SimpleGraph and SimpleDiGraph. If alwayscopy is true, the resulting graph will always be a copy, otherwise it can also be the original graph.\n\n\n\n\n\n","category":"method"},{"location":"first_steps/access/#Graph-access","page":"Graph access","title":"Graph access","text":"","category":"section"},{"location":"first_steps/access/","page":"Graph access","title":"Graph access","text":"The following is an overview of functions for accessing graph properties.","category":"page"},{"location":"first_steps/access/#Global-graph-properties","page":"Graph access","title":"Global graph properties","text":"","category":"section"},{"location":"first_steps/access/","page":"Graph access","title":"Graph access","text":"nv(g) returns the number of vertices in g.\nne(g) returns the number of edges in g.\nvertices(g) returns an iterable object containing all the vertices in g.\nedges(g) returns an iterable object containing all the edges in g.\nhas_vertex(g, v) checks whether graph g includes a vertex numbered v.\nhas_edge(g, s, d) checks whether graph g includes an edge from the source vertex s to the destination vertex d.\nhas_edge(g, e) returns true if there is an edge in g that satisfies e == f for any f ∈ edges(g). This is a strict equality test that may require all properties of e are the same. This definition of equality depends on the implementation. For testing whether an edge exists between two vertices s,d use has_edge(g, s, d). Note: to use the has_edge(g, e) method safely, it is important to understand the conditions under which edges are equal to each other. These conditions are defined by the has_edge(g::G,e) method as defined by the graph type G. The default behavior is to check has_edge(g,src(e),dst(e)). This distinction exists to allow new graph types such as MetaGraphs or MultiGraphs to distinguish between edges with the same source and destination but potentially different properties.\nhas_self_loops(g) checks for self-loops in g.\nis_directed(g) checks if g is a directed graph.\neltype(g) returns the type of the vertices of g.","category":"page"},{"location":"first_steps/access/#Vertex-properties","page":"Graph access","title":"Vertex properties","text":"","category":"section"},{"location":"first_steps/access/","page":"Graph access","title":"Graph access","text":"neighbors(g, v) returns the neighbors of vertex v in an iterable (if g is directed, only outneighbors are returned).\nall_neighbors( returns all the neighbors of vertex v (if g is directed, both inneighbors and outneighbors are returned).\ninneighbors return the inneighbors of vertex v (equivalent to neighbors for undirected graphs).\noutneighbors returns the outneighbors of vertex v (equivalent to neighbors for undirected graphs).","category":"page"},{"location":"first_steps/access/#Edge-properties","page":"Graph access","title":"Edge properties","text":"","category":"section"},{"location":"first_steps/access/","page":"Graph access","title":"Graph access","text":"src(e) gives the source vertex s of an edge (s, d).\ndst(e) gives the destination vertex d of an edge (s, d).\nreverse(e) creates a new edge (d, s) from edge (s, d).","category":"page"},{"location":"algorithms/cycles/#Cycles","page":"Cycles","title":"Cycles","text":"","category":"section"},{"location":"algorithms/cycles/","page":"Cycles","title":"Cycles","text":"Graphs.jl contains numerous algorithms related to cycles.","category":"page"},{"location":"algorithms/cycles/#Index","page":"Cycles","title":"Index","text":"","category":"section"},{"location":"algorithms/cycles/","page":"Cycles","title":"Cycles","text":"Pages = [\"cycles.md\"]","category":"page"},{"location":"algorithms/cycles/#Full-docs","page":"Cycles","title":"Full docs","text":"","category":"section"},{"location":"algorithms/cycles/","page":"Cycles","title":"Cycles","text":"Modules = [Graphs]\nPages = [\n    \"cycles/basis.jl\",\n    \"cycles/hawick-james.jl\",\n    \"cycles/incremental.jl\",\n    \"cycles/johnson.jl\",\n    \"cycles/karp.jl\",\n    \"cycles/limited_length.jl\",\n]\n","category":"page"},{"location":"algorithms/cycles/#Graphs.cycle_basis","page":"Cycles","title":"Graphs.cycle_basis","text":"cycle_basis(g, root=nothing)\n\nReturn a list of cycles which form a basis for cycles of the undirected graph g, optionally starting at node root.\n\nA basis for cycles of a network is a minimal collection of cycles such that any cycle in the network can be written as a sum of cycles in the basis.  Here summation of cycles is defined as \"exclusive or\" of the edges. Cycle bases are useful, e.g. when deriving equations for electric circuits using Kirchhoff's Laws.\n\nExamples\n\njulia> elist = [(1,2),(2,3),(2,4),(3,4),(4,1),(1,5)];\n\njulia> g = SimpleGraph(SimpleEdge.(elist));\n\njulia> cycle_basis(g)\n2-element Array{Array{Int64,1},1}:\n [2, 3, 4]\n [2, 1, 3]\n\nReferences\n\nPaton, K. An algorithm for finding a fundamental set of cycles of a graph. Comm. ACM 12, 9 (Sept 1969), 514-518. [https://dl.acm.org/citation.cfm?id=363232]\n\n\n\n\n\n","category":"function"},{"location":"algorithms/cycles/#Graphs.circuit_recursive!","page":"Cycles","title":"Graphs.circuit_recursive!","text":"circuit_recursive!(g, v1, v2, blocked, B, stack, cycles)\n\nFind circuits in g recursively starting from v1.\n\n\n\n\n\n","category":"function"},{"location":"algorithms/cycles/#Graphs.resetB!-Tuple{Any}","page":"Cycles","title":"Graphs.resetB!","text":"resetB!(B)\n\nReset B work structure.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/cycles/#Graphs.resetblocked!-Tuple{Any}","page":"Cycles","title":"Graphs.resetblocked!","text":"resetblocked!(blocked)\n\nReset vector of blocked vertices.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/cycles/#Graphs.simplecycles_hawick_james","page":"Cycles","title":"Graphs.simplecycles_hawick_james","text":"simplecycles_hawick_james(g)\n\nFind circuits (including self-loops) in g using the algorithm of Hawick & James.\n\nReferences\n\nHawick & James, \"Enumerating Circuits and Loops in Graphs with Self-Arcs and Multiple-Arcs\", 2008\n\n\n\n\n\n","category":"function"},{"location":"algorithms/cycles/#Graphs.unblock!-Union{Tuple{T}, Tuple{T, AbstractVector, Array{Vector{T}, 1}}} where T","page":"Cycles","title":"Graphs.unblock!","text":"unblock!(v, blocked, B)\n\nUnblock the value v from the blocked list and remove from B.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/cycles/#Graphs.DenseGraphICT_BFGT_N","page":"Cycles","title":"Graphs.DenseGraphICT_BFGT_N","text":"struct DenseGraphICT_BFGT_N\n\nImplements the \"Naive\" (Algorithm N) Bender-Fineman-Gilbert-Tarjan one-way line search incremental cycle detector for dense graphs from BFGT15 (Section 3).\n\nReferences\n\nBFGT15: Michael A. Bender, Jeremy T. Fineman, Seth Gilbert, and Robert E. Tarjan. 2015     A New Approach to Incremental Cycle Detection and Related Problems.     ACM Trans. Algorithms 12, 2, Article 14 (December 2015), 22 pages.     DOI: http://dx.doi.org/10.1145/2756553\n\n\n\n\n\n","category":"type"},{"location":"algorithms/cycles/#Graphs.IncrementalCycleTracker","page":"Cycles","title":"Graphs.IncrementalCycleTracker","text":"abstract type IncrementalCycleTracker\n\nThe supertype for incremental cycle detection problems. The abstract type constructor IncrementalCycleTracker(G) may be used to automatically select a specific incremental cycle detection algorithm. See add_edge_checked! for a usage example.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/cycles/#Graphs.TransactionalVector","page":"Cycles","title":"Graphs.TransactionalVector","text":"struct TransactionalVector\n\nA vector with one checkpoint that may be reverted to by calling revert!. The setpoint itself is set by calling commit!.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/cycles/#Graphs.add_edge_checked!","page":"Cycles","title":"Graphs.add_edge_checked!","text":"add_edge_checked!([f!,], ict::IncrementalCycleTracker, v, w)\n\nUsing the incremental cycle tracker, ict, check whether adding the edge v=>w would introduce a cycle in the underlying graph. If so, return false and leave the ict intact. If not, update the underlying graph and return true.\n\nOptional f! Argument\n\nBy default the add_edge! function is used to update the underlying graph. However, for more complicated graphs, users may wish to manually specify the graph update operation. This may be accomplished by passing the optional f! callback argument. This callback is called on the underlying graph when no cycle is detected and is required to modify the underlying graph in order to effectuate the proposed edge addition.\n\nBatched edge additions\n\nOptionally, either v or w (depending on the in_out_reverse flag) may be a collection of vertices representing a batched addition of vertices sharing a common source or target more efficiently than individual updates.\n\nExample\n\njulia> G = SimpleDiGraph(3)\n\njulia> ict = IncrementalCycleTracker(G)\nBFGT_N cycle tracker on {3, 0} directed simple Int64 graph\n\njulia> add_edge_checked!(ict, 1, 2)\ntrue\n\njulia> collect(edges(G))\n1-element Vector{Graphs.SimpleGraphs.SimpleEdge{Int64}}:\n Edge 1 => 2\n\njulia> add_edge_checked!(ict, 2, 3)\ntrue\n\njulia> collect(edges(G))\n2-element Vector{Graphs.SimpleGraphs.SimpleEdge{Int64}}:\n Edge 1 => 2\n Edge 2 => 3\n\njulia> add_edge_checked!(ict, 3, 1) # Would add a cycle\nfalse\n\njulia> collect(edges(G))\n2-element Vector{Graphs.SimpleGraphs.SimpleEdge{Int64}}:\nEdge 1 => 2\nEdge 2 => 3\n\n\n\n\n\n","category":"function"},{"location":"algorithms/cycles/#Graphs.JohnsonVisitor","page":"Cycles","title":"Graphs.JohnsonVisitor","text":"type JohnsonVisitor{T<:Integer} <: Visitor{T}\n    stack::Vector{T}\n    blocked::BitVector\n    blockedmap::Vector{Set{T}}\nend\n\nJohnsonVisitor(dg::::IsDirected)\n\n\nComposite type that regroups the information needed for Johnson's algorithm.\n\nstack is the stack of visited vertices. blocked is a boolean for each vertex that tells whether it is blocked or not. blockedmap tells which vertices to unblock if the key vertex is unblocked.\n\nJohnsonVisitor may also be constructed directly from the directed graph.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/cycles/#Graphs.circuit","page":"Cycles","title":"Graphs.circuit","text":"circuit{T<:Integer}(v::T, dg::::IsDirected, vis::JohnsonVisitor{T},\nallcycles::Vector{Vector{T}}, vmap::Vector{T}, startnode::T = v)\n\nReturn one step of the recursive version of simple cycle detection, using a DFS algorithm.\n\nv: the vertex considered in this iteration of the DFS\ndg: the digraph from which cycles are computed\nvisitor: Informations needed for the cycle computation, contains:\nstack: the stack of parent vertices\nblocked: tells whether a vertex has already been explored or not\nblockedmap: mapping of the blocking / unblocking consequences\nallcycles: output containing the cycles already detected\nvmap: vector map containing the link from the old to the new nodes of the directed graph\nstartnode = v: optional argument giving the starting node. In the first iteration,\n\nthe same as v, otherwise it should be passed.\n\nImplementation Notes\n\nImplements Johnson's CIRCUIT function. This is a recursive version. Modifies the vector of cycles, when needed.\n\nReferences\n\nJohnson\n\n\n\n\n\n","category":"function"},{"location":"algorithms/cycles/#Graphs.circuit_iter","page":"Cycles","title":"Graphs.circuit_iter","text":"circuit_iter{T<:Integer}(v::T, dg::::IsDirected, vis::JohnsonVisitor{T},\nvmap::Vector{T}, cycle::Channel, startnode::T = v)\n\nExecute one step of the recursive version of simple cycle detection, using a DFS algorithm. Return true if a circuit has been found in the current exploration.\n\nArguments\n\nv: the vertex considered in this iteration of the DFS\ndg: the digraph from which cycles are computed\nvisitor: Informations needed for the cycle computation, contains:\nstack: the stack of parent vertices\nblocked: tells whether a vertex has already been explored or not\nblockedmap: mapping of the blocking / unblocking consequences\nvmap: vector map containing the link from the old to the new nodes of the directed graph\ncycle: storage of the channel\nstartnode = v: optional argument giving the starting node. In the first iteration,\n\nthe same as v, otherwise it should be passed.\n\nImplementation Notes\n\nImplements the CIRCUIT function from Johnson's algorithm, recursive and iterative version. Produces a cycle when needed. Can be used only inside a Channel.\n\nReferences\n\nJohnson\n\n\n\n\n\n","category":"function"},{"location":"algorithms/cycles/#Graphs.itercycles","page":"Cycles","title":"Graphs.itercycles","text":"itercycles(dg::::IsDirected, cycle::Channel)\n\nCompute all cycles of the given directed graph, using Johnson's algorithm.\n\nImplementation Notes\n\nIterative version of the algorithm, using Channels to stop the exploration after a given number of cycles.\n\nReferences\n\nJohnson\n\n\n\n\n\n","category":"function"},{"location":"algorithms/cycles/#Graphs.maxsimplecycles","page":"Cycles","title":"Graphs.maxsimplecycles","text":"maxsimplecycles(dg::::IsDirected, byscc::Bool = true)\n\nCompute the theoretical maximum number of cycles in the directed graph dg.\n\nThe computation can be performed assuming the graph is complete or taking into account the decomposition in strongly connected components (byscc parameter).\n\nPerformance\n\nA more efficient version is possible.\n\nReferences\n\nJohnson\n\n\n\n\n\n","category":"function"},{"location":"algorithms/cycles/#Graphs.maxsimplecycles-Tuple{Integer}","page":"Cycles","title":"Graphs.maxsimplecycles","text":"maxsimplecycles(n::Integer)\n\nCompute the theoretical maximum number of cycles in a directed graph of n vertices, assuming there are no self-loops.\n\nReferences\n\nJohnson.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/cycles/#Graphs.ncycles_n_i-Tuple{Integer, Integer}","page":"Cycles","title":"Graphs.ncycles_n_i","text":"ncycles_n_i(n::Integer, i::Integer)\n\nCompute the theoretical maximum number of cycles of size i in a directed graph of n  vertices.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/cycles/#Graphs.simplecycles","page":"Cycles","title":"Graphs.simplecycles","text":"simplecycles(dg::::IsDirected)\n\nCompute and return all cycles of the given directed graph using Johnson's algorithm.\n\nPerformance\n\nThe number of cycles grows more than exponentially with the number of vertices, you might want to use the algorithm with a ceiling – simplecycles_iter – on large directed graphs (slightly slower). If you want to have an idea of the possible number of cycles, look at function maxsimplecycles(dg::DiGraph, byscc::Bool = true). If you only need short cycles of a limited length, simplecycles_limited_length can be more efficient.\n\nReferences\n\nJohnson\n\nExamples\n\njulia> simplecycles(complete_digraph(3))\n5-element Array{Array{Int64,1},1}:\n [1, 2]\n [1, 2, 3]\n [1, 3]\n [1, 3, 2]\n [2, 3]\n\n\n\n\n\n","category":"function"},{"location":"algorithms/cycles/#Graphs.simplecycles_iter","page":"Cycles","title":"Graphs.simplecycles_iter","text":"simplecycles_iter(dg::DiGraph, ceiling = 10^6)\n\nSearch all cycles of the given directed graph, using Johnson's algorithm, up to the ceiling (to avoid memory overload).\n\nImplementation Notes\n\nIf the graph is small, the ceiling will not be reached and simplecycles(dg::DiGraph) is more efficient. It avoids the overhead of the counting and testing if the ceiling is reached. It returns all the cycles of the directed graph if the ceiling is not reached, a subset of them otherwise.\n\nTo get an idea of the possible number of cycles, use function `maxsimplecycles(dg::DiGraph, byscc::Bool = true) on the directed graph.\n\nReferences\n\nJohnson\n\n\n\n\n\n","category":"function"},{"location":"algorithms/cycles/#Graphs.simplecyclescount","page":"Cycles","title":"Graphs.simplecyclescount","text":"simplecyclescount(dg::DiGraph, ceiling = 10^6)\n\nCount the number of cycles in a directed graph, using Johnson's algorithm. Return the minimum of the ceiling and the number of cycles.\n\nImplementation Notes\n\nThe ceiling is here to avoid memory overload if there are a lot of cycles in the graph. Default value is 10^6, but it can be higher or lower. You can use the function maxsimplecycles(dg::DiGraph, byscc::Bool = true) to get an idea of the theoretical maximum number or cycles.\n\nReferences\n\nJohnson\n\nExamples\n\njulia> simplecyclescount(complete_digraph(6))\n409\n\n\n\n\n\n","category":"function"},{"location":"algorithms/cycles/#Graphs.simplecycleslength","page":"Cycles","title":"Graphs.simplecycleslength","text":"simplecycleslength(dg::DiGraph, ceiling = 10^6)\n\nSearch all cycles of the given directed graph, using Johnson's algorithm, and return a tuple representing the cycle length and the number of cycles.\n\nImplementation Notes\n\nTo get an idea of the possible number of cycles, using function maxsimplecycles(dg::DiGraph, byscc::Bool = true) on the directed graph.\n\nIf the ceiling is reached (ncycles = ceiling), the output is only a subset of the cycles lengths.\n\nReferences\n\nJohnson\n\nExamples\n\njulia> simplecycleslength(complete_digraph(16))\n([0, 1, 1, 1, 1, 1, 2, 10, 73, 511, 3066, 15329, 61313, 183939, 367876, 367876], 1000000)\n\njulia> simplecycleslength(wheel_digraph(16))\n([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], 1)\n\n\n\n\n\n","category":"function"},{"location":"algorithms/cycles/#Graphs.unblock!-Union{Tuple{T}, Tuple{T, BitVector, Array{Set{T}, 1}}} where T<:Integer","page":"Cycles","title":"Graphs.unblock!","text":"unblock!{T<:Integer}(v::T, blocked::BitVector, B::Vector{Set{T}})\n\nUnblock the vertices recursively.\n\nv is the vertex to unblock, blocked tells whether a vertex is blocked or not and B is the map that tells if the unblocking of one vertex should unblock other vertices.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/cycles/#Graphs.karp_minimum_cycle_mean","page":"Cycles","title":"Graphs.karp_minimum_cycle_mean","text":"karp_minimum_cycle_mean(g[, distmx])\n\nReturn minimum cycle mean of the directed graph g with optional edge weights contained in distmx.\n\nReferences\n\nKarp.\n\n\n\n\n\n","category":"function"},{"location":"algorithms/cycles/#Graphs.simplecycles_limited_length-Union{Tuple{T}, Tuple{AbstractGraph{T}, Int64}, Tuple{AbstractGraph{T}, Int64, Any}} where T","page":"Cycles","title":"Graphs.simplecycles_limited_length","text":"simplecycles_limited_length(g, n, ceiling=10^6)\n\nCompute and return at most ceiling cycles of length at most n of the given graph. Both directed and undirected graphs are supported.\n\nPerformance\n\nThe number of cycles grows very fast with the number of vertices and the allowed length of the cycles. This function is intended for finding short cycles. If you want to find cycles of any length in a directed graph, simplecycles or simplecycles_iter may be more efficient.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/community/#Community-structures","page":"Community structures","title":"Community structures","text":"","category":"section"},{"location":"algorithms/community/","page":"Community structures","title":"Community structures","text":"Graphs.jl contains several algorithms to detect and analyze community structures.","category":"page"},{"location":"algorithms/community/#Index","page":"Community structures","title":"Index","text":"","category":"section"},{"location":"algorithms/community/","page":"Community structures","title":"Community structures","text":"Pages = [\"community.md\"]","category":"page"},{"location":"algorithms/community/#Full-docs","page":"Community structures","title":"Full docs","text":"","category":"section"},{"location":"algorithms/community/","page":"Community structures","title":"Community structures","text":"Modules = [Graphs]\nPages = [\n    \"community/assortativity.jl\",\n    \"community/clique_percolation.jl\",\n    \"community/cliques.jl\",\n    \"community/clustering.jl\",\n    \"community/core-periphery.jl\",\n    \"community/label_propagation.jl\",\n    \"community/modularity.jl\",\n    \"community/rich_club.jl\",\n]\n","category":"page"},{"location":"algorithms/community/#Graphs.assortativity-Union{Tuple{AbstractGraph{T}}, Tuple{T}} where T","page":"Community structures","title":"Graphs.assortativity","text":"assortativity(g)\n\nReturn the assortativity coefficient of graph g, defined as the Pearson correlation of excess degree between the end vertices of all the edges of the graph.\n\nThe excess degree is equal to the degree of linked vertices minus one, i.e. discounting the edge that links the pair. In directed graphs, the paired values are the out-degree of source vertices and the in-degree of destination vertices.\n\nExamples\n\njulia> using Graphs\n\njulia> assortativity(star_graph(4))\n-1.0\n\n\n\n\n\n","category":"method"},{"location":"algorithms/community/#Graphs.clique_percolation","page":"Community structures","title":"Graphs.clique_percolation","text":"clique_percolation(g, k=3)\n\nCommunity detection using the clique percolation algorithm. Communities are potentionally overlapping. Return a vector of vectors c such that c[i] is the set of vertices in community i.  The parameter k defines the size of the clique to use in percolation.\n\nReferences\n\nPalla G, Derenyi I, Farkas I J, et al.\n\nExamples\n\njulia> using Graphs\n\njulia> clique_percolation(clique_graph(3, 2))\n2-element Array{BitSet,1}:\n BitSet([4, 5, 6])\n BitSet([1, 2, 3])\n\njulia> clique_percolation(clique_graph(3, 2), k=2)\n1-element Array{BitSet,1}:\n BitSet([1, 2, 3, 4, 5, 6])\n\njulia> clique_percolation(clique_graph(3, 2), k=4)\n0-element Array{BitSet,1}\n\n\n\n\n\n","category":"function"},{"location":"algorithms/community/#Graphs.maximal_cliques","page":"Community structures","title":"Graphs.maximal_cliques","text":"maximal_cliques(g)\n\nReturn a vector of vectors representing the node indices in each of the maximal cliques found in the undirected graph g.\n\njulia> using Graphs\njulia> g = SimpleGraph(3)\njulia> add_edge!(g, 1, 2)\njulia> add_edge!(g, 2, 3)\njulia> maximal_cliques(g)\n2-element Array{Array{Int64,N},1}:\n [2,3]\n [2,1]\n\n\n\n\n\n","category":"function"},{"location":"algorithms/community/#Graphs.global_clustering_coefficient-Tuple{AbstractGraph}","page":"Community structures","title":"Graphs.global_clustering_coefficient","text":"global_clustering_coefficient(g)\n\nReturn the global clustering coefficient of graph g.\n\nExamples\n\njulia> using Graphs\n\njulia> global_clustering_coefficient(star_graph(4))\n0.0\n\njulia> global_clustering_coefficient(smallgraph(:housex))\n0.7894736842105263\n\n\n\n\n\n","category":"method"},{"location":"algorithms/community/#Graphs.local_clustering-Tuple{AbstractGraph, Integer}","page":"Community structures","title":"Graphs.local_clustering","text":"local_clustering(g, v)\nlocal_clustering(g, vs)\n\nReturn a tuple (a, b), where a is the number of triangles in the neighborhood of v and b is the maximum number of possible triangles. If a list of vertices vs is specified, return two vectors representing the number of triangles and the maximum number of possible triangles, respectively, for each node in the list.\n\nThis function is related to the local clustering coefficient r by r=fracab.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/community/#Graphs.local_clustering_coefficient-Tuple{AbstractGraph, Integer}","page":"Community structures","title":"Graphs.local_clustering_coefficient","text":"local_clustering_coefficient(g, v)\nlocal_clustering_coefficient(g, vs)\n\nReturn the local clustering coefficient for node v in graph g. If a list of vertices vs is specified, return a vector of coefficients for each node in the list.\n\nExamples\n\njulia> using Graphs\n\njulia> g = SimpleGraph(4);\n\njulia> add_edge!(g, 1, 2);\n\njulia> add_edge!(g, 2, 4);\n\njulia> add_edge!(g, 4, 1);\n\njulia> local_clustering_coefficient(g, [1, 2, 3])\n3-element Array{Float64,1}:\n 1.0\n 1.0\n 0.0\n\n\n\n\n\n","category":"method"},{"location":"algorithms/community/#Graphs.triangles-Tuple{AbstractGraph, Integer}","page":"Community structures","title":"Graphs.triangles","text":"triangles(g[, v])\ntriangles(g, vs)\n\nReturn the number of triangles in the neighborhood of node v in graph g. If a list of vertices vs is specified, return a vector of number of triangles for each node in the list. If no vertices are specified, return the number of triangles for each node in the graph.\n\nExamples\n\njulia> using Graphs\n\njulia> g = SimpleGraph(4);\n\njulia> add_edge!(g, 1, 2);\n\njulia> add_edge!(g, 2, 4);\n\njulia> add_edge!(g, 4, 1);\n\njulia> triangles(g)\n4-element Array{Int64,1}:\n 1\n 1\n 0\n 1\n\n\n\n\n\n","category":"method"},{"location":"algorithms/community/#Graphs.core_periphery_deg","page":"Community structures","title":"Graphs.core_periphery_deg","text":"core_periphery_deg(g)\n\nCompute the degree-based core-periphery for graph g. Return the vertex assignments (1 for core and 2 for periphery) for each node in g.\n\nReferences:     Lip)\n\nExamples\n\njulia> using Graphs\n\njulia> core_periphery_deg(star_graph(5))\n5-element Array{Int64,1}:\n 1\n 2\n 2\n 2\n 2\n\njulia> core_periphery_deg(path_graph(3))\n3-element Array{Int64,1}:\n 2\n 1\n 2\n\n\n\n\n\n","category":"function"},{"location":"algorithms/community/#Graphs.NeighComm","page":"Community structures","title":"Graphs.NeighComm","text":"NeighComm{T}\n\nType to record neighbor labels and their counts.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/community/#Graphs.label_propagation-Union{Tuple{AbstractGraph{T}}, Tuple{T}, Tuple{AbstractGraph{T}, Any}} where T","page":"Community structures","title":"Graphs.label_propagation","text":"label_propagation(g, maxiter=1000; rng=GLOBAL_RNG)\n\nCommunity detection using the label propagation algorithm. Return two vectors: the first is the label number assigned to each node, and the second is the convergence history for each node. Will return after maxiter iterations if convergence has not completed.\n\nReferences\n\nRaghavan et al.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/community/#Graphs.range_shuffle!-Tuple{Random.AbstractRNG, UnitRange, AbstractVector}","page":"Community structures","title":"Graphs.range_shuffle!","text":"range_shuffle!(rng, r, a)\n\nFast shuffle Array a in UnitRange r.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/community/#Graphs.vote!-Tuple{Random.AbstractRNG, AbstractGraph, Vector, Graphs.NeighComm, Integer}","page":"Community structures","title":"Graphs.vote!","text":"vote!(rng, g, m, c, u)\n\nReturn the label with greatest frequency.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/community/#Graphs.modularity-Tuple{AbstractGraph, AbstractVector{<:Integer}}","page":"Community structures","title":"Graphs.modularity","text":"modularity(g, c, distmx=weights(g), γ=1.0)\n\nReturn a value representing Newman's modularity Q for the undirected and  directed graph g given the partitioning vector c. This method also supports weighted graphs if the distance matrix is provided.\n\nModularity Q for undirected graph:\n\nQ = frac12m sum_c left( e_c - gamma fracK_c^22m right)\n\nModularity Q for directed graph:\n\nQ = frac1m sum_c left( e_c - gamma fracK_c^in K_c^outm right)\n\nwhere:\n\nm: total number of edges in the network \ne_c: number of edges in community c\nK_c: sum of the degrees of the nodes in community c or the  sum of the weighted degree of the nodes in community c when the graph is  weighted. K_c^in sum of the in-degrees of the nodes in community c.\n\nOptional Arguments\n\ndistmx=weights(g): distance matrix for weighted graphs\nγ=1.0: where γ > 0 is a resolution parameter. When the modularity is used  to find communities structure in networks (i.e with Louvain's method for  community detection),  higher resolutions lead to more communities, while lower resolutions lead to  fewer communities. Where γ=1.0 it lead to the traditional definition of  the modularity.\n\nReferences\n\nM. E. J. Newman and M. Girvan. \"Finding and evaluating community structure in networks\".  Phys. Rev. E 69, 026113 (2004). (arXiv)\nJ. Reichardt and S. Bornholdt. \"Statistical mechanics of community detection\".  Phys. Rev. E 74, 016110 (2006). (arXiv)\nE. A. Leicht and M. E. J. Newman. \"Community structure in directed networks\".  Physical Review Letter, 100:118703, (2008). (arXiv)\n\nExamples\n\njulia> using Graphs\n\njulia> barbell = blockdiag(complete_graph(3), complete_graph(3));\n\njulia> add_edge!(barbell, 1, 4);\n\njulia> modularity(barbell, [1, 1, 1, 2, 2, 2])\n0.35714285714285715\n\njulia> modularity(barbell, [1, 1, 1, 2, 2, 2], γ=0.5)\n0.6071428571428571  \n\njulia> using SimpleWeightedGraphs\n\njulia> triangle = SimpleWeightedGraph(3);\n\njulia> add_edge!(triangle, 1, 2, 1);\n\njulia> add_edge!(triangle, 2, 3, 1);\n\njulia> add_edge!(triangle, 3, 1, 1);\n\njulia> barbell = blockdiag(triangle, triangle);\n\njulia> add_edge!(barbell, 1, 4, 5); # this edge has a weight of 5\n\njulia> modularity(barbell, [1, 1, 1, 2, 2, 2])\n0.045454545454545456\n\n\n\n\n\n","category":"method"},{"location":"algorithms/community/#Graphs.rich_club-Union{Tuple{T}, Tuple{AbstractGraph{T}, Int64}} where T","page":"Community structures","title":"Graphs.rich_club","text":"rich_club(g, k)\n\nReturn the non-normalised rich-club coefficient of graph g, with degree cut-off k.\n\njulia> using LightGraphs\njulia> g = star_graph(5)\njulia> rich_club(g, 1)\n0.4\n\n\n\n\n\n","category":"method"},{"location":"advanced/errorhandling/#Error-handling","page":"Error handling","title":"Error handling","text":"","category":"section"},{"location":"advanced/errorhandling/","page":"Error handling","title":"Error handling","text":"In an ideal world, all software would work perfectly all the time. However, in the real world software encounters errors due to the outside world, bad input, bugs, or programmer error.","category":"page"},{"location":"advanced/errorhandling/#Types-of-errors","page":"Error handling","title":"Types of errors","text":"","category":"section"},{"location":"advanced/errorhandling/#Sentinel-values","page":"Error handling","title":"Sentinel values","text":"","category":"section"},{"location":"advanced/errorhandling/","page":"Error handling","title":"Error handling","text":"It is the position of this project that error conditions that happen often, typically due to bad data, should be handled with sentinel values returned to indicate the failure condition. These are used for functions such as add_edge!(g, u, v). If you try to add an edge with negative vertex numbers, or vertices that exceed the number of vertices in the graph, then you will get a return value of false.","category":"page"},{"location":"advanced/errorhandling/#Errors-/-exceptions","page":"Error handling","title":"Errors / exceptions","text":"","category":"section"},{"location":"advanced/errorhandling/","page":"Error handling","title":"Error handling","text":"For more severe failures such as bad arguments or failure to converge, we use exceptions. The primary distinction between Sentinel Values and Argument Errors has to do with the run time of the function being called. In a function that is expected to be a called in a tight loop such as add_edge!, we will use a sentinel value rather than an exception. This is because it is faster to do a simple if statement to handle the error than a full try/catch block. For functions that take longer to run, we use Exceptions. If you find an exception with an error message that isn't helpful for debugging, please file a bug report so that we can improve these messages.","category":"page"},{"location":"advanced/errorhandling/","page":"Error handling","title":"Error handling","text":"ArgumentError: the inputs to this function are not valid\nInexactError: some types are used that cannot express a computed quantity with the necessary precision","category":"page"},{"location":"core_functions/operators/#Operators","page":"Operators","title":"Operators","text":"","category":"section"},{"location":"core_functions/operators/","page":"Operators","title":"Operators","text":"Graphs.jl implements the following graph operators. In general, functions with two graph arguments will require them to be of the same type (either both SimpleGraph or both SimpleDiGraph).","category":"page"},{"location":"core_functions/operators/#Index","page":"Operators","title":"Index","text":"","category":"section"},{"location":"core_functions/operators/","page":"Operators","title":"Operators","text":"Pages = [\"operators.md\"]","category":"page"},{"location":"core_functions/operators/#Full-docs","page":"Operators","title":"Full docs","text":"","category":"section"},{"location":"core_functions/operators/","page":"Operators","title":"Operators","text":"Modules = [Graphs]\nPages = [\"operators.jl\"]\n","category":"page"},{"location":"core_functions/operators/#Base.getindex-Tuple{AbstractGraph, Any}","page":"Operators","title":"Base.getindex","text":"g[iter]\n\nReturn the subgraph induced by iter. Equivalent to induced_subgraph(g, iter)[1].\n\n\n\n\n\n","category":"method"},{"location":"core_functions/operators/#Base.intersect-Union{Tuple{T}, Tuple{T, T}} where T<:AbstractGraph","page":"Operators","title":"Base.intersect","text":"intersect(g, h)\n\nReturn a graph with edges that are only in both graph g and graph h.\n\nImplementation Notes\n\nThis function may produce a graph with 0-degree vertices. Preserves the eltype of the input graph.\n\nExamples\n\njulia> g1 = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);\n\njulia> g2 = SimpleDiGraph([0 1 0; 0 0 1; 1 0 0]);\n\njulia> foreach(println, edges(intersect(g1, g2)))\nEdge 1 => 2\nEdge 2 => 3\nEdge 3 => 1\n\n\n\n\n\n","category":"method"},{"location":"core_functions/operators/#Base.join-Union{Tuple{T}, Tuple{T, T}} where T<:AbstractGraph","page":"Operators","title":"Base.join","text":"join(g, h)\n\nReturn a graph that combines graphs g and h using blockdiag and then adds all the edges between the vertices in g and those in h.\n\nImplementation Notes\n\nPreserves the eltype of the input graph. Will error if the number of vertices in the generated graph exceeds the eltype.\n\nExamples\n\njulia> using Graphs\n\njulia> g = join(star_graph(3), path_graph(2))\n{5, 9} undirected simple Int64 graph\n\njulia> collect(edges(g))\n9-element Array{Graphs.SimpleGraphs.SimpleEdge{Int64},1}:\n Edge 1 => 2\n Edge 1 => 3\n Edge 1 => 4\n Edge 1 => 5\n Edge 2 => 4\n Edge 2 => 5\n Edge 3 => 4\n Edge 3 => 5\n Edge 4 => 5\n\n\n\n\n\n","category":"method"},{"location":"core_functions/operators/#Base.reverse","page":"Operators","title":"Base.reverse","text":"reverse(g)\n\nReturn a directed graph where all edges are reversed from the original directed graph.\n\nImplementation Notes\n\nPreserves the eltype of the input graph.\n\nExamples\n\njulia> g = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);\n\njulia> foreach(println, edges(reverse(g)))\nEdge 1 => 3\nEdge 2 => 1\nEdge 3 => 2\nEdge 4 => 3\nEdge 4 => 5\nEdge 5 => 4\n\n\n\n\n\n","category":"function"},{"location":"core_functions/operators/#Base.reverse!","page":"Operators","title":"Base.reverse!","text":"reverse!(g)\n\nIn-place reverse of a directed graph (modifies the original graph). See reverse for a non-modifying version.\n\n\n\n\n\n","category":"function"},{"location":"core_functions/operators/#Base.size-Tuple{SimpleGraph, Int64}","page":"Operators","title":"Base.size","text":"size(g, i)\n\nReturn the number of vertices in g if i=1 or i=2, or 1 otherwise.\n\nExamples\n\njulia> using Graphs\n\njulia> g = cycle_graph(4);\n\njulia> size(g, 1)\n4\n\njulia> size(g, 2)\n4\n\njulia> size(g, 3)\n1\n\n\n\n\n\n","category":"method"},{"location":"core_functions/operators/#Base.sum-Tuple{AbstractGraph, Int64}","page":"Operators","title":"Base.sum","text":"sum(g, i)\n\nReturn a vector of indegree (i=1) or outdegree (i=2) values for graph g.\n\nExamples\n\njulia> g = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);\n\njulia> sum(g, 2)\n5-element Array{Int64,1}:\n 1\n 1\n 2\n 1\n 1\n\njulia> sum(g, 1)\n5-element Array{Int64,1}:\n 1\n 1\n 1\n 2\n 1\n\n\n\n\n\n","category":"method"},{"location":"core_functions/operators/#Base.sum-Tuple{AbstractGraph}","page":"Operators","title":"Base.sum","text":"sum(g)\n\nReturn the number of edges in g.\n\nExamples\n\njulia> g = SimpleGraph([0 1 0; 1 0 1; 0 1 0]);\n\njulia> sum(g)\n2\n\n\n\n\n\n","category":"method"},{"location":"core_functions/operators/#Base.union-Union{Tuple{T}, Tuple{T, T}} where T<:Graphs.SimpleGraphs.AbstractSimpleGraph","page":"Operators","title":"Base.union","text":"union(g, h)\n\nReturn a graph that combines graphs g and h by taking the set union of all vertices and edges.\n\nImplementation Notes\n\nPreserves the eltype of the input graph. Will error if the number of vertices in the generated graph exceeds the eltype.\n\nExamples\n\njulia> using Graphs\n\njulia> g = SimpleGraph(3); h = SimpleGraph(5);\n\njulia> add_edge!(g, 1, 2);\n\njulia> add_edge!(g, 1, 3);\n\njulia> add_edge!(h, 3, 4);\n\njulia> add_edge!(h, 3, 5);\n\njulia> add_edge!(h, 4, 5);\n\njulia> f = union(g, h);\n\njulia> collect(edges(f))\n5-element Array{Graphs.SimpleGraphs.SimpleEdge{Int64},1}:\n Edge 1 => 2\n Edge 1 => 3\n Edge 3 => 4\n Edge 3 => 5\n Edge 4 => 5\n\n\n\n\n\n","category":"method"},{"location":"core_functions/operators/#Graphs.cartesian_product-Union{Tuple{G}, Tuple{G, G}} where G<:AbstractGraph","page":"Operators","title":"Graphs.cartesian_product","text":"cartesian_product(g, h)\n\nReturn the cartesian product of g and h.\n\nImplementation Notes\n\nPreserves the eltype of the input graph. Will error if the number of vertices in the generated graph exceeds the eltype.\n\nExamples\n\njulia> using Graphs\n\njulia> g = cartesian_product(star_graph(3), path_graph(3))\n{9, 12} undirected simple Int64 graph\n\njulia> collect(edges(g))\n12-element Array{Graphs.SimpleGraphs.SimpleEdge{Int64},1}:\n Edge 1 => 2\n Edge 1 => 4\n Edge 1 => 7\n Edge 2 => 3\n Edge 2 => 5\n Edge 2 => 8\n Edge 3 => 6\n Edge 3 => 9\n Edge 4 => 5\n Edge 5 => 6\n Edge 7 => 8\n Edge 8 => 9\n\n\n\n\n\n","category":"method"},{"location":"core_functions/operators/#Graphs.complement-Tuple{SimpleGraph}","page":"Operators","title":"Graphs.complement","text":"complement(g)\n\nReturn the graph complement of a graph\n\nImplementation Notes\n\nPreserves the eltype of the input graph.\n\nExamples\n\njulia> g = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);\n\njulia> foreach(println, edges(complement(g)))\nEdge 1 => 3\nEdge 1 => 4\nEdge 1 => 5\nEdge 2 => 1\nEdge 2 => 4\nEdge 2 => 5\nEdge 3 => 2\nEdge 3 => 5\nEdge 4 => 1\nEdge 4 => 2\nEdge 4 => 3\nEdge 5 => 1\nEdge 5 => 2\nEdge 5 => 3\n\n\n\n\n\n","category":"method"},{"location":"core_functions/operators/#Graphs.compute_shifts-Tuple{Integer, AbstractArray}","page":"Operators","title":"Graphs.compute_shifts","text":"compute_shifts(n::Int, x::AbstractArray)\n\nDetermine how many elements of x are less than i for all i in 1:n.\n\n\n\n\n\n","category":"method"},{"location":"core_functions/operators/#Graphs.crosspath","page":"Operators","title":"Graphs.crosspath","text":"crosspath(len::Integer, g::Graph)\n\nReturn a graph that duplicates g len times and connects each vertex with its copies in a path.\n\nImplementation Notes\n\nPreserves the eltype of the input graph. Will error if the number of vertices in the generated graph exceeds the eltype.\n\nExamples\n\njulia> using Graphs\n\njulia> g = crosspath(3, path_graph(3))\n{9, 12} undirected simple Int64 graph\n\njulia> collect(edges(g))\n12-element Array{Graphs.SimpleGraphs.SimpleEdge{Int64},1}:\n Edge 1 => 2\n Edge 1 => 4\n Edge 2 => 3\n Edge 2 => 5\n Edge 3 => 6\n Edge 4 => 5\n Edge 4 => 7\n Edge 5 => 6\n Edge 5 => 8\n Edge 6 => 9\n Edge 7 => 8\n Edge 8 => 9\n\n\n\n\n\n","category":"function"},{"location":"core_functions/operators/#Graphs.difference-Union{Tuple{T}, Tuple{T, T}} where T<:AbstractGraph","page":"Operators","title":"Graphs.difference","text":"difference(g, h)\n\nReturn a graph with edges in graph g that are not in graph h.\n\nImplementation Notes\n\nNote that this function may produce a graph with 0-degree vertices. Preserves the eltype of the input graph.\n\nExamples\n\njulia> g1 = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);\n\njulia> g2 = SimpleDiGraph([0 1 0; 0 0 1; 1 0 0]);\n\njulia> foreach(println, edges(difference(g1, g2)))\nEdge 3 => 4\nEdge 4 => 5\nEdge 5 => 4\n\n\n\n\n\n","category":"method"},{"location":"core_functions/operators/#Graphs.egonet-Union{Tuple{T}, Tuple{U}, Tuple{AbstractGraph{T}, Integer, Integer}, Tuple{AbstractGraph{T}, Integer, Integer, AbstractMatrix{U}}} where {U<:Real, T<:Integer}","page":"Operators","title":"Graphs.egonet","text":"egonet(g, v, d, distmx=weights(g))\n\nReturn the subgraph of g induced by the neighbors of v up to distance d, using weights (optionally) provided by distmx. This is equivalent to induced_subgraph(g, neighborhood(g, v, d, dir=dir))[1].\n\nOptional Arguments\n\ndir=:out: if g is directed, this argument specifies the edge direction\n\nwith respect to v (i.e. :in or :out).\n\n\n\n\n\n","category":"method"},{"location":"core_functions/operators/#Graphs.induced_subgraph-Union{Tuple{T}, Tuple{U}, Tuple{T, AbstractVector{U}}} where {U<:Integer, T<:AbstractGraph}","page":"Operators","title":"Graphs.induced_subgraph","text":"induced_subgraph(g, vlist)\ninduced_subgraph(g, elist)\n\nReturn the subgraph of g induced by the vertices in  vlist or edges in elist along with a vector mapping the new vertices to the old ones (the  vertex i in the subgraph corresponds to the vertex vmap[i] in g.)\n\nThe returned graph has length(vlist) vertices, with the new vertex i corresponding to the vertex of the original graph in the i-th position of vlist.\n\nUsage Examples\n\njulia> g = complete_graph(10)\n\njulia> sg, vmap = induced_subgraph(g, 5:8)\n\njulia> @assert g[5:8] == sg\n\njulia> @assert nv(sg) == 4\n\njulia> @assert ne(sg) == 6\n\njulia> @assert vm[4] == 8\n\njulia> sg, vmap = induced_subgraph(g, [2,8,3,4])\n\njulia> @assert sg == g[[2,8,3,4]]\n\njulia> elist = [Edge(1,2), Edge(3,4), Edge(4,8)]\n\njulia> sg, vmap = induced_subgraph(g, elist)\n\njulia> @assert sg == g[elist]\n\n\n\n\n\n","category":"method"},{"location":"core_functions/operators/#Graphs.merge_vertices!-Union{Tuple{T}, Tuple{SimpleGraph{T}, Vector{U} where U<:Integer}} where T","page":"Operators","title":"Graphs.merge_vertices!","text":"merge_vertices!(g, vs)\n\nCombine vertices specified in vs into single vertex whose index will be the lowest value in vs. All edges connected to vertices in vs connect to the new merged vertex.\n\nReturn a vector with new vertex values are indexed by the original vertex indices.\n\nImplementation Notes\n\nSupports SimpleGraph only.\n\nExamples\n\njulia> using Graphs\n\njulia> g = path_graph(5);\n\njulia> collect(edges(g))\n4-element Array{Graphs.SimpleGraphs.SimpleEdge{Int64},1}:\n Edge 1 => 2\n Edge 2 => 3\n Edge 3 => 4\n Edge 4 => 5\n\njulia> merge_vertices!(g, [2, 3])\n5-element Array{Int64,1}:\n 1\n 2\n 2\n 3\n 4\n\njulia> collect(edges(g))\n3-element Array{Graphs.SimpleGraphs.SimpleEdge{Int64},1}:\n Edge 1 => 2\n Edge 2 => 3\n Edge 3 => 4\n\n\n\n\n\n","category":"method"},{"location":"core_functions/operators/#Graphs.merge_vertices-Tuple{Graphs.SimpleGraphs.AbstractSimpleGraph, Any}","page":"Operators","title":"Graphs.merge_vertices","text":"merge_vertices(g::AbstractGraph, vs)\n\nCreate a new graph where all vertices in vs have been aliased to the same vertex minimum(vs).\n\nExamples\n\njulia> using Graphs\n\njulia> g = path_graph(5);\n\njulia> collect(edges(g))\n4-element Array{Graphs.SimpleGraphs.SimpleEdge{Int64},1}:\n Edge 1 => 2\n Edge 2 => 3\n Edge 3 => 4\n Edge 4 => 5\n\njulia> h = merge_vertices(g, [2, 3]);\n\njulia> collect(edges(h))\n3-element Array{Graphs.SimpleGraphs.SimpleEdge{Int64},1}:\n Edge 1 => 2\n Edge 2 => 3\n Edge 3 => 4\n\n\n\n\n\n","category":"method"},{"location":"core_functions/operators/#Graphs.symmetric_difference-Union{Tuple{T}, Tuple{T, T}} where T<:AbstractGraph","page":"Operators","title":"Graphs.symmetric_difference","text":"symmetric_difference(g, h)\n\nReturn a graph with edges from graph g that do not exist in graph h, and vice versa.\n\nImplementation Notes\n\nNote that this function may produce a graph with 0-degree vertices. Preserves the eltype of the input graph. Will error if the number of vertices in the generated graph exceeds the eltype.\n\nExamples\n\njulia> using Graphs\n\njulia> g = SimpleGraph(3); h = SimpleGraph(3);\n\njulia> add_edge!(g, 1, 2);\n\njulia> add_edge!(h, 1, 3);\n\njulia> add_edge!(h, 2, 3);\n\njulia> f = symmetric_difference(g, h);\n\njulia> collect(edges(f))\n3-element Array{Graphs.SimpleGraphs.SimpleEdge{Int64},1}:\n Edge 1 => 2\n Edge 1 => 3\n Edge 2 => 3\n\n\n\n\n\n","category":"method"},{"location":"core_functions/operators/#Graphs.tensor_product-Union{Tuple{G}, Tuple{G, G}} where G<:AbstractGraph","page":"Operators","title":"Graphs.tensor_product","text":"tensor_product(g, h)\n\nReturn the tensor product of g and h.\n\nImplementation Notes\n\nPreserves the eltype of the input graph. Will error if the number of vertices in the generated graph exceeds the eltype.\n\nExamples\n\njulia> using Graphs\n\njulia> g = tensor_product(star_graph(3), path_graph(3))\n{9, 8} undirected simple Int64 graph\n\njulia> collect(edges(g))\n8-element Array{Graphs.SimpleGraphs.SimpleEdge{Int64},1}:\n Edge 1 => 5\n Edge 1 => 8\n Edge 2 => 4\n Edge 2 => 6\n Edge 2 => 7\n Edge 2 => 9\n Edge 3 => 5\n Edge 3 => 8\n\n\n\n\n\n","category":"method"},{"location":"core_functions/operators/#SparseArrays.blockdiag-Union{Tuple{T}, Tuple{T, T}} where T<:AbstractGraph","page":"Operators","title":"SparseArrays.blockdiag","text":"blockdiag(g, h)\n\nReturn a graph with V(g) + V(h) vertices and E(g) + E(h) edges where the vertices and edges from graph h are appended to graph g.\n\nImplementation Notes\n\nPreserves the eltype of the input graph. Will error if the number of vertices in the generated graph exceeds the eltype.\n\nExamples\n\njulia> g1 = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);\n\njulia> g2 = SimpleDiGraph([0 1 0; 0 0 1; 1 0 0]);\n\njulia> blockdiag(g1, g2)\n{8, 9} directed simple Int64 graph\n\njulia> foreach(println, edges(blockdiag(g1, g2)))\nEdge 1 => 2\nEdge 2 => 3\nEdge 3 => 1\nEdge 3 => 4\nEdge 4 => 5\nEdge 5 => 4\nEdge 6 => 7\nEdge 7 => 8\nEdge 8 => 6\n\n\n\n\n\n","category":"method"},{"location":"core_functions/operators/#SparseArrays.sparse-Tuple{AbstractGraph}","page":"Operators","title":"SparseArrays.sparse","text":"sparse(g)\n\nReturn the default adjacency matrix of g.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/vertexcover/#Vertex-cover","page":"Vertex cover","title":"Vertex cover","text":"","category":"section"},{"location":"algorithms/vertexcover/","page":"Vertex cover","title":"Vertex cover","text":"Graphs.jl provides some algorithms to find vertex covers.","category":"page"},{"location":"algorithms/vertexcover/#Index","page":"Vertex cover","title":"Index","text":"","category":"section"},{"location":"algorithms/vertexcover/","page":"Vertex cover","title":"Vertex cover","text":"Pages = [\"vertexcover.md\"]","category":"page"},{"location":"algorithms/vertexcover/#Full-docs","page":"Vertex cover","title":"Full docs","text":"","category":"section"},{"location":"algorithms/vertexcover/","page":"Vertex cover","title":"Vertex cover","text":"Modules = [Graphs]\nPages = [\n    \"vertexcover/degree_vertex_cover.jl\",\n    \"vertexcover/random_vertex_cover.jl\",\n]\n","category":"page"},{"location":"algorithms/vertexcover/#Graphs.vertex_cover-Union{Tuple{T}, Tuple{AbstractGraph{T}, DegreeVertexCover}} where T<:Integer","page":"Vertex cover","title":"Graphs.vertex_cover","text":"vertex_cover(g, DegreeVertexCover())\n\nObtain a vertex cover using a greedy heuristic.\n\nImplementation Notes\n\nAn edge is said to be covered if it has at least one end-point in the vertex cover. Initialise the vertex cover to an empty set and iteratively choose the vertex with the most uncovered edges.\n\nPerformance\n\nRuntime: O((|V|+|E|)*log(|V|)) Memory: O(|V|)\n\nExamples\n\njulia> using Graphs\n\njulia> vertex_cover(path_graph(3), DegreeVertexCover())\n1-element Array{Int64,1}:\n 2\n\njulia> vertex_cover(cycle_graph(3), DegreeVertexCover())\n2-element Array{Int64,1}:\n 1\n 3\n\n\n\n\n\n","category":"method"},{"location":"algorithms/vertexcover/#Graphs.vertex_cover-Union{Tuple{T}, Tuple{AbstractGraph{T}, RandomVertexCover}} where T<:Integer","page":"Vertex cover","title":"Graphs.vertex_cover","text":"vertex_cover(g, RandomVertexCover(); seed=-1)\n\nFind a set of vertices such that every edge in g has some vertex in the set as  atleast one of its end point.\n\nImplementation Notes\n\nPerforms Approximate Minimum Vertex Cover once. Returns a vector of vertices representing the vertices in the Vertex Cover.\n\nPerformance\n\nRuntime: O(|V|+|E|) Memory: O(|E|) Approximation Factor: 2\n\nOptional Arguments\n\nIf seed >= 0, a random generator is seeded with this value.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/independentset/#Independent-sets","page":"Independent sets","title":"Independent sets","text":"","category":"section"},{"location":"algorithms/independentset/","page":"Independent sets","title":"Independent sets","text":"Graphs.jl contains functions related to independent sets.","category":"page"},{"location":"algorithms/independentset/#Index","page":"Independent sets","title":"Index","text":"","category":"section"},{"location":"algorithms/independentset/","page":"Independent sets","title":"Independent sets","text":"Pages = [\"independentset.md\"]","category":"page"},{"location":"algorithms/independentset/#Full-docs","page":"Independent sets","title":"Full docs","text":"","category":"section"},{"location":"algorithms/independentset/","page":"Independent sets","title":"Independent sets","text":"Modules = [Graphs]\nPages = [\n    \"independentset/degree_ind_set.jl\",\n    \"independentset/maximal_ind_set.jl\",\n]\n","category":"page"},{"location":"algorithms/independentset/#Graphs.independent_set-Union{Tuple{T}, Tuple{AbstractGraph{T}, DegreeIndependentSet}} where T<:Integer","page":"Independent sets","title":"Graphs.independent_set","text":"independent_set(g, DegreeIndependentSet())\n\nObtain an independent set of g using a greedy heuristic based on the degree of the vertices.\n\nImplementation Notes\n\nA vertex is said to be valid if it is not in the independent set or adjacent to any vertex in the independent set. Initilalise the independent set to an empty set and iteratively choose the vertex that is  adjacent to the fewest valid vertices in the independent set until all vertices are invalid.\n\nPerformance\n\nRuntime: O((|V|+|E|)*log(|V|)) Memory: O(|V|)\n\n\n\n\n\n","category":"method"},{"location":"algorithms/independentset/#Graphs.independent_set-Union{Tuple{T}, Tuple{AbstractGraph{T}, MaximalIndependentSet}} where T<:Integer","page":"Independent sets","title":"Graphs.independent_set","text":"independent_set(g, MaximalIndependentSet(); seed=-1)\n\nFind a random set of vertices that are independent (no two vertices are adjacent to each other) and  it is not possible to insert a vertex into the set without sacrificing the independence property.\n\nImplementation Notes\n\nPerforms Approximate Maximum Independent Set once. Returns a vector of vertices representing the vertices in the independent set.\n\nPerformance\n\nRuntime: O(|V|+|E|) Memory: O(|V|) Approximation Factor: maximum(degree(g))+1\n\nOptional Arguments\n\nIf seed >= 0, a random generator is seeded with this value.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/centrality/#Centrality-measures","page":"Centrality measures","title":"Centrality measures","text":"","category":"section"},{"location":"algorithms/centrality/","page":"Centrality measures","title":"Centrality measures","text":"Graphs.jl implements various centrality measures, which describe the importance of a vertex to the rest of the graph.","category":"page"},{"location":"algorithms/centrality/#Index","page":"Centrality measures","title":"Index","text":"","category":"section"},{"location":"algorithms/centrality/","page":"Centrality measures","title":"Centrality measures","text":"Pages   = [\"centrality.md\"]","category":"page"},{"location":"algorithms/centrality/#Full-docs","page":"Centrality measures","title":"Full docs","text":"","category":"section"},{"location":"algorithms/centrality/","page":"Centrality measures","title":"Centrality measures","text":"Modules = [Graphs]\nPages   = [\n    \"centrality/betweenness.jl\",\n    \"centrality/closeness.jl\",\n    \"centrality/degree.jl\",\n    \"centrality/eigenvector.jl\",\n    \"centrality/katz.jl\",\n    \"centrality/pagerank.jl\",\n    \"centrality/radiality.jl\",\n    \"centrality/stress.jl\",\n]\n","category":"page"},{"location":"algorithms/centrality/#Graphs.betweenness_centrality","page":"Centrality measures","title":"Graphs.betweenness_centrality","text":"betweenness_centrality(g[, vs])\nbetweenness_centrality(g, k)\n\nCalculate the betweenness centrality of a graph g across all vertices, a specified subset of vertices vs, or a random subset of k vertices. Return a vector representing the centrality calculated for each node in g.\n\nOptional Arguments\n\nnormalize=true: If true, normalize the betweenness values by the\n\ntotal number of possible distinct paths between all pairs in the graphs. For an undirected graph, this number is frac(V-1)(V-2)2 and for a directed graph, (V-1)(V-2).\n\nendpoints=false: If true, include endpoints in the shortest path count.\n\nBetweenness centrality is defined as: bc(v) = frac1mathcalN sum_s neq t neq v fracsigma_st(v)sigma_st.\n\nReferences\n\nBrandes 2001 & Brandes 2008\n\nExamples\n\njulia> using Graphs\n\njulia> betweenness_centrality(star_graph(3))\n3-element Array{Float64,1}:\n 1.0\n 0.0\n 0.0\n\njulia> betweenness_centrality(path_graph(4))\n4-element Array{Float64,1}:\n 0.0\n 0.6666666666666666\n 0.6666666666666666\n 0.0\n\n\n\n\n\n","category":"function"},{"location":"algorithms/centrality/#Graphs.closeness_centrality","page":"Centrality measures","title":"Graphs.closeness_centrality","text":"closeness_centrality(g, distmx=weights(g); normalize=true)\n\nCalculate the closeness centrality of the graph g. Return a vector representing the centrality calculated for each node in g.\n\nOptional Arguments\n\nnormalize=true: If true, normalize the centrality value of each\n\nnode n by fracδ_nV-1, where δ_n is the set of vertices reachable from node n.\n\nExamples\n\njulia> using Graphs\n\njulia> closeness_centrality(star_graph(5))\n5-element Array{Float64,1}:\n 1.0\n 0.5714285714285714\n 0.5714285714285714\n 0.5714285714285714\n 0.5714285714285714\n\njulia> closeness_centrality(path_graph(4))\n4-element Array{Float64,1}:\n 0.5\n 0.75\n 0.75\n 0.5\n\n\n\n\n\n","category":"function"},{"location":"algorithms/centrality/#Graphs.degree_centrality-Tuple{AbstractGraph}","page":"Centrality measures","title":"Graphs.degree_centrality","text":"degree_centrality(g)\nindegree_centrality(g)\noutdegree_centrality(g)\n\nCalculate the degree centrality of graph g. Return a vector representing the centrality calculated for each node in g.\n\nOptional Arguments\n\nnormalize=true: If true, normalize each centrality measure by frac1V-1.\n\nExamples\n\njulia> using Graphs\n\njulia> degree_centrality(star_graph(4))\n4-element Array{Float64,1}:\n 1.0               \n 0.3333333333333333\n 0.3333333333333333\n 0.3333333333333333\n\njulia> degree_centrality(path_graph(3))\n3-element Array{Float64,1}:\n 0.5\n 1.0\n 0.5\n\n\n\n\n\n","category":"method"},{"location":"algorithms/centrality/#Graphs.eigenvector_centrality-Tuple{AbstractGraph}","page":"Centrality measures","title":"Graphs.eigenvector_centrality","text":"eigenvector_centrality(g)\n\nCompute the eigenvector centrality for the graph g.\n\nEigenvector centrality computes the centrality for a node based on the centrality of its neighbors. The eigenvector centrality for node i is the i^th element of mathbfx in the equation mathbfAx = λ mathbfx where mathbfA is the adjacency matrix of the graph g  with eigenvalue λ.\n\nBy virtue of the Perron–Frobenius theorem, there is a unique and positive solution if λ is the largest eigenvalue associated with the eigenvector of the adjacency matrix mathbfA.\n\nReferences\n\nPhillip Bonacich: Power and Centrality: A Family of Measures.   American Journal of Sociology 92(5):1170–1182, 1986   http://www.leonidzhukov.net/hse/2014/socialnetworks/papers/Bonacich-Centrality.pdf\nMark E. J. Newman: Networks: An Introduction.      Oxford University Press, USA, 2010, pp. 169.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/centrality/#Graphs.katz_centrality","page":"Centrality measures","title":"Graphs.katz_centrality","text":"katz_centrality(g, α=0.3)\n\nCalculate the Katz centrality of the graph g optionally parameterized by α. Return a vector representing the centrality calculated for each node in g.\n\n\n\n\n\n","category":"function"},{"location":"algorithms/centrality/#Graphs.pagerank-Union{Tuple{AbstractGraph{U}}, Tuple{U}, Tuple{AbstractGraph{U}, Any}, Tuple{AbstractGraph{U}, Any, Integer}, Tuple{AbstractGraph{U}, Any, Integer, Any}} where U<:Integer","page":"Centrality measures","title":"Graphs.pagerank","text":"pagerank(g, α=0.85, n=100, ϵ=1.0e-6)\n\nCalculate the PageRank of the graph g parameterized by damping factor α, number of iterations  n, and convergence threshold ϵ. Return a vector representing the centrality calculated for each node in g, or an error if convergence is not reached within n iterations.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/centrality/#Graphs.radiality_centrality-Tuple{AbstractGraph}","page":"Centrality measures","title":"Graphs.radiality_centrality","text":"radiality_centrality(g)\n\nCalculate the radiality centrality of a graph g across all vertices. Return a vector representing the centrality calculated for each node in g.\n\nThe radiality centrality R_u of a vertex u is defined as R_u = fracD_g + 1 - fracsum_vVd_uvV-1D_g\n\nwhere D_g is the diameter of the graph and d_uv is the  length of the shortest path from u to v.\n\nReferences\n\nBrandes, U.: A faster algorithm for betweenness centrality. J Math Sociol 25 (2001) 163-177\n\nExamples\n\njulia> using Graphs\n\njulia> radiality_centrality(star_graph(4))\n4-element Array{Float64,1}:\n 1.0               \n 0.6666666666666666\n 0.6666666666666666\n 0.6666666666666666\n\njulia> radiality_centrality(path_graph(3))\n3-element Array{Float64,1}:\n 0.75\n 1.0 \n 0.75\n\n\n\n\n\n","category":"method"},{"location":"algorithms/centrality/#Graphs.stress_centrality","page":"Centrality measures","title":"Graphs.stress_centrality","text":"stress_centrality(g[, vs])\nstress_centrality(g, k)\n\nCalculate the stress centrality of a graph g across all vertices, a specified subset of vertices vs, or a random subset of k vertices. Return a vector representing the centrality calculated for each node in g.\n\nThe stress centrality of a vertex n is defined as the number of shortest paths passing through n.\n\nReferences\n\nBarabási, A.L., Oltvai, Z.N.: Network biology: understanding the cell's functional organization. Nat Rev Genet 5 (2004) 101-113\nShimbel, A.: Structural parameters of communication networks. Bull Math Biophys 15 (1953) 501-507.\n\nExamples\n\njulia> using Graphs\n\njulia> stress_centrality(star_graph(3))\n3-element Array{Int64,1}:\n 2\n 0\n 0\n\njulia> stress_centrality(cycle_graph(4))\n4-element Array{Int64,1}:\n 2\n 2\n 2\n 2\n\n\n\n\n\n","category":"function"},{"location":"core_functions/simplegraphs_generators/#Generators-for-common-graphs","page":"Generators for common graphs","title":"Generators for common graphs","text":"","category":"section"},{"location":"core_functions/simplegraphs_generators/","page":"Generators for common graphs","title":"Generators for common graphs","text":"Graphs.jl defines generators for various families of deterministic and random graphs.","category":"page"},{"location":"core_functions/simplegraphs_generators/#Index","page":"Generators for common graphs","title":"Index","text":"","category":"section"},{"location":"core_functions/simplegraphs_generators/","page":"Generators for common graphs","title":"Generators for common graphs","text":"Pages = [\"simplegraphs_generators.md\"]","category":"page"},{"location":"core_functions/simplegraphs_generators/#Full-docs","page":"Generators for common graphs","title":"Full docs","text":"","category":"section"},{"location":"core_functions/simplegraphs_generators/","page":"Generators for common graphs","title":"Generators for common graphs","text":"Modules = [Graphs.SimpleGraphs]\nPages = [\n    \"SimpleGraphs/generators/euclideangraphs.jl\",\n    \"SimpleGraphs/generators/randgraphs.jl\",\n    \"SimpleGraphs/generators/smallgraphs.jl\",\n    \"SimpleGraphs/generators/staticgraphs.jl\",\n]\n","category":"page"},{"location":"core_functions/simplegraphs_generators/#Graphs.SimpleGraphs.euclidean_graph-Tuple{Int64, Int64}","page":"Generators for common graphs","title":"Graphs.SimpleGraphs.euclidean_graph","text":"euclidean_graph(N, d; seed=-1, L=1., p=2., cutoff=-1., bc=:open)\n\nGenerate N uniformly distributed points in the box 0L^d and return a Euclidean graph, a map containing the distance on each edge and a matrix with the points' positions.\n\nExamples\n\njulia> g, dists = euclidean_graph(5, 2, cutoff=0.3);\n\njulia> g\n{5, 4} undirected simple Int64 graph\n\njulia> dists\nDict{Graphs.SimpleGraphs.SimpleEdge{Int64},Float64} with 4 entries:\n  Edge 1 => 5 => 0.205756\n  Edge 2 => 5 => 0.271359\n  Edge 2 => 4 => 0.247703\n  Edge 4 => 5 => 0.168372\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs_generators/#Graphs.SimpleGraphs.euclidean_graph-Tuple{Matrix}","page":"Generators for common graphs","title":"Graphs.SimpleGraphs.euclidean_graph","text":"euclidean_graph(points)\n\nGiven the d×N matrix points build an Euclidean graph of N vertices and return a graph and Dict containing the distance on each edge.\n\nOptional Arguments\n\nL=1: used to bound the d dimensional box from which points are selected.\np=2\nbc=:open\n\nImplementation Notes\n\nDefining the d-dimensional vectors x[i] = points[:,i], an edge between vertices i and j is inserted if norm(x[i]-x[j], p) < cutoff. In case of negative cutoff instead every edge is inserted. For p=2 we have the standard Euclidean distance. Set bc=:periodic to impose periodic boundary conditions in the box 0L^d.\n\nExamples\n\njulia> pts = rand(3, 10); # 10 vertices in R^3\n\njulia> g, dists = euclidean_graph(pts, p=1, bc=:periodic) # Taxicab-distance (L^1);\n\njulia> g\n{10, 45} undirected simple Int64 graph\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs_generators/#Graphs.SimpleGraphs.SimpleDiGraph-Union{Tuple{T}, Tuple{Integer, Integer}} where T<:Integer","page":"Generators for common graphs","title":"Graphs.SimpleGraphs.SimpleDiGraph","text":"SimpleDiGraph{T}(nv, ne; seed=-1)\n\nConstruct a random SimpleDiGraph{T} with nv vertices and ne edges. The graph is sampled uniformly from all such graphs. If seed >= 0, a random generator is seeded with this value. If not specified, the element type T is the type of nv.\n\nSee also\n\nerdos_renyi\n\nExamples\n\njulia> SimpleDiGraph(5, 7)\n{5, 7} directed simple Int64 graph\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs_generators/#Graphs.SimpleGraphs.SimpleGraph-Tuple{Integer, Integer, Channel}","page":"Generators for common graphs","title":"Graphs.SimpleGraphs.SimpleGraph","text":"SimpleGraph{T}(nv, ne, edgestream::Channel)\n\nConstruct a SimpleGraph{T} with nv vertices and ne edges from edgestream. Can result in less than ne edges if the channel edgestream is closed prematurely. Duplicate edges are only counted once. The element type is the type of nv.\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs_generators/#Graphs.SimpleGraphs.SimpleGraph-Tuple{Integer, Integer, StochasticBlockModel}","page":"Generators for common graphs","title":"Graphs.SimpleGraphs.SimpleGraph","text":"SimpleGraph{T}(nv, ne, smb::StochasticBlockModel)\n\nConstruct a random SimpleGraph{T} with nv vertices and ne edges. The graph is sampled according to the stochastic block model smb. The element type is the type of nv.\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs_generators/#Graphs.SimpleGraphs.SimpleGraph-Union{Tuple{T}, Tuple{Integer, Integer}} where T<:Integer","page":"Generators for common graphs","title":"Graphs.SimpleGraphs.SimpleGraph","text":"SimpleGraph{T}(nv, ne; seed=-1)\n\nConstruct a random SimpleGraph{T} with nv vertices and ne edges. The graph is sampled uniformly from all such graphs. If seed >= 0, a random generator is seeded with this value. If not specified, the element type T is the type of nv.\n\nSee also\n\nerdos_renyi\n\nExamples\n\njulia> SimpleGraph(5, 7)\n{5, 7} undirected simple Int64 graph\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs_generators/#Graphs.SimpleGraphs.StochasticBlockModel","page":"Generators for common graphs","title":"Graphs.SimpleGraphs.StochasticBlockModel","text":"StochasticBlockModel{T,P}\n\nA type capturing the parameters of the SBM. Each vertex is assigned to a block and the probability of edge (i,j) depends only on the block labels of vertex i and vertex j.\n\nThe assignement is stored in nodemap and the block affinities a k by k matrix is stored in affinities.\n\naffinities[k,l] is the probability of an edge between any vertex in block k and any vertex in block l.\n\nImplementation Notes\n\nGraphs are generated by taking random ij  V and flipping a coin with probability affinities[nodemap[i],nodemap[j]].\n\n\n\n\n\n","category":"type"},{"location":"core_functions/simplegraphs_generators/#Graphs.SimpleGraphs.barabasi_albert!-Tuple{AbstractGraph, Integer, Integer}","page":"Generators for common graphs","title":"Graphs.SimpleGraphs.barabasi_albert!","text":"barabasi_albert!(g::AbstractGraph, n::Integer, k::Integer)\n\nCreate a Barabási–Albert model random graph with n vertices. It is grown by adding new vertices to an initial graph g. Each new vertex is attached with k edges to k different vertices already present in the system by preferential attachment.\n\nOptional Arguments\n\nseed=-1: set the RNG seed.\n\nExamples\n\njulia> g = cycle_graph(4)\n{4, 4} undirected simple Int64 graph\n\njulia> barabasi_albert!(g, 16, 3);\n\njulia> g\n{16, 40} undirected simple Int64 graph\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs_generators/#Graphs.SimpleGraphs.barabasi_albert-Tuple{Integer, Integer, Integer}","page":"Generators for common graphs","title":"Graphs.SimpleGraphs.barabasi_albert","text":"barabasi_albert(n::Integer, n0::Integer, k::Integer)\n\nCreate a Barabási–Albert model random graph with n vertices. It is grown by adding new vertices to an initial graph with n0 vertices. Each new vertex is attached with k edges to k different vertices already present in the system by preferential attachment. Initial graphs are undirected and consist of isolated vertices by default.\n\nOptional Arguments\n\nis_directed=false: if true, return a directed graph.\ncomplete=false: if true, use a complete graph for the initial graph.\nseed=-1: set the RNG seed.\n\nExamples\n\njulia> barabasi_albert(10, 3, 2)\n{10, 14} undirected simple Int64 graph\n\njulia> barabasi_albert(100, Int8(10), 3, is_directed=true, seed=123)\n{100, 270} directed simple Int8 graph\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs_generators/#Graphs.SimpleGraphs.barabasi_albert-Tuple{Integer, Integer}","page":"Generators for common graphs","title":"Graphs.SimpleGraphs.barabasi_albert","text":"barabasi_albert(n, k)\n\nCreate a Barabási–Albert model random graph with n vertices. It is grown by adding new vertices to an initial graph with k vertices. Each new vertex is attached with k edges to k different vertices already present in the system by preferential attachment. Initial graphs are undirected and consist of isolated vertices by default.\n\nOptional Arguments\n\nis_directed=false: if true, return a directed graph.\ncomplete=false: if true, use a complete graph for the initial graph.\nseed=-1: set the RNG seed.\n\nExamples\n\njulia> barabasi_albert(50, 3)\n{50, 141} undirected simple Int64 graph\n\njulia> barabasi_albert(100, Int8(10), is_directed=true, complete=true, seed=123)\n{100, 990} directed simple Int8 graph\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs_generators/#Graphs.SimpleGraphs.blockcounts-Tuple{StochasticBlockModel, AbstractMatrix}","page":"Generators for common graphs","title":"Graphs.SimpleGraphs.blockcounts","text":"blockcounts(sbm, A)\n\nCount the number of edges that go between each block.\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs_generators/#Graphs.SimpleGraphs.dorogovtsev_mendes-Tuple{Integer}","page":"Generators for common graphs","title":"Graphs.SimpleGraphs.dorogovtsev_mendes","text":"dorogovtsev_mendes(n)\n\nGenerate a random n vertex graph by the Dorogovtsev-Mendes method (with n \\ge 3).\n\nThe Dorogovtsev-Mendes process begins with a triangle graph and inserts n-3 additional vertices. Each time a vertex is added, a random edge is selected and the new vertex is connected to the two endpoints of the chosen edge. This creates graphs with a many triangles and a high local clustering coefficient.\n\nIt is often useful to track the evolution of the graph as vertices are added, you can access the graph from the tth stage of this algorithm by accessing the first t vertices with g[1:t].\n\nReferences\n\nhttp://graphstream-project.org/doc/Generators/Dorogovtsev-Mendes-generator/\nhttps://arxiv.org/pdf/cond-mat/0106144.pdf#page=24\n\nExamples\n\njulia> dorogovtsev_mendes(10)\n{10, 17} undirected simple Int64 graph\n\njulia> dorogovtsev_mendes(11, seed=123)\n{11, 19} undirected simple Int64 graph\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs_generators/#Graphs.SimpleGraphs.erdos_renyi-Tuple{Integer, Integer}","page":"Generators for common graphs","title":"Graphs.SimpleGraphs.erdos_renyi","text":"erdos_renyi(n, ne)\n\nCreate an Erdős–Rényi random graph with n vertices and ne edges.\n\nOptional Arguments\n\nis_directed=false: if true, return a directed graph.\nseed=-1: set the RNG seed.\n\nExamples\n\njulia> erdos_renyi(10, 30)\n{10, 30} undirected simple Int64 graph\n\njulia> erdos_renyi(10, 30, is_directed=true, seed=123)\n{10, 30} directed simple Int64 graph\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs_generators/#Graphs.SimpleGraphs.erdos_renyi-Tuple{Integer, Real}","page":"Generators for common graphs","title":"Graphs.SimpleGraphs.erdos_renyi","text":"erdos_renyi(n, p)\n\nCreate an Erdős–Rényi random graph with n vertices. Edges are added between pairs of vertices with probability p.\n\nOptional Arguments\n\nis_directed=false: if true, return a directed graph.\nseed=-1: set the RNG seed.\n\nExamples\n\njulia> erdos_renyi(10, 0.5)\n{10, 20} undirected simple Int64 graph\n\njulia> erdos_renyi(10, 0.5, is_directed=true, seed=123)\n{10, 49} directed simple Int64 graph\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs_generators/#Graphs.SimpleGraphs.expected_degree_graph-Union{Tuple{Vector{T}}, Tuple{T}} where T<:Real","page":"Generators for common graphs","title":"Graphs.SimpleGraphs.expected_degree_graph","text":"expected_degree_graph(ω)\n\nGiven a vector of expected degrees ω indexed by vertex, create a random undirected graph in which vertices i and j are connected with probability ω[i]*ω[j]/sum(ω).\n\nOptional Arguments\n\nseed=-1: set the RNG seed.\n\nImplementation Notes\n\nThe algorithm should work well for maximum(ω) << sum(ω). As maximum(ω) approaches sum(ω), some deviations from the expected values are likely.\n\nReferences\n\nConnected Components in Random Graphs with Given Expected Degree Sequences, Linyuan Lu and Fan Chung. https://link.springer.com/article/10.1007%2FPL00012580\nEfficient Generation of Networks with Given Expected Degrees, Joel C. Miller and Aric Hagberg. https://doi.org/10.1007/978-3-642-21286-4_10\n\nExamples\n\n# 1)\njulia> g = expected_degree_graph([3, 1//2, 1//2, 1//2, 1//2])\n{5, 3} undirected simple Int64 graph\n\njulia> print(degree(g))\n[3, 0, 1, 1, 1]\n\n# 2)\njulia> g = expected_degree_graph([0.5, 0.5, 0.5], seed=123)\n{3, 1} undirected simple Int64 graph\n\njulia> print(degree(g))\n[1, 0, 1]\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs_generators/#Graphs.SimpleGraphs.kronecker","page":"Generators for common graphs","title":"Graphs.SimpleGraphs.kronecker","text":"kronecker(SCALE, edgefactor, A=0.57, B=0.19, C=0.19; seed=-1)\n\nGenerate a directed Kronecker graph with the default Graph500 parameters.\n\n\n\nReferences\n\nhttp://www.graph500.org/specifications#alg:generator\n\n\n\n\n\n","category":"function"},{"location":"core_functions/simplegraphs_generators/#Graphs.SimpleGraphs.make_edgestream","page":"Generators for common graphs","title":"Graphs.SimpleGraphs.make_edgestream","text":"make_edgestream(sbm)\n\nTake an infinite sample from the Stochastic Block Model sbm. Pass to Graph(nvg, neg, edgestream) to get a Graph object based on sbm.\n\n\n\n\n\n","category":"function"},{"location":"core_functions/simplegraphs_generators/#Graphs.SimpleGraphs.nearbipartiteaffinity-Union{Tuple{T}, Tuple{AbstractVector{T}, Real, Real}} where T<:Integer","page":"Generators for common graphs","title":"Graphs.SimpleGraphs.nearbipartiteaffinity","text":"nearbipartiteaffinity(sizes, between, intra)\n\nConstruct the affinity matrix for a near bipartite SBM. between is the affinity between the two parts of each bipartite community. intra is the probability of an edge within the parts of the partitions.\n\nThis is a specific type of SBM with `\\frac{k}{2} blocks each with two halves. Each half is connected as a random bipartite graph with probabilityintraThe blocks are connected with probabilitybetween`.\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs_generators/#Graphs.SimpleGraphs.randbn","page":"Generators for common graphs","title":"Graphs.SimpleGraphs.randbn","text":"randbn(n, p, seed=-1)\n\nReturn a binomally-distribted random number with parameters n and p and optional seed.\n\nReferences\n\n\"Non-Uniform Random Variate Generation,\" Luc Devroye, p. 522. Retrieved via http://www.eirene.de/Devroye.pdf.\nhttp://stackoverflow.com/questions/23561551/a-efficient-binomial-random-number-generator-code-in-java\n\n\n\n\n\n","category":"function"},{"location":"core_functions/simplegraphs_generators/#Graphs.SimpleGraphs.random_configuration_model-Union{Tuple{T}, Tuple{Integer, Array{T}}} where T<:Integer","page":"Generators for common graphs","title":"Graphs.SimpleGraphs.random_configuration_model","text":"random_configuration_model(n, ks)\n\nCreate a random undirected graph according to the configuration model containing n vertices, with each node i having degree k[i].\n\nOptional Arguments\n\nseed=-1: set the RNG seed.\ncheck_graphical=false: if true, ensure that k is a graphical sequence\n\n(see isgraphical).\n\nPerformance\n\nTime complexity is approximately mathcalO(n bark^2).\n\nImplementation Notes\n\nAllocates an array of n bark Ints.\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs_generators/#Graphs.SimpleGraphs.random_orientation_dag-Union{Tuple{SimpleGraph{T}}, Tuple{T}, Tuple{SimpleGraph{T}, Int64}} where T<:Integer","page":"Generators for common graphs","title":"Graphs.SimpleGraphs.random_orientation_dag","text":"random_orientation_dag(g)\n\nGenerate a random oriented acyclical digraph. The function takes in a simple graph and a random number generator as an argument. The probability of each directional acyclic graph randomly being generated depends on the architecture of the original directed graph.\n\nDAG's have a finite topological order; this order is randomly generated via \"order = randperm()\".\n\nExamples\n\njulia> random_orientation_dag(complete_graph(10))\n{10, 45} directed simple Int64 graph\n\njulia> random_orientation_dag(star_graph(Int8(10)), 123)\n{10, 9} directed simple Int8 graph\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs_generators/#Graphs.SimpleGraphs.random_pair-Tuple{Random.AbstractRNG, Integer}","page":"Generators for common graphs","title":"Graphs.SimpleGraphs.random_pair","text":"random_pair(rng, n)\n\nGenerate a stream of random pairs in 1:n using random number generator RNG.\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs_generators/#Graphs.SimpleGraphs.random_regular_digraph-Tuple{Integer, Integer}","page":"Generators for common graphs","title":"Graphs.SimpleGraphs.random_regular_digraph","text":"random_regular_digraph(n, k)\n\nCreate a random directed regular graph with n vertices, each with degree k.\n\nOptional Arguments\n\ndir=:out: the direction of the edges for degree parameter.\nseed=-1: set the RNG seed.\n\nImplementation Notes\n\nAllocates an n  n sparse matrix of boolean as an adjacency matrix and uses that to generate the directed graph.\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs_generators/#Graphs.SimpleGraphs.random_regular_graph-Tuple{Integer, Integer}","page":"Generators for common graphs","title":"Graphs.SimpleGraphs.random_regular_graph","text":"random_regular_graph(n, k)\n\nCreate a random undirected regular graph with n vertices, each with degree k.\n\nOptional Arguments\n\nseed=-1: set the RNG seed.\n\nPerformance\n\nTime complexity is approximately mathcalO(nk^2).\n\nImplementation Notes\n\nAllocates an array of nk Ints, and . For k  fracn2, generates a graph of degree n-k-1 and returns its complement.\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs_generators/#Graphs.SimpleGraphs.random_tournament_digraph-Tuple{Integer}","page":"Generators for common graphs","title":"Graphs.SimpleGraphs.random_tournament_digraph","text":"random_tournament_digraph(n)\n\nCreate a random directed tournament graph with n vertices.\n\nOptional Arguments\n\nseed=-1: set the RNG seed.\n\nExamples\n\njulia> random_tournament_digraph(5)\n{5, 10} directed simple Int64 graph\n\njulia> random_tournament_digraph(Int8(10), seed=123)\n{10, 45} directed simple Int8 graph\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs_generators/#Graphs.SimpleGraphs.sbmaffinity-Union{Tuple{T}, Tuple{U}, Tuple{Vector{T}, Real, Vector{U}}} where {U<:Integer, T<:Real}","page":"Generators for common graphs","title":"Graphs.SimpleGraphs.sbmaffinity","text":"sbmaffinity(internalp, externalp, sizes)\n\nProduce the sbm affinity matrix with internal probabilities internalp and external probabilities externalp.\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs_generators/#Graphs.SimpleGraphs.static_fitness_model-Union{Tuple{T}, Tuple{Integer, Vector{T}}} where T<:Real","page":"Generators for common graphs","title":"Graphs.SimpleGraphs.static_fitness_model","text":"static_fitness_model(m, fitness)\n\nGenerate a random graph with fitness vertices and m edges, in which the probability of the existence of Edge_ij is proportional to fitness_i  fitness_j.\n\nOptional Arguments\n\nseed=-1: set the RNG seed.\n\nPerformance\n\nTime complexity is mathcalO(V + E log E).\n\nReferences\n\nGoh K-I, Kahng B, Kim D: Universal behaviour of load distribution in scale-free networks. Phys Rev Lett 87(27):278701, 2001.\n\nExamples\n\njulia> g = static_fitness_model(5, [1, 1, 0.5, 0.1])\n{4, 5} undirected simple Int64 graph\n\njulia> edges(g) |> collect\n5-element Array{Graphs.SimpleGraphs.SimpleEdge{Int64},1}:\n Edge 1 => 2\n Edge 1 => 3\n Edge 1 => 4\n Edge 2 => 3\n Edge 2 => 4\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs_generators/#Graphs.SimpleGraphs.static_fitness_model-Union{Tuple{T}, Tuple{S}, Tuple{Integer, Vector{T}, Vector{S}}} where {S<:Real, T<:Real}","page":"Generators for common graphs","title":"Graphs.SimpleGraphs.static_fitness_model","text":"static_fitness_model(m, fitness_out, fitness_in)\n\nGenerate a random directed graph with fitness_out + fitness_in vertices and m edges, in which the probability of the existence of Edge_ij is proportional with respect to i  fitness_out and j  fitness_in.\n\nOptional Arguments\n\nseed=-1: set the RNG seed.\n\nPerformance\n\nTime complexity is mathcalO(V + E log E).\n\nReferences\n\nGoh K-I, Kahng B, Kim D: Universal behaviour of load distribution in scale-free networks. Phys Rev Lett 87(27):278701, 2001.\n\nExamples\n\njulia> g = static_fitness_model(6, [1, 0.2, 0.2, 0.2], [0.1, 0.1, 0.1, 0.9]; seed=123)\n{4, 6} directed simple Int64 graph\n\njulia> edges(g) |> collect\n6-element Array{Graphs.SimpleGraphs.SimpleEdge{Int64},1}:\n Edge 1 => 2\n Edge 1 => 3\n Edge 1 => 4\n Edge 2 => 3\n Edge 2 => 4\n Edge 3 => 4\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs_generators/#Graphs.SimpleGraphs.static_scale_free-Tuple{Integer, Integer, Real, Float64}","page":"Generators for common graphs","title":"Graphs.SimpleGraphs.static_scale_free","text":"static_scale_free(n, m, α_out, α_in)\n\nGenerate a random graph with n vertices, m edges and expected power-law degree distribution with exponent α_out for outbound edges and α_in for inbound edges.\n\nOptional Arguments\n\nseed=-1: set the RNG seed.\nfinite_size_correction=true: determines whether to use the finite size correction\n\nproposed by Cho et al.\n\nPerformance\n\nTime complexity is mathcalO(V + E log E).\n\nReferences\n\nGoh K-I, Kahng B, Kim D: Universal behaviour of load distribution in scale-free networks. Phys Rev Lett 87(27):278701, 2001.\nChung F and Lu L: Connected components in a random graph with given degree sequences. Annals of Combinatorics 6, 125-145, 2002.\nCho YS, Kim JS, Park J, Kahng B, Kim D: Percolation transitions in scale-free networks under the Achlioptas process. Phys Rev Lett 103:135702, 2009.\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs_generators/#Graphs.SimpleGraphs.static_scale_free-Tuple{Integer, Integer, Real}","page":"Generators for common graphs","title":"Graphs.SimpleGraphs.static_scale_free","text":"static_scale_free(n, m, α)\n\nGenerate a random graph with n vertices, m edges and expected power-law degree distribution with exponent α.\n\nOptional Arguments\n\nseed=-1: set the RNG seed.\nfinite_size_correction=true: determines whether to use the finite size correction\n\nproposed by Cho et al.\n\nPerformance\n\nTime complexity is mathcalO(V + E log E).\n\nReferences\n\nGoh K-I, Kahng B, Kim D: Universal behaviour of load distribution in scale-free networks. Phys Rev Lett 87(27):278701, 2001.\nChung F and Lu L: Connected components in a random graph with given degree sequences. Annals of Combinatorics 6, 125-145, 2002.\nCho YS, Kim JS, Park J, Kahng B, Kim D: Percolation transitions in scale-free networks under the Achlioptas process. Phys Rev Lett 103:135702, 2009.\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs_generators/#Graphs.SimpleGraphs.stochastic_block_model-Union{Tuple{T}, Tuple{U}, Tuple{Matrix{T}, Vector{U}}} where {U<:Integer, T<:Real}","page":"Generators for common graphs","title":"Graphs.SimpleGraphs.stochastic_block_model","text":"stochastic_block_model(c, n)\n\nReturn a Graph generated according to the Stochastic Block Model (SBM).\n\nc[a,b] : Mean number of neighbors of a vertex in block a belonging to block b.            Only the upper triangular part is considered, since the lower traingular is            determined by cba = cab * fracnanb. n[a] : Number of vertices in block a\n\nOptional Arguments\n\nseed=-1: set the RNG seed.\n\nFor a dynamic version of the SBM see the StochasticBlockModel type and related functions.\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs_generators/#Graphs.SimpleGraphs.stochastic_block_model-Union{Tuple{T}, Tuple{U}, Tuple{T, T, Vector{U}}} where {U<:Integer, T<:Real}","page":"Generators for common graphs","title":"Graphs.SimpleGraphs.stochastic_block_model","text":"stochastic_block_model(cint, cext, n)\n\nReturn a Graph generated according to the Stochastic Block Model (SBM), sampling from an SBM with c_aa=cint, and c_ab=cext.\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs_generators/#Graphs.SimpleGraphs.watts_strogatz-Tuple{Integer, Integer, Real}","page":"Generators for common graphs","title":"Graphs.SimpleGraphs.watts_strogatz","text":"watts_strogatz(n, k, β)\n\nReturn a Watts-Strogatz small world random graph with n vertices, each with expected degree k  (or k - 1 if k is odd). Edges are randomized per the model based on probability β.\n\nThe algorithm proceeds as follows. First, a perfect 1-lattice is constructed, where each vertex has exacly div(k, 2) neighbors on each side (i.e., k or k - 1 in total). Then the following steps are repeated for a hop length i of 1 through div(k, 2).\n\nConsider each vertex s in turn, along with the edge to its ith nearest neighbor t, in a clockwise sense.\nGenerate a uniformly random number r. If r ≥ β, then the edge (s, t) is left unaltered. Otherwise, the edge is deleted and rewired so that s is connected to some vertex d, chosen uniformly at random from the entire graph, excluding s and its neighbors. (Note that t is a valid candidate.)\n\nFor β = 1, the graph will remain a 1-lattice, and for β = 0, all edges will be rewired randomly.\n\nOptional Arguments\n\nis_directed=false: if true, return a directed graph.\nseed=-1: set the RNG seed.\n\nExamples\n\njulia> watts_strogatz(10, 4, 0.3)\n{10, 20} undirected simple Int64 graph\n\njulia> watts_strogatz(Int8(10), 4, 0.8, is_directed=true, seed=123)\n{10, 20} directed simple Int8 graph\n\nReferences\n\nCollective dynamics of ‘small-world’ networks, Duncan J. Watts, Steven H. Strogatz. https://doi.org/10.1038/30918\nSmall Worlds, Duncan J. watts. https://en.wikipedia.org/wiki/Special:BookSources?isbn=978-0691005416\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs_generators/#Graphs.SimpleGraphs.smallgraph-Tuple{Symbol}","page":"Generators for common graphs","title":"Graphs.SimpleGraphs.smallgraph","text":"smallgraph(s)\nsmallgraph(s)\n\nCreate a small graph of type s. Admissible values for s are:\n\ns graph type\n:bull A bull graph.\n:chvatal A Chvátal graph.\n:cubical A Platonic cubical graph.\n:desargues A Desarguesgraph.\n:diamond A diamond graph.\n:dodecahedral A Platonic dodecahedral  graph.\n:frucht A Frucht graph.\n:heawood A Heawood graph.\n:house A graph mimicing the classic outline of a house.\n:housex A house graph, with two edges crossing the bottom square.\n:icosahedral A Platonic icosahedral   graph.\n:karate A social network graph called Zachary's karate club.\n:krackhardtkite A Krackhardt-Kite social network  graph.\n:moebiuskantor A Möbius-Kantor graph.\n:octahedral A Platonic octahedral graph.\n:pappus A Pappus graph.\n:petersen A Petersen graph.\n:sedgewickmaze A simple maze graph used in Sedgewick's Algorithms in C++: Graph  Algorithms (3rd ed.)\n:tetrahedral A Platonic tetrahedral  graph.\n:truncatedcube A skeleton of the truncated cube graph.\n:truncatedtetrahedron A skeleton of the truncated tetrahedron  graph.\n:truncatedtetrahedron_dir A skeleton of the truncated tetrahedron digraph.\n:tutte A Tutte graph.\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs_generators/#Graphs.SimpleGraphs.barbell_graph-Union{Tuple{T}, Tuple{T, T}} where T<:Integer","page":"Generators for common graphs","title":"Graphs.SimpleGraphs.barbell_graph","text":"barbell_graph(n1, n2)\n\nCreate a barbell graph consisting of a clique of size n1 connected by an edge to a clique of size n2.\n\nImplementation Notes\n\nPreserves the eltype of n1 and n2. Will error if the required number of vertices exceeds the eltype. n1 and n2 must be at least 1 so that both cliques are non-empty. The cliques are organized with nodes 1:n1 being the left clique and n1+1:n1+n2 being the right clique. The cliques are connected by and edge (n1, n1+1).\n\nExamples\n\njulia> barbell_graph(3, 4)\n{7, 10} undirected simple Int64 graph\n\njulia> barbell_graph(Int8(5), Int8(5))\n{10, 21} undirected simple Int8 graph\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs_generators/#Graphs.SimpleGraphs.binary_tree-Tuple{T} where T<:Integer","page":"Generators for common graphs","title":"Graphs.SimpleGraphs.binary_tree","text":"binary_tree(k::Integer)\n\nCreate a binary tree of depth k.\n\nExamples\n\njulia> binary_tree(4)\n{15, 14} undirected simple Int64 graph\n\njulia> binary_tree(Int8(5))\n{31, 30} undirected simple Int8 graph\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs_generators/#Graphs.SimpleGraphs.circular_ladder_graph-Tuple{Integer}","page":"Generators for common graphs","title":"Graphs.SimpleGraphs.circular_ladder_graph","text":"circular_ladder_graph(n)\n\nCreate a circular ladder graph consisting of 2n nodes and 3n edges. This is also known as the prism graph.\n\nImplementation Notes\n\nPreserves the eltype of the partitions vector. Will error if the required number of vertices exceeds the eltype. n must be at least 3 to avoid self-loops and multi-edges.\n\nExamples\n\njulia> circular_ladder_graph(3)\n{6, 9} undirected simple Int64 graph\n\njulia> circular_ladder_graph(Int8(4))\n{8, 12} undirected simple Int8 graph\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs_generators/#Graphs.SimpleGraphs.clique_graph-Union{Tuple{T}, Tuple{T, T}} where T<:Integer","page":"Generators for common graphs","title":"Graphs.SimpleGraphs.clique_graph","text":"clique_graph(k, n)\n\nCreate a graph consisting of n connected k-cliques.\n\nExamples\n\njulia> clique_graph(4, 10)\n{40, 70} undirected simple Int64 graph\n\njulia> clique_graph(Int8(10), Int8(4))\n{40, 184} undirected simple Int8 graph\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs_generators/#Graphs.SimpleGraphs.complete_bipartite_graph-Union{Tuple{T}, Tuple{T, T}} where T<:Integer","page":"Generators for common graphs","title":"Graphs.SimpleGraphs.complete_bipartite_graph","text":"complete_bipartite_graph(n1, n2)\n\nCreate an undirected complete bipartite graph with n1 + n2 vertices.\n\nExamples\n\njulia> complete_bipartite_graph(3, 4)\n{7, 12} undirected simple Int64 graph\n\njulia> complete_bipartite_graph(Int8(3), Int8(4))\n{7, 12} undirected simple Int8 graph\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs_generators/#Graphs.SimpleGraphs.complete_digraph-Tuple{T} where T<:Integer","page":"Generators for common graphs","title":"Graphs.SimpleGraphs.complete_digraph","text":"complete_digraph(n)\n\nCreate a directed complete graph with n vertices.\n\nExamples\n\njulia> complete_digraph(5)\n{5, 20} directed simple Int64 graph\n\njulia> complete_digraph(Int8(6))\n{6, 30} directed simple Int8 graph\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs_generators/#Graphs.SimpleGraphs.complete_graph-Tuple{T} where T<:Integer","page":"Generators for common graphs","title":"Graphs.SimpleGraphs.complete_graph","text":"complete_graph(n)\n\nCreate an undirected complete graph with n vertices.\n\nExamples\n\njulia> complete_graph(5)\n{5, 10} undirected simple Int64 graph\n\njulia> complete_graph(Int8(6))\n{6, 15} undirected simple Int8 graph\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs_generators/#Graphs.SimpleGraphs.complete_multipartite_graph-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T<:Integer","page":"Generators for common graphs","title":"Graphs.SimpleGraphs.complete_multipartite_graph","text":"complete_multipartite_graph(partitions)\n\nCreate an undirected complete bipartite graph with sum(partitions) vertices. A partition with 0 vertices is skipped.\n\nImplementation Notes\n\nPreserves the eltype of the partitions vector. Will error if the required number of vertices exceeds the eltype.\n\nExamples\n\njulia> complete_multipartite_graph([1,2,3])\n{6, 11} undirected simple Int64 graph\n\njulia> complete_multipartite_graph(Int8[5,5,5])\n{15, 75} undirected simple Int8 graph\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs_generators/#Graphs.SimpleGraphs.cycle_digraph-Tuple{T} where T<:Integer","page":"Generators for common graphs","title":"Graphs.SimpleGraphs.cycle_digraph","text":"cycle_digraph(n)\n\nCreate a directed cycle graph with n vertices.\n\nExamples\n\njulia> cycle_digraph(3)\n{3, 3} directed simple Int64 graph\n\njulia> cycle_digraph(Int8(5))\n{5, 5} directed simple Int8 graph\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs_generators/#Graphs.SimpleGraphs.cycle_graph-Tuple{T} where T<:Integer","page":"Generators for common graphs","title":"Graphs.SimpleGraphs.cycle_graph","text":"cycle_graph(n)\n\nCreate an undirected cycle graph with n vertices.\n\nExamples\n\njulia> cycle_graph(3)\n{3, 3} undirected simple Int64 graph\n\njulia> cycle_graph(Int8(5))\n{5, 5} undirected simple Int8 graph\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs_generators/#Graphs.SimpleGraphs.double_binary_tree-Tuple{Integer}","page":"Generators for common graphs","title":"Graphs.SimpleGraphs.double_binary_tree","text":"double_binary_tree(k::Integer)\n\nCreate a double complete binary tree with k levels.\n\nReferences\n\nUsed as an example for spectral clustering by Guattery and Miller 1998.\n\nExamples\n\njulia> double_binary_tree(4)\n{30, 29} undirected simple Int64 graph\n\njulia> double_binary_tree(Int8(5))\n{62, 61} undirected simple Int8 graph\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs_generators/#Graphs.SimpleGraphs.grid-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T<:Integer","page":"Generators for common graphs","title":"Graphs.SimpleGraphs.grid","text":"grid(dims; periodic=false)\n\nCreate a dims-dimensional cubic lattice, with length dims[i] in dimension i.\n\nOptional Arguments\n\nperiodic=false: If true, the resulting lattice will have periodic boundary\n\ncondition in each dimension.\n\nExamples\n\njulia> grid([2,3])\n{6, 7} undirected simple Int64 graph\n\njulia> grid(Int8[2, 2, 2], periodic=true)\n{8, 12} undirected simple Int8 graph\n\njulia> grid((2,3))\n{6, 7} undirected simple Int64 graph\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs_generators/#Graphs.SimpleGraphs.ladder_graph-Tuple{T} where T<:Integer","page":"Generators for common graphs","title":"Graphs.SimpleGraphs.ladder_graph","text":"ladder_graph(n)\n\nCreate a ladder graph consisting of 2n nodes and 3n-2 edges.\n\nImplementation Notes\n\nPreserves the eltype of n. Will error if the required number of vertices exceeds the eltype.\n\nExamples\n\njulia> ladder_graph(3)\n{6, 7} undirected simple Int64 graph\n\njulia> ladder_graph(Int8(4))\n{8, 10} undirected simple Int8 graph\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs_generators/#Graphs.SimpleGraphs.lollipop_graph-Union{Tuple{T}, Tuple{T, T}} where T<:Integer","page":"Generators for common graphs","title":"Graphs.SimpleGraphs.lollipop_graph","text":"lollipop_graph(n1, n2)\n\nCreate a lollipop graph consisting of a clique of size n1 connected by an edge to a path of size n2.\n\nImplementation Notes\n\nPreserves the eltype of n1 and n2. Will error if the required number of vertices exceeds the eltype. n1 and n2 must be at least 1 so that both the clique and the path have at least one vertex. The graph is organized with nodes 1:n1 being the clique and n1+1:n1+n2 being the path. The clique is connected to the path by an edge (n1, n1+1).\n\nExamples\n\njulia> lollipop_graph(2, 5)\n{7, 6} undirected simple Int64 graph\n\njulia> lollipop_graph(Int8(3), Int8(4))\n{7, 7} undirected simple Int8 graph\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs_generators/#Graphs.SimpleGraphs.path_digraph-Tuple{T} where T<:Integer","page":"Generators for common graphs","title":"Graphs.SimpleGraphs.path_digraph","text":"path_digraph(n)\n\nCreates a directed path graph with n vertices.\n\nExamples\n\njulia> path_digraph(5)\n{5, 4} directed simple Int64 graph\n\njulia> path_digraph(Int8(10))\n{10, 9} directed simple Int8 graph\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs_generators/#Graphs.SimpleGraphs.path_graph-Tuple{T} where T<:Integer","page":"Generators for common graphs","title":"Graphs.SimpleGraphs.path_graph","text":"path_graph(n)\n\nCreate an undirected path graph with n vertices.\n\nExamples\n\njulia> path_graph(5)\n{5, 4} undirected simple Int64 graph\n\njulia> path_graph(Int8(10))\n{10, 9} undirected simple Int8 graph\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs_generators/#Graphs.SimpleGraphs.roach_graph-Tuple{Integer}","page":"Generators for common graphs","title":"Graphs.SimpleGraphs.roach_graph","text":"roach_graph(k)\n\nCreate a Roach graph of size k.\n\nReferences\n\nGuattery and Miller 1998\n\nExamples\n\njulia> roach_graph(10)\n{40, 48} undirected simple Int64 graph\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs_generators/#Graphs.SimpleGraphs.star_digraph-Tuple{T} where T<:Integer","page":"Generators for common graphs","title":"Graphs.SimpleGraphs.star_digraph","text":"star_digraph(n)\n\nCreate a directed star graph with n vertices.\n\nExamples\n\njulia> star_digraph(3)\n{3, 2} directed simple Int64 graph\n\njulia> star_digraph(Int8(10))\n{10, 9} directed simple Int8 graph\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs_generators/#Graphs.SimpleGraphs.star_graph-Tuple{T} where T<:Integer","page":"Generators for common graphs","title":"Graphs.SimpleGraphs.star_graph","text":"star_graph(n)\n\nCreate an undirected star graph with n vertices.\n\nExamples\n\njulia> star_graph(3)\n{3, 2} undirected simple Int64 graph\n\njulia> star_graph(Int8(10))\n{10, 9} undirected simple Int8 graph\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs_generators/#Graphs.SimpleGraphs.turan_graph-Tuple{Integer, Integer}","page":"Generators for common graphs","title":"Graphs.SimpleGraphs.turan_graph","text":"turan_graph(n, r)\n\nCreates a Turán Graph, a complete multipartite graph with n vertices and r partitions.\n\nExamples\n\njulia> turan_graph(6, 2)\n{6, 9} undirected simple Int64 graph\n\njulia> turan_graph(Int8(7), 2)\n{7, 12} undirected simple Int8 graph\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs_generators/#Graphs.SimpleGraphs.wheel_digraph-Tuple{T} where T<:Integer","page":"Generators for common graphs","title":"Graphs.SimpleGraphs.wheel_digraph","text":"wheel_digraph(n)\n\nCreate a directed wheel graph with n vertices.\n\nExamples\n\njulia> wheel_digraph(5)\n{5, 8} directed simple Int64 graph\n\njulia> wheel_digraph(Int8(6))\n{6, 10} directed simple Int8 graph\n\n\n\n\n\n","category":"method"},{"location":"core_functions/simplegraphs_generators/#Graphs.SimpleGraphs.wheel_graph-Tuple{T} where T<:Integer","page":"Generators for common graphs","title":"Graphs.SimpleGraphs.wheel_graph","text":"wheel_graph(n)\n\nCreate an undirected wheel graph with n vertices.\n\nExamples\n\njulia> wheel_graph(5)\n{5, 8} undirected simple Int64 graph\n\njulia> wheel_graph(Int8(6))\n{6, 10} undirected simple Int8 graph\n\n\n\n\n\n","category":"method"},{"location":"algorithms/digraph/#Directed-graphs","page":"Directed graphs","title":"Directed graphs","text":"","category":"section"},{"location":"algorithms/digraph/","page":"Directed graphs","title":"Directed graphs","text":"Graphs.jl includes some algorithms that are specific to directed graphs.","category":"page"},{"location":"algorithms/digraph/#Index","page":"Directed graphs","title":"Index","text":"","category":"section"},{"location":"algorithms/digraph/","page":"Directed graphs","title":"Directed graphs","text":"Pages = [\"digraph.md\"]","category":"page"},{"location":"algorithms/digraph/#Full-docs","page":"Directed graphs","title":"Full docs","text":"","category":"section"},{"location":"algorithms/digraph/","page":"Directed graphs","title":"Directed graphs","text":"Modules = [Graphs]\nPages = [\n    \"digraph/transitivity.jl\",\n]\n","category":"page"},{"location":"algorithms/digraph/#Graphs.transitiveclosure","page":"Directed graphs","title":"Graphs.transitiveclosure","text":"transitiveclosure(g, selflooped=false)\n\nCompute the transitive closure of a directed graph, using DFS. Return a graph representing the transitive closure. If selflooped is true, add self loops to the graph.\n\nPerformance\n\nTime complexity is mathcalO(EV).\n\nExamples\n\njulia> using Graphs\n\njulia> barbell = blockdiag(complete_digraph(3), complete_digraph(3));\n\njulia> add_edge!(barbell, 1, 4);\n\njulia> collect(edges(barbell))\n13-element Array{Graphs.SimpleGraphs.SimpleEdge{Int64},1}:\n Edge 1 => 2\n Edge 1 => 3\n Edge 1 => 4\n Edge 2 => 1\n Edge 2 => 3\n Edge 3 => 1\n Edge 3 => 2\n Edge 4 => 5\n Edge 4 => 6\n Edge 5 => 4\n Edge 5 => 6\n Edge 6 => 4\n Edge 6 => 5\n\njulia> collect(edges(transitiveclosure(barbell)))\n21-element Array{Graphs.SimpleGraphs.SimpleEdge{Int64},1}:\n Edge 1 => 2\n Edge 1 => 3\n Edge 1 => 4\n Edge 1 => 5\n Edge 1 => 6\n Edge 2 => 1\n Edge 2 => 3\n Edge 2 => 4\n Edge 2 => 5\n Edge 2 => 6\n Edge 3 => 1\n Edge 3 => 2\n Edge 3 => 4\n Edge 3 => 5\n Edge 3 => 6\n Edge 4 => 5\n Edge 4 => 6\n Edge 5 => 4\n Edge 5 => 6\n Edge 6 => 4\n Edge 6 => 5\n\n\n\n\n\n","category":"function"},{"location":"algorithms/digraph/#Graphs.transitiveclosure!","page":"Directed graphs","title":"Graphs.transitiveclosure!","text":"transitiveclosure!(g, selflooped=false)\n\nCompute the transitive closure of a directed graph, using DFS. If selflooped is true, add self loops to the graph.\n\nPerformance\n\nTime complexity is mathcalO(EV).\n\nImplementation Notes\n\nThis version of the function modifies the original graph.\n\n\n\n\n\n","category":"function"},{"location":"algorithms/digraph/#Graphs.transitivereducion","page":"Directed graphs","title":"Graphs.transitivereducion","text":"transitivereduction(g; selflooped=false)\n\nCompute the transitive reduction of  a directed graph. If the graph contains cycles, each strongly connected component is replaced by a directed cycle and the transitive reduction is calculated on the condensation graph connecting the components. If selflooped is true, self loops on strongly connected components of size one will be preserved.\n\nPerformance\n\nTime complexity is mathcalO(VE).\n\nExamples\n\njulia> using Graphs\n\njulia> barbell = blockdiag(complete_digraph(3), complete_digraph(3));\n\njulia> add_edge!(barbell, 1, 4);\n\njulia> collect(edges(barbell))\n13-element Array{Graphs.SimpleGraphs.SimpleEdge{Int64},1}:\n Edge 1 => 2\n Edge 1 => 3\n Edge 1 => 4\n Edge 2 => 1\n Edge 2 => 3\n Edge 3 => 1\n Edge 3 => 2\n Edge 4 => 5\n Edge 4 => 6\n Edge 5 => 4\n Edge 5 => 6\n Edge 6 => 4\n Edge 6 => 5\n\njulia> collect(edges(transitivereduction(barbell)))\n7-element Array{Graphs.SimpleGraphs.SimpleEdge{Int64},1}:\n Edge 1 => 2\n Edge 1 => 4\n Edge 2 => 3\n Edge 3 => 1\n Edge 4 => 5\n Edge 5 => 6\n Edge 6 => 4\n\n\n\n\n\n","category":"function"},{"location":"algorithms/distance/#Distance","page":"Distance","title":"Distance","text":"","category":"section"},{"location":"algorithms/distance/","page":"Distance","title":"Distance","text":"Graphs.jl includes several distance measurements.","category":"page"},{"location":"algorithms/distance/#Index","page":"Distance","title":"Index","text":"","category":"section"},{"location":"algorithms/distance/","page":"Distance","title":"Distance","text":"Pages = [\"distance.md\"]","category":"page"},{"location":"algorithms/distance/#Full-docs","page":"Distance","title":"Full docs","text":"","category":"section"},{"location":"algorithms/distance/","page":"Distance","title":"Distance","text":"Modules = [Graphs]\nPages   = [\"distance.jl\"]\n","category":"page"},{"location":"algorithms/distance/#Graphs.DefaultDistance","page":"Distance","title":"Graphs.DefaultDistance","text":"DefaultDistance\n\nAn array-like structure that provides distance values of 1 for any src, dst combination.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/distance/#Graphs.center-Tuple{Vector}","page":"Distance","title":"Graphs.center","text":"center(eccentricities)\ncenter(g, distmx=weights(g))\n\nGiven a graph and optional distance matrix, or a vector of precomputed eccentricities, return the set of all vertices whose eccentricity is equal to the graph's radius (that is, the set of vertices with the smallest eccentricity).\n\nExamples\n\njulia> using Graphs\n\njulia> center(star_graph(5))\n1-element Array{Int64,1}:\n 1\n\njulia> center(path_graph(5))\n1-element Array{Int64,1}:\n 3\n\n\n\n\n\n","category":"method"},{"location":"algorithms/distance/#Graphs.diameter-Tuple{Vector}","page":"Distance","title":"Graphs.diameter","text":"diameter(eccentricities)\ndiameter(g, distmx=weights(g))\n\nGiven a graph and optional distance matrix, or a vector of precomputed eccentricities, return the maximum eccentricity of the graph.\n\nExamples\n\njulia> using Graphs\n\njulia> diameter(star_graph(5))\n2\n\njulia> diameter(path_graph(5))\n4\n\n\n\n\n\n","category":"method"},{"location":"algorithms/distance/#Graphs.eccentricity-Union{Tuple{T}, Tuple{AbstractGraph, Integer}, Tuple{AbstractGraph, Integer, AbstractMatrix{T}}} where T<:Real","page":"Distance","title":"Graphs.eccentricity","text":"eccentricity(g[, v][, distmx])\neccentricity(g[, vs][, distmx])\n\nReturn the eccentricity[ies] of a vertex / vertex list v or a set of vertices vs defaulting to the entire graph. An optional matrix of edge distances may be supplied; if missing, edge distances default to 1.\n\nThe eccentricity of a vertex is the maximum shortest-path distance between it and all other vertices in the graph.\n\nThe output is either a single float (when a single vertex is provided) or a vector of floats corresponding to the vertex vector. If no vertex vector is provided, the vector returned corresponds to each vertex in the graph.\n\nPerformance\n\nBecause this function must calculate shortest paths for all vertices supplied in the argument list, it may take a long time.\n\nImplementation Notes\n\nThe eccentricity vector returned by eccentricity() may be used as input for the rest of the distance measures below. If an eccentricity vector is provided, it will be used. Otherwise, an eccentricity vector will be calculated for each call to the function. It may therefore be more efficient to calculate, store, and pass the eccentricities if multiple distance measures are desired.\n\nAn infinite path length is represented by the typemax of the distance matrix.\n\nExamples\n\njulia> g = SimpleGraph([0 1 0; 1 0 1; 0 1 0]);\n\njulia> eccentricity(g, 1)\n2\n\njulia> eccentricity(g, [1; 2])\n2-element Array{Int64,1}:\n 2\n 1\n\njulia> eccentricity(g, [1; 2], [0 2 0; 0.5 0 0.5; 0 2 0])\n2-element Array{Float64,1}:\n 2.5\n 0.5\n\n\n\n\n\n","category":"method"},{"location":"algorithms/distance/#Graphs.periphery-Tuple{Vector}","page":"Distance","title":"Graphs.periphery","text":"periphery(eccentricities)\nperiphery(g, distmx=weights(g))\n\nGiven a graph and optional distance matrix, or a vector of precomputed eccentricities, return the set of all vertices whose eccentricity is equal to the graph's diameter (that is, the set of vertices with the largest eccentricity).\n\nExamples\n\njulia> using Graphs\n\njulia> periphery(star_graph(5))\n4-element Array{Int64,1}:\n 2\n 3\n 4\n 5\n\njulia> periphery(path_graph(5))\n2-element Array{Int64,1}:\n 1\n 5\n\n\n\n\n\n","category":"method"},{"location":"algorithms/distance/#Graphs.radius-Tuple{Vector}","page":"Distance","title":"Graphs.radius","text":"radius(eccentricities)\nradius(g, distmx=weights(g))\n\nGiven a graph and optional distance matrix, or a vector of precomputed eccentricities, return the minimum eccentricity of the graph.\n\nExamples\n\njulia> using Graphs\n\njulia> radius(star_graph(5))\n1\n\njulia> radius(path_graph(5))\n2\n\n\n\n\n\n","category":"method"},{"location":"advanced/experimental/#Experimental-algorithms","page":"Experimental algorithms","title":"Experimental algorithms","text":"","category":"section"},{"location":"advanced/experimental/","page":"Experimental algorithms","title":"Experimental algorithms","text":"Graphs.Experimental is a module for graph algorithms that are newer or less stable. We can adopt algorithms before we finalize an interface for using them or if we feel that full support cannot be provided to the current implementation. You can expect new developments to land here before they make it into the main module. This enables the development to keep advancing without being risk-averse because of stability guarantees. You can think of this module as a 0.X semantic version space ; it is a place where you can play around with new algorithms, perspectives, and interfaces without fear of breaking critical code.","category":"page"},{"location":"advanced/experimental/","page":"Experimental algorithms","title":"Experimental algorithms","text":"A Note To Users","category":"page"},{"location":"advanced/experimental/","page":"Experimental algorithms","title":"Experimental algorithms","text":"Code in this module is unstable and subject to change. Do not use any code in this module in production environments without understanding the (large) risks involved. However, we welcome bug reports and issues via the normal channels..","category":"page"},{"location":"advanced/experimental/#Index","page":"Experimental algorithms","title":"Index","text":"","category":"section"},{"location":"advanced/experimental/","page":"Experimental algorithms","title":"Experimental algorithms","text":"Pages = [\"experimental.md\"]","category":"page"},{"location":"advanced/experimental/#Full-docs","page":"Experimental algorithms","title":"Full docs","text":"","category":"section"},{"location":"advanced/experimental/","page":"Experimental algorithms","title":"Experimental algorithms","text":"Modules = [Graphs.Experimental, Graphs.Experimental.Traversals, Graphs.Experimental.ShortestPaths, Graphs.Experimental.Parallel]\nPages = [\n    \"Experimental/Experimental.jl\",\n    \"Experimental/isomorphism.jl\",\n    \"Experimental/vf2.jl\",\n    \"Experimental/Parallel/traversals/gdistances.jl\",\n    \"Experimental/Parallel/Parallel.jl\",\n    \"Experimental/ShortestPaths/astar.jl\",\n    \"Experimental/ShortestPaths/bellman-ford.jl\",\n    \"Experimental/ShortestPaths/bfs.jl\",\n    \"Experimental/ShortestPaths/desopo-pape.jl\",\n    \"Experimental/ShortestPaths/dijkstra.jl\",\n    \"Experimental/ShortestPaths/floyd-warshall.jl\",\n    \"Experimental/ShortestPaths/johnson.jl\",\n    \"Experimental/ShortestPaths/ShortestPaths.jl\",\n    \"Experimental/ShortestPaths/spfa.jl\",\n    \"Experimental/Traversals/bfs.jl\",\n    \"Experimental/Traversals/dfs.jl\",\n    \"Experimental/Traversals/Traversals.jl\",\n]\n","category":"page"},{"location":"advanced/experimental/#Graphs.Experimental.IsomorphismAlgorithm","page":"Experimental algorithms","title":"Graphs.Experimental.IsomorphismAlgorithm","text":"IsomorphismAlgorithm\n\nAn abstract type used for method dispatch on isomorphism functions.\n\n\n\n\n\n","category":"type"},{"location":"advanced/experimental/#Graphs.Experimental.all_induced_subgraphisomorph","page":"Experimental algorithms","title":"Graphs.Experimental.all_induced_subgraphisomorph","text":"all_induced_subgraphisomorph(g1, g2, alg::IsomorphismAlgorithm=VF2(); vertex_relation=nothing, edge_relation=nothing)\n\nReturn all isomorphism from vertex induced subgraphs of g1 to g2. The isomorphisms are returned as an iterator of vectors of tuples, where the i-th vector is  the i-th isomorphism and a tuple (u, v) in this vector means that u ∈ g1 is mapped to v ∈ g2.\n\nOptional Arguments\n\nalg: The algorithm that is used to find the induced subgraph isomorphism. Can be only   VF2() at the moment.\nvertex_relation: A binary function that takes a vertex from g1 and one from g2. An   isomorphism only exists if this function returns true for all matched vertices.\nedge_relation: A binary function that takes an edge from g1 and one from g2. An   isomorphism only exists if this function returns true for all matched edges.\n\nExamples\n\njulia> all_induced_subgraphisomorph(path_graph(3), SimpleGraph(2)) |> collect\n2-element Array{Array{Tuple{Int64,Int64},1},1}:\n [(1, 1), (3, 2)]\n [(3, 1), (1, 2)]\n\njulia> g1 = path_digraph(3); color1 = [1, 1, 2]\njulia> g2 = path_digraph(2); color2 = [1, 2]\njulia> color_rel(u, v) = (color1[u] == color2[v])\njulia> all_induced_subgraphisomorph(g1, g2) |> collect\n2-element Array{Array{Tuple{Int64,Int64},1},1}:\n [(1, 1), (2, 2)]\n [(2, 1), (3, 2)]\njulia> all_induced_subgraphisomorph(g1, g2, vertex_relation=color_rel) |> collect\n1-element Array{Array{Tuple{Int64,Int64},1},1}:\n [(1, 1), (2, 2)]\n\nSee also\n\nall_subgraphisomorph, all_isomorph, has_induced_subgraphisomorph, count_induced_subgraphisomorph\n\n\n\n\n\n","category":"function"},{"location":"advanced/experimental/#Graphs.Experimental.all_isomorph","page":"Experimental algorithms","title":"Graphs.Experimental.all_isomorph","text":"all_isomorph(g1, g2, alg::IsomorphismAlgorithm=VF2(); vertex_relation=nothing, edge_relation=nothing)\n\nReturn all isomorphism from g1 to g2. The isomorphisms are returned as an iterator of vectors of tuples, where the i-th vector is  the i-th isomorphism and a tuple (u, v) in this vector means that u ∈ g1 is mapped to v ∈ g2.\n\nOptional Arguments\n\nalg: The algorithm that is used to find the induced subgraph isomorphism. Can be only   VF2() at the moment.\nvertex_relation: A binary function that takes a vertex from g1 and one from g2. An   isomorphism only exists if this function returns true for all matched vertices.\nedge_relation: A binary function that takes an edge from g1 and one from g2. An   isomorphism only exists if this function returns true for all matched edges.\n\nExamples\n\njulia> all_isomorph(star_graph(4), star_graph(4)) |> collect\n6-element Array{Array{Tuple{Int64,Int64},1},1}:\n [(1, 1), (2, 2), (3, 3), (4, 4)]\n [(1, 1), (2, 2), (4, 3), (3, 4)]\n [(1, 1), (3, 2), (2, 3), (4, 4)]\n [(1, 1), (3, 2), (4, 3), (2, 4)]\n [(1, 1), (4, 2), (2, 3), (3, 4)]\n [(1, 1), (4, 2), (3, 3), (2, 4)]\n \njulia> g1 = cycle_digraph(3); color1 = [1, 1, 2]\njulia> g2 = cycle_digraph(3); color2 = [2, 1, 1]\njulia> color_rel(u, v) = (color1[u] == color2[v])\njulia> all_isomorph(g1, g2) |> collect\n3-element Array{Array{Tuple{Int64,Int64},1},1}:\n [(1, 1), (2, 2), (3, 3)]\n [(2, 1), (3, 2), (1, 3)]\n [(3, 1), (1, 2), (2, 3)]\njulia> all_subgraphisomorph(g1, g2, vertex_relation=color_rel)\n1-element Array{Array{Tuple{Int64,Int64},1},1}:\n [(3, 1), (1, 2), (2, 3)]\n\nSee also\n\nall_induced_subgraphisomorph, all_subgraphisomorph, has_isomorph, count_isomorph\n\n\n\n\n\n","category":"function"},{"location":"advanced/experimental/#Graphs.Experimental.all_subgraphisomorph","page":"Experimental algorithms","title":"Graphs.Experimental.all_subgraphisomorph","text":"all_subgraphisomorph(g1, g2, alg::IsomorphismAlgorithm=VF2(); vertex_relation=nothing, edge_relation=nothing)\n\nReturn all isomorphism from  subgraphs of g1 to g2. The isomorphisms are returned as an iterator of vectors of tuples, where the i-th vector is  the i-th isomorphism and a tuple (u, v) in this vector means that u ∈ g1 is mapped to v ∈ g2.\n\nOptional Arguments\n\nalg: The algorithm that is used to find the induced subgraph isomorphism. Can be only   VF2() at the moment.\nvertex_relation: A binary function that takes a vertex from g1 and one from g2. An   isomorphism only exists if this function returns true for all matched vertices.\nedge_relation: A binary function that takes an edge from g1 and one from g2. An   isomorphism only exists if this function returns true for all matched edges.\n\nExamples\n\njulia> all_subgraphisomorph(path_graph(3), path_graph(2)) |> collect\n4-element Array{Array{Tuple{Int64,Int64},1},1}:\n [(1, 1), (2, 2)]\n [(2, 1), (1, 2)]\n [(2, 1), (3, 2)]\n [(3, 1), (2, 2)]\n\njulia> g1 = path_digraph(3); color1 = [1, 1, 2]\njulia> g2 = path_digraph(2); color2 = [1, 2]\njulia> color_rel(u, v) = (color1[u] == color2[v])\njulia> all_subgraphisomorph(g1, g2) |> collect\n2-element Array{Array{Tuple{Int64,Int64},1},1}:\n [(1, 1), (2, 2)]\n [(2, 1), (3, 2)]\njulia> all_subgraphisomorph(g1, g2, vertex_relation=color_rel)\n1-element Array{Array{Tuple{Int64,Int64},1},1}:\n [(2, 1), (3, 2)]\n\nSee also\n\nall_induced_subgraphisomorph, all_isomorph, has_subgraphisomorph, count_subgraphisomorph\n\n\n\n\n\n","category":"function"},{"location":"advanced/experimental/#Graphs.Experimental.could_have_isomorph-Tuple{AbstractGraph, AbstractGraph}","page":"Experimental algorithms","title":"Graphs.Experimental.could_have_isomorph","text":"could_have_isomorph(g1, g2)\n\nRun quick test to check if g1 andg2` could be isomorphic.\n\nIf the result is false, then g1 and g2 are definitely not isomorphic, but if the result is true this is not guaranteed.\n\nExamples\n\njulia> using Graphs\n\njulia> Graphs.Experimental.could_have_isomorph(path_graph(3), star_graph(4))\nfalse\n\njulia> Graphs.Experimental.could_have_isomorph(path_graph(3), star_graph(3))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"advanced/experimental/#Graphs.Experimental.count_induced_subgraphisomorph","page":"Experimental algorithms","title":"Graphs.Experimental.count_induced_subgraphisomorph","text":"count_induced_subgraphisomorph(g1, g2, alg::IsomorphismAlgorithm=VF2(); vertex_relation=nothing, edge_relation=nothing)\n\nReturn the number of vertex induced subgraphs of the graph g1 that are isomorphic to g2.\n\nOptional Arguments\n\nvertex_relation: A binary function that takes a vertex from g1 and one from g2. An   isomorphism only exists if this function returns true for all matched vertices.\nedge_relation: A binary function that takes an edge from g1 and one from g2. An   isomorphism only exists if this function returns true for all matched edges.\n\nExamples\n\njulia> count_induced_subgraphisomorph(complete_graph(5), complete_graph(4))\n120\njulia> count_induced_subgraphisomorph(complete_graph(5), cycle_graph(4))\n0\n\njulia> g1 = path_graph(3); color1 = [1, 1, 2]\njulia> g2 = path_graph(2); color2 = [1, 2]\njulia> color_rel(u, v) = (color1[u] == color2[v])\njulia> count_induced_subgraphisomorph(g1, g2)\n2\njulia> count_induced_subgraphisomorph(g1, g2, vertex_relation=color_rel)\n1\n\nSee also\n\ncount_subgraphisomorph, count_isomorph, has_induced_subgraphisomorph, all_induced_subgraphisomorph\n\n\n\n\n\n","category":"function"},{"location":"advanced/experimental/#Graphs.Experimental.count_isomorph","page":"Experimental algorithms","title":"Graphs.Experimental.count_isomorph","text":"count_isomorph(g1, g2, alg::IsomorphismAlgorithm=VF2(); vertex_relation=nothing, edge_relation=nothing)\n\nReturn the number of isomorphism from graph g1 to g2.\n\nOptional Arguments\n\nalg: The algorithm that is used to find the induced subgraph isomorphism. Can be only   VF2() at the moment.\nvertex_relation: A binary function that takes a vertex from g1 and one from g2. An   isomorphism only exists if this function returns true for all matched vertices.\nedge_relation: A binary function that takes an edge from g1 and one from g2. An   isomorphism only exists if this function returns true for all matched edges.\n\nExamples\n\njulia> count_isomorph(cycle_graph(5), cycle_graph(5))\n10\njulia> count_isomorph(complete_graph(5), cycle_graph(5))\n0\n\njulia> g1 = cycle_digraph(3); color1 = [1, 1, 2]\njulia> g2 = cycle_digraph(3); color2 = [1, 1, 1]\njulia> color_rel(u, v) = (color1[u] == color2[v])\njulia> count_isomorph(g1, g2)\n3\njulia> count_isomorph(g1, g2, vertex_relation=color_rel)\n0\n\nSee also\n\ncount_induced_subgraphisomorph, count_subgraphisomorph, has_isomorph, all_isomorph\n\n\n\n\n\n","category":"function"},{"location":"advanced/experimental/#Graphs.Experimental.count_subgraphisomorph","page":"Experimental algorithms","title":"Graphs.Experimental.count_subgraphisomorph","text":"count_subgraphisomorph(g1, g2, alg::IsomorphismAlgorithm=VF2(); vertex_relation=nothing, edge_relation=nothing)\n\nReturn the number of subgraphs of the graph g1 that are isomorphic to g2.\n\nOptional Arguments\n\nalg: The algorithm that is used to find the induced subgraph isomorphism. Can be only   VF2() at the moment.\nvertex_relation: A binary function that takes a vertex from g1 and one from g2. An   isomorphism only exists if this function returns true for all matched vertices.\nedge_relation: A binary function that takes an edge from g1 and one from g2. An   isomorphism only exists if this function returns true for all matched edges.\n\nExamples\n\njulia> count_subgraphisomorph(complete_graph(5), complete_graph(4))\n120\njulia> count_subgraphisomorph(complete_graph(5), cycle_graph(4))\n120\n\njulia> g1 = cycle_digraph(3); color1 = [1, 1, 2]\njulia> g2 = SimpleDiGraph(2); color2 = [1, 2]\njulia> color_rel(u, v) = (color1[u] == color2[v])\njulia> count_subgraphisomorph(g1, g2)\n6\njulia> count_subgraphisomorph(g1, g2, vertex_relation=color_rel)\n2\n\nSee also\n\ncount_induced_subgraphisomorph, count_isomorph, has_subgraphisomorph, all_subgraphisomorph\n\n\n\n\n\n","category":"function"},{"location":"advanced/experimental/#Graphs.Experimental.has_induced_subgraphisomorph","page":"Experimental algorithms","title":"Graphs.Experimental.has_induced_subgraphisomorph","text":"has_induced_subgraphisomorph(g1, g2, alg::IsomorphismAlgorithm=VF2(); vertex_relation=nothing, edge_relation=nothing)\n\nReturn true if the graph g1 contains a vertex induced subgraph that is isomorphic to g2.\n\nOptional Arguments\n\nalg: The algorithm that is used to find the induced subgraph isomorphism. Can be only   VF2() at the moment.\nvertex_relation: A binary function that takes a vertex from g1 and one from g2. An   isomorphism only exists if this function returns true for all matched vertices.\nedge_relation: A binary function that takes an edge from g1 and one from g2. An   isomorphism only exists if this function returns true for all matched edges.\n\nExamples\n\njulia> has_induced_subgraphisomorph(complete_graph(5), complete_graph(4))\ntrue\njulia> has_induced_subgraphisomorph(complete_graph(5), cycle_graph(4))\nfalse\n\njulia> g1 = path_digraph(3); color1 = [1, 1, 1]\njulia> g2 = path_digraph(2); color2 = [1, 2]\njulia> color_rel(u, v) = (color1[u] == color2[v])\njulia> has_induced_subgraphisomorph(g1, g2)\ntrue\njulia> has_induced_subgraphisomorph(g1, g2, vertex_relation=color_rel)\nfalse\n\nSee also\n\nhas_subgraphisomorph, has_isomorph, count_induced_subgraphisomorph, all_induced_subgraphisomorph\n\n\n\n\n\n","category":"function"},{"location":"advanced/experimental/#Graphs.Experimental.has_isomorph","page":"Experimental algorithms","title":"Graphs.Experimental.has_isomorph","text":"has_isomorph(g1, g2, alg::IsomorphismAlgorithm=VF2(); vertex_relation=nothing, edge_relation=nothing)\n\nReturn true if the graph g1 is isomorphic to g2.\n\nOptional Arguments\n\nalg: The algorithm that is used to find the induced subgraph isomorphism. Can be only   VF2() at the moment.\nvertex_relation: A binary function that takes a vertex from g1 and one from g2. An   isomorphism only exists if this function returns true for all matched vertices.\nedge_relation: A binary function that takes an edge from g1 and one from g2. An   isomorphism only exists if this function returns true for all matched edges.\n\nExamples\n\njulia> has_isomorph(complete_graph(3), cycle_graph(3))\ntrue\njulia> has_isomorph(complete_graph(4), cycle_graph(4))\nfalse\n\njulia> g1 = path_digraph(4); color1 = [1, 2, 1, 1]\njulia> g2 = path_digraph(4); color2 = [1, 2, 2, 1]\njulia> color_rel(u, v) = (color1[u] == color2[v])\njulia> has_isomorph(g1, g2)\ntrue\njulia> has_isomorph(g1, g2, vertex_relation=color_rel)\nfalse\n\nSee also\n\nhas_induced_subgraphisomorph, has_subgraphisomorph, count_subgraphisomorph, all_subgraphisomorph\n\n\n\n\n\n","category":"function"},{"location":"advanced/experimental/#Graphs.Experimental.has_subgraphisomorph","page":"Experimental algorithms","title":"Graphs.Experimental.has_subgraphisomorph","text":"has_subgraphisomorph(g1, g2, alg::IsomorphismAlgorithm=VF2(); vertex_relation=nothing, edge_relation=nothing)\n\nReturn true if the graph g1 contains a subgraph that is isomorphic to g2.\n\nOptional Arguments\n\nalg: The algorithm that is used to find the induced subgraph isomorphism. Can be only   VF2() at the moment.\nvertex_relation: A binary function that takes a vertex from g1 and one from g2. An   isomorphism only exists if this function returns true for all matched vertices.\nedge_relation: A binary function that takes an edge from g1 and one from g2. An   isomorphism only exists if this function returns true for all matched edges.\n\nExamples\n\njulia> has_subgraphisomorph(complete_graph(5), complete_graph(4))\ntrue\njulia> has_subgraphisomorph(complete_graph(5), cycle_graph(4))\ntrue\n\njulia> g1 = path_digraph(3); color1 = [1, 1, 1]\njulia> g2 = path_digraph(2); color2 = [1, 2]\njulia> color_rel(u, v) = (color1[u] == color2[v])\njulia> has_subgraphisomorph(g1, g2)\ntrue\njulia> has_subgraphisomorph(g1, g2, vertex_relation=color_rel)\nfalse\n\nSee also\n\nhas_induced_subgraphisomorph, has_isomorph, count_subgraphisomorph, all_subgraphisomorph\n\n\n\n\n\n","category":"function"},{"location":"advanced/experimental/#Graphs.Experimental.VF2","page":"Experimental algorithms","title":"Graphs.Experimental.VF2","text":"VF2\n\nAn empty concrete type used to dispatch to vf2 isomorphism functions.\n\n\n\n\n\n","category":"type"},{"location":"advanced/experimental/#Graphs.Experimental.VF2State","page":"Experimental algorithms","title":"Graphs.Experimental.VF2State","text":"VF2State{G, T}\n\nStructure that is internally used by vf2\n\n\n\n\n\n","category":"type"},{"location":"advanced/experimental/#Graphs.Experimental.vf2-Union{Tuple{G}, Tuple{Function, G, G, Graphs.Experimental.GraphMorphismProblem}} where G<:Graphs.SimpleGraphs.AbstractSimpleGraph","page":"Experimental algorithms","title":"Graphs.Experimental.vf2","text":"vf2(callback, g1, g2, problemtype; vertex_relation=nothing, edge_relation=nothing)\n\nIterate over all isomorphism between the graphs g1 (or subgraphs thereof) and g2. The problem that is solved depends on the value of problemtype:\n\nIsomorphismProblem(): Only isomorphisms between the whole graph g1 and g2 are considered.\nSubGraphIsomorphismProblem(): All isomorphism between subgraphs of g1 and g2 are considered.\nInducedSubGraphIsomorphismProblem(): All isomorphism between vertex induced subgraphs of g1 and g2 are considered.\n\nUpon finding an isomorphism, the function callback is called with a vector vmap as an argument. vmap is a vector where vmap[v] == u means that vertex v in g2 is mapped to vertex u in g1. If the algorithm should look for another isomorphism, then this function should return true.\n\nOptional Arguments\n\nvertex_relation: A binary function that takes a vertex from g1 and one from g2. An   isomorphism only exists if this function returns true for all matched vertices.\nedge_relation: A binary function that takes an edge from g1 and one from g2. An   isomorphism only exists if this function returns true for all matched edges.\n\nReferences\n\nLuigi P. Cordella, Pasquale Foggia, Carlo Sansone, Mario Vento “A (Sub)Graph Isomorphism Algorithm for Matching Large Graphs”\n\n\n\n\n\n","category":"method"},{"location":"advanced/experimental/#Graphs.Experimental.vf2check_feasibility-Tuple{Any, Any, Graphs.Experimental.VF2State, Any, Union{Nothing, Function}, Union{Nothing, Function}}","page":"Experimental algorithms","title":"Graphs.Experimental.vf2check_feasibility","text":"vf2check_feasibility(u, v, state, problemtype, vertex_relation, edge_relation)\n\nCheck whether two vertices of G₁ and G₂ can be matched. Used by vf2match!.\n\n\n\n\n\n","category":"method"},{"location":"advanced/experimental/#Graphs.Experimental.vf2match!-Tuple{Any, Any, Function, Graphs.Experimental.GraphMorphismProblem, Any, Any}","page":"Experimental algorithms","title":"Graphs.Experimental.vf2match!","text":"vf2match!(state, depth, callback, problemtype, vertex_relation, edge_relation)\n\nPerform isomorphic subgraph matching. Called by vf2.\n\n\n\n\n\n","category":"method"},{"location":"advanced/experimental/#Graphs.Experimental.vf2reset_state!-Tuple{Graphs.Experimental.VF2State, Any, Any, Any}","page":"Experimental algorithms","title":"Graphs.Experimental.vf2reset_state!","text":"vf2reset_state!(state, u, v, depth)\n\nReset state after returning from recursion. Helper function for vf2match!.\n\n\n\n\n\n","category":"method"},{"location":"advanced/experimental/#Graphs.Experimental.vf2update_state!-Tuple{Graphs.Experimental.VF2State, Any, Any, Any}","page":"Experimental algorithms","title":"Graphs.Experimental.vf2update_state!","text":"vf2update_state!(state, u, v, depth)\n\nUpdate state before recursing. Helper function for vf2match!.\n\n\n\n\n\n","category":"method"},{"location":"advanced/experimental/#Graphs.Experimental.Traversals.distances-Union{Tuple{T}, Tuple{AbstractGraph{T}, Any}, Tuple{AbstractGraph{T}, Any, Graphs.Experimental.Traversals.BFS}} where T","page":"Experimental algorithms","title":"Graphs.Experimental.Traversals.distances","text":"distances(g, s, alg=BFS())\ndistances(g, ss, alg=BFS())\n\nReturn a vector filled with the geodesic distances of vertices in  g from vertex s / unique vertices ss using BFS traversal algorithm alg.  For vertices in disconnected components the default distance is typemax(T).\n\n\n\n\n\n","category":"method"},{"location":"advanced/experimental/#Graphs.Experimental.Traversals.traverse_graph!-Union{Tuple{U}, Tuple{AbstractGraph{U}, AbstractVector, Graphs.Experimental.Traversals.BFS, Graphs.Experimental.Traversals.AbstractTraversalState}, Tuple{AbstractGraph{U}, AbstractVector, Graphs.Experimental.Traversals.BFS, Graphs.Experimental.Traversals.AbstractTraversalState, Function}} where U<:Integer","page":"Experimental algorithms","title":"Graphs.Experimental.Traversals.traverse_graph!","text":"traverse_graph!(g, s, alg, state, neighborfn=outneighbors)\ntraverse_graph!(g, ss, alg, state, neighborfn=outneighbors)\n\nTraverse a graph `g` starting at vertex `s` / vertices `ss` using algorithm `alg`, maintaining state in [`AbstractTraversalState`](@ref) `state`. Next vertices to be visited are determined by `neighborfn` (default `outneighbors`). Return `true` if traversal finished; `false` if one of the visit functions caused an early termination.\n\n\n\n\n\n","category":"method"},{"location":"advanced/experimental/#Graphs.Experimental.Traversals.AbstractTraversalState","page":"Experimental algorithms","title":"Graphs.Experimental.Traversals.AbstractTraversalState","text":"abstract type AbstractTraversalState\n\nAbstractTraversalState is the abstract type used to hold mutable states for various traversal algorithms (see traverse_graph!).\n\nWhen creating concrete types, you should override the following functions where relevant. These functions are listed in order of occurrence in the traversal:\n\ninitfn!(<:AbstractTraversalState, u::Integer): runs prior to traversal, used to set initial state.\nprevisitfn!(<:AbstractTraversalState, u::Integer): runs prior to neighborhood discovery for vertex u.\nvisitfn!(<:AbstractTraversalState, u::Integer, v::Integer): runs for each neighbor v (newly-discovered or not) of vertex u.\nnewvisitfn!(<:AbstractTraversalState, u::Integer, v::Integer): runs when a new neighbor v of vertex u is discovered.\npostvisitfn!(<:AbstractTraversalState, u::Integer): runs after neighborhood discovery for vertex u.\npostlevelfn!(<:AbstractTraversalState): runs after each traversal level.\n\nEach of these functions should return a boolean. If the return value of the function is false, the traversal will return the state immediately. Otherwise, the traversal will continue.\n\nFor better performance, use the @inline directive and make your functions branch-free.\n\n\n\n\n\n","category":"type"},{"location":"advanced/experimental/#Graphs.Experimental.Traversals.TraversalAlgorithm","page":"Experimental algorithms","title":"Graphs.Experimental.Traversals.TraversalAlgorithm","text":"abstract type TraversalAlgorithm\n\nTraversalAlgorithm is the abstract type used to specify breadth-first traversal (BFS) or depth-first traversal (DFS) for the various traversal functions.\n\n\n\n\n\n","category":"type"},{"location":"advanced/experimental/#Graphs.Experimental.Traversals.initfn!-Tuple{Graphs.Experimental.Traversals.AbstractTraversalState, Any}","page":"Experimental algorithms","title":"Graphs.Experimental.Traversals.initfn!","text":"initfn!(state, u)\n\nModify AbstractTraversalState state on initialization of traversal with source vertices, and return true if successful; false otherwise. initfn! will be called once for each vertex passed to traverse_graph!.\n\n\n\n\n\n","category":"method"},{"location":"advanced/experimental/#Graphs.Experimental.Traversals.newvisitfn!-Tuple{Graphs.Experimental.Traversals.AbstractTraversalState, Any, Any}","page":"Experimental algorithms","title":"Graphs.Experimental.Traversals.newvisitfn!","text":"newvisitfn!(state, u, v)\n\nModify AbstractTraversalState state when the first edge between u and v is encountered, and return true if successful; false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"advanced/experimental/#Graphs.Experimental.Traversals.parents-Union{Tuple{T}, Tuple{AbstractGraph{T}, Integer, Graphs.Experimental.Traversals.TraversalAlgorithm}, Tuple{AbstractGraph{T}, Integer, Graphs.Experimental.Traversals.TraversalAlgorithm, Any}} where T","page":"Experimental algorithms","title":"Graphs.Experimental.Traversals.parents","text":"parents(g, s, alg, neighborfn=outneighbors)\n\nReturn a vector of parent vertices indexed by vertex using TraversalAlgorithm alg starting with vertex s. If neighborfn is specified, use the corresponding neighbor-generation function (inneighborsr and outneighbors are valid values).\n\nPerformance\n\nThis implementation is designed to perform well on large graphs. There are implementations which are marginally faster in practice for smaller graphs, but the performance improvements using this implementation on large graphs can be significant.\n\n\n\n\n\n","category":"method"},{"location":"advanced/experimental/#Graphs.Experimental.Traversals.postlevelfn!-Tuple{Graphs.Experimental.Traversals.AbstractTraversalState}","page":"Experimental algorithms","title":"Graphs.Experimental.Traversals.postlevelfn!","text":"postlevelfn!(state)\n\nModify AbstractTraversalState state before moving to the next vertex in the traversal algorithm, and return true if successful; false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"advanced/experimental/#Graphs.Experimental.Traversals.postvisitfn!-Tuple{Graphs.Experimental.Traversals.AbstractTraversalState, Any}","page":"Experimental algorithms","title":"Graphs.Experimental.Traversals.postvisitfn!","text":"postvisitfn!(state, u)\n\nModify AbstractTraversalState state after having examined all neighbors of vertex u, and return true if successful; false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"advanced/experimental/#Graphs.Experimental.Traversals.previsitfn!-Tuple{Graphs.Experimental.Traversals.AbstractTraversalState, Any}","page":"Experimental algorithms","title":"Graphs.Experimental.Traversals.previsitfn!","text":"previsitfn!(state, u)\n\nModify AbstractTraversalState state before examining neighbors of vertex u, and return true if successful; false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"advanced/experimental/#Graphs.Experimental.Traversals.traverse_graph!-Tuple{AbstractGraph, Integer, Any, Any, Any}","page":"Experimental algorithms","title":"Graphs.Experimental.Traversals.traverse_graph!","text":"traverse_graph!(g, s, alg, state, neighborfn=outneighbors)\ntraverse_graph!(g, ss, alg, state, neighborfn=outneighbors)\n\nTraverse a graph g from source vertex s / vertices ss keeping track of state. Return true if traversal finished normally; false if one of the visit functions returned false (see )\n\n\n\n\n\n","category":"method"},{"location":"advanced/experimental/#Graphs.Experimental.Traversals.tree","page":"Experimental algorithms","title":"Graphs.Experimental.Traversals.tree","text":"tree(g, s, alg, neighborfn=outneighbors)\n\nReturn a directed acyclic graph based on traversal of the graph g starting with source vertex s using algorithm alg with neighbor function neighborfn.\n\n\n\n\n\n","category":"function"},{"location":"advanced/experimental/#Graphs.Experimental.Traversals.tree-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T<:Integer","page":"Experimental algorithms","title":"Graphs.Experimental.Traversals.tree","text":"tree(p)\n\nReturn a directed acyclic graph based on a parents vector p.\n\n\n\n\n\n","category":"method"},{"location":"advanced/experimental/#Graphs.Experimental.Traversals.visited_vertices-Union{Tuple{U}, Tuple{AbstractGraph{U}, AbstractVector, Graphs.Experimental.Traversals.TraversalAlgorithm}} where U<:Integer","page":"Experimental algorithms","title":"Graphs.Experimental.Traversals.visited_vertices","text":"visited_vertices(g, s, alg)\nvisited_vertices(g, ss, alg)\n\nReturn a vector representing the vertices of g visited in order by TraversalAlgorithm alg starting at vertex s (vertices ss).\n\n\n\n\n\n","category":"method"},{"location":"advanced/experimental/#Graphs.Experimental.Traversals.visitfn!-Tuple{Graphs.Experimental.Traversals.AbstractTraversalState, Any, Any}","page":"Experimental algorithms","title":"Graphs.Experimental.Traversals.visitfn!","text":"visitfn!(state, u, v)\n\nModify AbstractTraversalState state when the edge between u and v is encountered, and return true if successful; false otherwise. Note: visitfn! may be called multiple times per edge, depending on the traversal algorithm, for a function that operates on the first occurrence only, use newvisitfn!.\n\n\n\n\n\n","category":"method"},{"location":"advanced/experimental/#Graphs.Experimental.ShortestPaths.AStar","page":"Experimental algorithms","title":"Graphs.Experimental.ShortestPaths.AStar","text":"struct AStar <: ShortestPathAlgorithm\n\nThe structure used to configure and specify that shortest_paths should use the A* search algorithm. An optional heuristic function may be supplied. If missing, the heuristic is set to n -> 0.\n\nImplementation Notes\n\nAStar supports the following shortest-path functionality:\n\nnon-negative distance matrices / weights\nsingle destination\n\n\n\n\n\n","category":"type"},{"location":"advanced/experimental/#Graphs.Experimental.ShortestPaths.BellmanFord","page":"Experimental algorithms","title":"Graphs.Experimental.ShortestPaths.BellmanFord","text":"struct BellmanFord <: ShortestPathAlgorithm\n\nThe structure used to configure and specify that shortest_paths should use the Bellman-Ford algorithm. No fields are specified or required.\n\nImplementation Notes\n\nBellmanFord supports the following shortest-path functionality:\n\nnegative distance matrices / weights\n(optional) multiple sources\nall destinations\n\n\n\n\n\n","category":"type"},{"location":"advanced/experimental/#Graphs.Experimental.ShortestPaths.BFS","page":"Experimental algorithms","title":"Graphs.Experimental.ShortestPaths.BFS","text":"struct BFS <: ShortestPathAlgorithm\n\nThe structure used to configure and specify that shortest_paths should use the Breadth-First Search algorithm.\n\nAn optional sorting algorithm may be specified (default = no sorting). Sorting helps maintain cache locality and will improve performance on very large graphs; for normal use, sorting will incur a performance penalty.\n\nBFS is the default algorithm used when a source is specified but no distance matrix is specified.\n\nImplementation Notes\n\nBFS supports the following shortest-path functionality:\n\n(optional) multiple sources\nall destinations\n\n\n\n\n\n","category":"type"},{"location":"advanced/experimental/#Graphs.Experimental.ShortestPaths.DEsopoPape","page":"Experimental algorithms","title":"Graphs.Experimental.ShortestPaths.DEsopoPape","text":"struct DEsopoPape <: ShortestPathAlgorithm\n\nThe structure used to configure and specify that shortest_paths should use the D'Esopo-Pape algorithm. No fields are specified or required.\n\nImplementation Notes\n\nDEsopoPape supports the following shortest-path functionality:\n\nnon-negative distance matrices / weights\nall destinations\n\n\n\n\n\n","category":"type"},{"location":"advanced/experimental/#Graphs.Experimental.ShortestPaths.Dijkstra","page":"Experimental algorithms","title":"Graphs.Experimental.ShortestPaths.Dijkstra","text":"struct Dijkstra <: ShortestPathAlgorithm\n\nThe structure used to configure and specify that shortest_paths should use Dijkstra's algorithm to compute shortest paths. Optional fields for this structure include\n\nall_paths::Bool - set to true to calculate all (redundant, equivalent) paths to a given destination\ntrack_vertices::Bool - set to true to keep a running list of visited vertices (used for specific centrality calculations; generally not needed).\n\nDijkstra is the default algorithm used when a distance matrix is specified.\n\nImplementation Notes\n\nDijkstra supports the following shortest-path functionality:\n\nnon-negative distance matrices / weights\n(optional) multiple sources\nall destinations\nredundant equivalent path tracking\nvertex tracking\n\nPerformance\n\nIf using a sparse matrix for distmx in shortest_paths, you may achieve better performance by passing in a transpose of its sparse transpose. That is, assuming D is the sparse distance matrix:\n\nD = transpose(sparse(transpose(D)))\n\nBe aware that realizing the sparse transpose of D incurs a heavy one-time penalty, so this strategy should only be used when multiple calls to shortest_paths with the distance matrix are planned.\n\n\n\n\n\n","category":"type"},{"location":"advanced/experimental/#Graphs.Experimental.ShortestPaths.FloydWarshall","page":"Experimental algorithms","title":"Graphs.Experimental.ShortestPaths.FloydWarshall","text":"struct FloydWarshall <: ShortestPathAlgorithm\n\nThe structure used to configure and specify that shortest_paths should use the Floyd-Warshall algorithm. No additional configuration parameters are specified or required.\n\nFloydWarshall is the default all-pairs algorithm used when no source is specified.\n\nImplementation Notes\n\nFloydWarshall supports the following shortest-path functionality:\n\nnon-negative distance matrices / weights\nall-pairs shortest paths\n\nPerformance\n\nSpace complexity is on the order of mathcalO(V^2).\n\n\n\n\n\n","category":"type"},{"location":"advanced/experimental/#Graphs.Experimental.ShortestPaths.Johnson","page":"Experimental algorithms","title":"Graphs.Experimental.ShortestPaths.Johnson","text":"struct Johnson <: ShortestPathAlgorithm\n\nThe structure used to configure and specify that shortest_paths should use the Johnson algorithm. No additional configuration parameters are specified or required.\n\nImplementation Notes\n\nJohnson supports the following shortest-path functionality:\n\nnon-negative distance matrices / weights\nall-pairs shortest paths\n\nPerformance\n\nComplexity: O(|V|*|E|)\n\n\n\n\n\n","category":"type"},{"location":"advanced/experimental/#Graphs.Experimental.ShortestPaths.ShortestPathAlgorithm","page":"Experimental algorithms","title":"Graphs.Experimental.ShortestPaths.ShortestPathAlgorithm","text":"ShortestPathAlgorithm <: AbstractGraphAlgorithm\n\nConcrete subtypes of ShortestPathAlgorithm are used to specify the type of shortest path calculation used by shortest_paths. Some concrete subtypes (most notably Dijkstra have fields that specify algorithm parameters.\n\nSee AStar, BellmanFord, BFS, DEsopoPape, Dijkstra, FloydWarshall, Johnson, and SPFA for specific requirements and usage details.\n\n\n\n\n\n","category":"type"},{"location":"advanced/experimental/#Graphs.Experimental.ShortestPaths.ShortestPathResult","page":"Experimental algorithms","title":"Graphs.Experimental.ShortestPaths.ShortestPathResult","text":"ShortestPathResult <: AbstractGraphResult\n\nConcrete subtypes of ShortestPathResult contain the results of a shortest-path calculation using a specific ShortestPathAlgorithm.\n\nIn general, the fields in these structs should not be accessed directly; use the dists and paths functions to obtain the results of the calculation.\n\n\n\n\n\n","category":"type"},{"location":"advanced/experimental/#Graphs.Experimental.ShortestPaths.dists-Tuple{Graphs.Experimental.ShortestPaths.ShortestPathResult, Integer}","page":"Experimental algorithms","title":"Graphs.Experimental.ShortestPaths.dists","text":"dists(state[, v])\n\nGiven the output of a shortest_paths calculation of type ShortestPathResult, return a vector (indexed by vertex) of the distances between the source vertex used to compute the shortest path and a single destination vertex v or the entire graph.\n\nFor ShortestPathAlgorithms that compute all-pairs shortest paths, dists(state) will return a matrix (indexed by source and destination vertices) of distances.\n\n\n\n\n\n","category":"method"},{"location":"advanced/experimental/#Graphs.Experimental.ShortestPaths.has_negative_weight_cycle","page":"Experimental algorithms","title":"Graphs.Experimental.ShortestPaths.has_negative_weight_cycle","text":"has_negative_weight_cycle(g[, distmx=weights(g), alg=BellmanFord()])\n\nGiven a graph g, an optional distance matrix distmx, and an optional algorithm alg (one of BellmanFord or SPFA), return true if any cycle detected in the graph has a negative weight.\n\nExamples\n\njulia> g = complete_graph(3);\n\njulia> d = [1 -3 1; -3 1 1; 1 1 1];\n\njulia> has_negative_weight_cycle(g, d)\ntrue\n\njulia> g = complete_graph(4);\n\njulia> d = [1 1 -1 1; 1 1 -1 1; 1 1 1 1; 1 1 1 1];\n\njulia> has_negative_weight_cycle(g, d, SPFA())\nfalse\n\n\n\n\n\n","category":"function"},{"location":"advanced/experimental/#Graphs.Experimental.ShortestPaths.paths-Tuple{Graphs.Experimental.ShortestPaths.ShortestPathResult, AbstractVector{<:Integer}}","page":"Experimental algorithms","title":"Graphs.Experimental.ShortestPaths.paths","text":"paths(state[, v])\npaths(state[, vs])\npaths(state[, v, d]))\n\nGiven the output of a shortest_paths calculation of type ShortestPathResult, return a vector (indexed by vertex) of the paths between the source vertex used to compute the shortest path and a single destination vertex v, a vector of destination vertices vs, or the entire graph.\n\nFor multiple destination vertices, each path is represented by a vector of vertices on the path between the source and the destination. Nonexistent paths will be indicated by an empty vector. For single destinations, the path is represented by a single vector of vertices, and will be length 0 if the path does not exist.\n\nFor ShortestPathAlgorithms that compute all shortest paths for all pairs of vertices, paths(state) will return a vector (indexed by source vertex) of vectors (indexed by destination vertex) of paths. paths(state, v) will return a vector (indexed by destination vertex) of paths from source v to all other vertices. In addition, paths(state, v, d) will return a vector representing the path from vertex v to vertex d.\n\n\n\n\n\n","category":"method"},{"location":"advanced/experimental/#Graphs.Experimental.ShortestPaths.shortest_paths-Tuple{AbstractGraph, Any, Graphs.Experimental.ShortestPaths.ShortestPathAlgorithm}","page":"Experimental algorithms","title":"Graphs.Experimental.ShortestPaths.shortest_paths","text":"shortest_paths(g, s, distmx, alg)\nshortest_paths(g, s, t, alg)\nshortest_paths(g, s, alg)\nshortest_paths(g, s)\nshortest_paths(g)\n\nReturn a ShortestPathResult that allows construction of the shortest path between sets of vertices in graph g. Depending on the algorithm specified, other information may be required: (e.g., a distance matrix distmx, and/or a target vertex t). Some algorithms will accept multiple source vertices s; algorithms that do not accept any source vertex s produce all-pairs shortest paths.\n\nSee ShortestPathAlgorithm for more details on the algorithm specifications.\n\nImplementation Notes\n\nThe elements of distmx may be of any type that has a Total Ordering and valid comparator, zero and typemax functions. Concretely, this means that distance matrices containing complex numbers are invalid.\n\nExamples\n\ng = path_graph(4)\nw = zeros(4, 4)\nfor i in 1:3\n    w[i, i+1] = 1.0\n    w[i+1, i] = 1.0\nend\n\ns1 = shortest_paths(g)                   # `alg` defaults to `FloydWarshall`\ns2 = shortest_paths(g, 1)                # `alg` defaults to `BFS`\ns3 = shortest_paths(g, 1, w)             # `alg` defaults to `Dijkstra`\ns4 = shortest_paths(g, 1, BellmanFord())\ns5 = shortest_paths(g, 1, w, DEsopoPape())\n\n\n\n\n\n","category":"method"},{"location":"advanced/experimental/#Graphs.Experimental.ShortestPaths.SPFA","page":"Experimental algorithms","title":"Graphs.Experimental.ShortestPaths.SPFA","text":"struct SPFA <: ShortestPathAlgorithm\n\nThe structure used to configure and specify that shortest_paths should use the Shortest Path Faster Algorithm. No additional configuration parameters are specified or required.\n\nImplementation Notes\n\nSPFA supports the following shortest-path functionality:\n\nnon-negative distance matrices / weights\nall destinations\n\n\n\n\n\n","category":"type"},{"location":"advanced/experimental/#Graphs.Experimental.ShortestPaths.has_negative_weight_cycle-Tuple{AbstractGraph, AbstractMatrix, Graphs.Experimental.ShortestPaths.SPFA}","page":"Experimental algorithms","title":"Graphs.Experimental.ShortestPaths.has_negative_weight_cycle","text":"Function which returns true if there is any negative weight cycle in the graph.\n\nExamples\n\njulia> g = complete_graph(3);\n\njulia> d = [1 -3 1; -3 1 1; 1 1 1];\n\njulia> has_negative_weight_cycle(g, d, SPFA())\ntrue\n\njulia> g = complete_graph(4);\n\njulia> d = [1 1 -1 1; 1 1 -1 1; 1 1 1 1; 1 1 1 1];\n\njulia> has_negative_weight_cycle(g, d, SPFA());\nfalse\n\n\n\n\n\n","category":"method"},{"location":"advanced/experimental/#Graphs.Experimental.Parallel.gdistances!-Union{Tuple{T}, Tuple{AbstractGraph{T}, Vector{<:Integer}, Vector{T}}} where T<:Integer","page":"Experimental algorithms","title":"Graphs.Experimental.Parallel.gdistances!","text":"gdistances!(g, sources, vert_level; queue_segment_size=20)\ngdistances!(g, source, vert_level; queue_segment_size=20)\n\nParallel implementation of Graphs.gdistances! with dynamic load balancing.\n\nOptional Arguments\n\nqueue_segment_size = 20: It is the number of vertices a thread can claim from a queue\n\nat a time. For graphs with uniform degree, a larger value of queue_segment_size could improve performance.\n\nReferences\n\n[Avoiding Locks and Atomic Instructions in Shared-Memory Parallel BFS Using Optimistic \n\nParallelization](https://www.computer.org/csdl/proceedings/ipdpsw/2013/4979/00/4979b628-abs.html).\n\n\n\n\n\n","category":"method"},{"location":"advanced/experimental/#Graphs.Experimental.Parallel.gdistances-Union{Tuple{T}, Tuple{AbstractGraph{T}, Vector{<:Integer}}} where T<:Integer","page":"Experimental algorithms","title":"Graphs.Experimental.Parallel.gdistances","text":"gdistances(g, sources; queue_segment_size=20)\ngdistances(g, source; queue_segment_size=20)\n\nParallel implementation of Graphs.gdistances! with dynamic load balancing.\n\nOptional Arguments\n\nqueue_segment_size = 20: It is the number of vertices a thread can claim from a queue at a time.\n\nFor denser graphs, a smaller value of queue_segment_size could improve performance.\n\nReferences\n\n[Avoiding Locks and Atomic Instructions in Shared-Memory Parallel BFS Using Optimistic \n\nParallelization](https://www.computer.org/csdl/proceedings/ipdpsw/2013/4979/00/4979b628-abs.html).\n\n\n\n\n\n","category":"method"},{"location":"advanced/experimental/#Graphs.Experimental.Parallel.partition_sources!-Union{Tuple{T}, Tuple{Array{Vector{T}, 1}, Vector{<:Integer}, Vector{Bool}}} where T<:Integer","page":"Experimental algorithms","title":"Graphs.Experimental.Parallel.partition_sources!","text":"partition_sources!(queue_list, sources)\n\nPartition sources using Graphs.unweighted_contiguous_partition and place the i^{th} partition  into queue_list[i] and set to empty_list[i] to true if the  i^{th} partition is empty.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/degeneracy/#Degeneracy","page":"Degeneracy","title":"Degeneracy","text":"","category":"section"},{"location":"algorithms/degeneracy/","page":"Degeneracy","title":"Degeneracy","text":"Graphs.jl provides a few functions for graph degeneracy.","category":"page"},{"location":"algorithms/degeneracy/#Index","page":"Degeneracy","title":"Index","text":"","category":"section"},{"location":"algorithms/degeneracy/","page":"Degeneracy","title":"Degeneracy","text":"Pages = [\"degeneracy.md\"]","category":"page"},{"location":"algorithms/degeneracy/#Full-docs","page":"Degeneracy","title":"Full docs","text":"","category":"section"},{"location":"algorithms/degeneracy/","page":"Degeneracy","title":"Degeneracy","text":"Modules = [Graphs]\nPages   = [\"degeneracy.jl\"]\n","category":"page"},{"location":"algorithms/degeneracy/#Graphs.core_number-Union{Tuple{AbstractGraph{T}}, Tuple{T}} where T","page":"Degeneracy","title":"Graphs.core_number","text":"core_number(g)\n\nReturn the core number for each vertex in graph g.\n\nA k-core is a maximal subgraph that contains vertices of degree k or more. The core number of a vertex is the largest value k of a k-core containing that vertex.\n\nImplementation Notes\n\nNot implemented for graphs with self loops.\n\nReferences\n\nAn O(m) Algorithm for Cores Decomposition of Networks,   Vladimir Batagelj and Matjaz Zaversnik, 2003.   http://arxiv.org/abs/cs.DS/0310049\n\nExamples\n\njulia> using Graphs\n\njulia> g = path_graph(5);\n\njulia> add_vertex!(g);\n\njulia> add_edge!(g, 5, 2);\n\njulia> core_number(g)\n6-element Array{Int64,1}:\n 1\n 2\n 2\n 2\n 2\n 0\n\n\n\n\n\n","category":"method"},{"location":"algorithms/degeneracy/#Graphs.k_core","page":"Degeneracy","title":"Graphs.k_core","text":"k_core(g[, k]; corenum=core_number(g))\n\nReturn a vector of vertices in the k-core of graph g. If k is not specified, return the core with the largest degree.\n\nA k-core is a maximal subgraph that contains vertices of degree k or more.\n\nImplementation Notes\n\nNot implemented for graphs with self loops.\n\nReferences\n\nAn O(m) Algorithm for Cores Decomposition of Networks,   Vladimir Batagelj and Matjaz Zaversnik, 2003.   http://arxiv.org/abs/cs.DS/0310049\n\nExamples\n\njulia> using Graphs\n\njulia> g = path_graph(5);\n\njulia> add_vertex!(g);\n\njulia> add_edge!(g, 5, 2);\n\njulia> k_core(g, 1)\n5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n\njulia> k_core(g, 2)\n4-element Array{Int64,1}:\n 2\n 3\n 4\n 5\n\n\n\n\n\n","category":"function"},{"location":"algorithms/degeneracy/#Graphs.k_corona-Tuple{AbstractGraph, Any}","page":"Degeneracy","title":"Graphs.k_corona","text":"k_corona(g, k; corenum=core_number(g))\n\nReturn a vector of vertices in the k-corona of g.\n\nThe k-corona is the subgraph of vertices in the k-core which have exactly k neighbors in the k-core.\n\nImplementation Notes\n\nNot implemented for graphs with parallel edges or self loops.\n\nReferences\n\nk-core (bootstrap) percolation on complex networks:  Critical phenomena and nonlocal effects,  A. V. Goltsev, S. N. Dorogovtsev, and J. F. F. Mendes,  Phys. Rev. E 73, 056101 (2006)  http://link.aps.org/doi/10.1103/PhysRevE.73.056101\n\nExamples\n\njulia> using Graphs\n\njulia> g = path_graph(5);\n\njulia> add_vertex!(g);\n\njulia> add_edge!(g, 5, 2);\n\njulia> k_corona(g, 0)\n1-element Array{Int64,1}:\n 6\n\njulia> k_corona(g, 1)\n1-element Array{Int64,1}:\n 1\n\njulia> k_corona(g, 2)\n4-element Array{Int64,1}:\n 2\n 3\n 4\n 5\n\njulia> k_corona(g, 3)\n0-element Array{Int64,1}\n\n\n\n\n\n","category":"method"},{"location":"algorithms/degeneracy/#Graphs.k_crust","page":"Degeneracy","title":"Graphs.k_crust","text":"k_crust(g[, k]; corenum=core_number(g))\n\nReturn a vector of vertices in the k-crust of g. If k is not specified, return the crust of the core with the largest degree.\n\nThe k-crust is the graph g with the k-core removed.\n\nImplementation Notes\n\nThis definition of k-crust is different than the definition in References. The k-crust in References is equivalent to the k+1 crust of this algorithm.\n\nNot implemented for graphs with self loops.\n\nReferences\n\nA model of Internet topology using k-shell decomposition  Shai Carmi, Shlomo Havlin, Scott Kirkpatrick, Yuval Shavitt,  and Eran Shir, PNAS  July 3, 2007   vol. 104  no. 27  11150-11154  http://www.pnas.org/content/104/27/11150.full\n\nExamples\n\njulia> using Graphs\n\njulia> g = path_graph(5);\n\njulia> add_vertex!(g);\n\njulia> add_edge!(g, 5, 2);\n\njulia> k_crust(g, 0)\n1-element Array{Int64,1}:\n 6\n\njulia> k_crust(g, 1)\n2-element Array{Int64,1}:\n 1\n 6\n\njulia> k_crust(g, 2)\n6-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n 6\n\n\n\n\n\n","category":"function"},{"location":"algorithms/degeneracy/#Graphs.k_shell","page":"Degeneracy","title":"Graphs.k_shell","text":"k_shell(g[, k]; corenum=core_number(g))\n\nReturn a vector of vertices in the k-shell of g. If k is not specified, return the shell of the core with the largest degree.\n\nThe k-shell is the subgraph of vertices in the k-core but not in the (k+1)-core. This is similar to k_corona but in that case only neighbors in the k-core are considered.\n\nImplementation Notes\n\nNot implemented for graphs with parallel edges or self loops.\n\nReferences\n\nA model of Internet topology using k-shell decomposition  Shai Carmi, Shlomo Havlin, Scott Kirkpatrick, Yuval Shavitt,  and Eran Shir, PNAS  July 3, 2007   vol. 104  no. 27  11150-11154  http://www.pnas.org/content/104/27/11150.full\n\nExamples\n\njulia> using Graphs\n\njulia> g = path_graph(5);\n\njulia> add_vertex!(g);\n\njulia> add_edge!(g, 5, 2);\n\njulia> k_shell(g, 0)\n1-element Array{Int64,1}:\n 6\n\njulia> k_shell(g, 1)\n1-element Array{Int64,1}:\n 1\n\njulia> k_shell(g, 2)\n4-element Array{Int64,1}:\n 2\n 3\n 4\n 5\n\n\n\n\n\n","category":"function"},{"location":"algorithms/spanningtrees/#Spanning-trees","page":"Spanning trees","title":"Spanning trees","text":"","category":"section"},{"location":"algorithms/spanningtrees/","page":"Spanning trees","title":"Spanning trees","text":"Graphs.jl contains a few algorithms to compute minimum spanning trees.","category":"page"},{"location":"algorithms/spanningtrees/#Index","page":"Spanning trees","title":"Index","text":"","category":"section"},{"location":"algorithms/spanningtrees/","page":"Spanning trees","title":"Spanning trees","text":"Pages = [\"spanningtrees.md\"]","category":"page"},{"location":"algorithms/spanningtrees/#Full-docs","page":"Spanning trees","title":"Full docs","text":"","category":"section"},{"location":"algorithms/spanningtrees/","page":"Spanning trees","title":"Spanning trees","text":"Modules = [Graphs]\nPages = [\n    \"spanningtrees/boruvka.jl\",\n    \"spanningtrees/kruskal.jl\",\n    \"spanningtrees/prim.jl\",\n]\n","category":"page"},{"location":"algorithms/spanningtrees/#Graphs.boruvka_mst","page":"Spanning trees","title":"Graphs.boruvka_mst","text":"boruvka_mst(g, distmx = weights(g); minimize = true)\n\nReturn a tuple (mst, weights) where mst is a vector of edges representing the optimum (minimum, by default) spanning tree of a connected, undirected graph g with optional matrix distmx that provides distinct edge weights, and weights is the sum of all the edges in the solution by using Boruvka's algorithm. The algorithm requires that all edges have different weights to correctly generate a minimun/maximum spanning tree\n\nOptional Arguments\n\nminimize=true: if set to false, calculate the maximum spanning tree.\n\n\n\n\n\n","category":"function"},{"location":"algorithms/spanningtrees/#Graphs.kruskal_mst","page":"Spanning trees","title":"Graphs.kruskal_mst","text":"kruskal_mst(g, distmx=weights(g); minimize=true)\n\nReturn a vector of edges representing the minimum (by default) spanning tree of a connected,  undirected graph g with optional distance matrix distmx using Kruskal's algorithm.\n\nOptional Arguments\n\nminimize=true: if set to false, calculate the maximum spanning tree.\n\n\n\n\n\n","category":"function"},{"location":"algorithms/spanningtrees/#Graphs.prim_mst","page":"Spanning trees","title":"Graphs.prim_mst","text":"prim_mst(g, distmx=weights(g))\n\nReturn a vector of edges representing the minimum spanning tree of a connected, undirected graph g with optional distance matrix distmx using Prim's algorithm. Return a vector of edges.\n\n\n\n\n\n","category":"function"},{"location":"first_steps/tutorials/#Tutorials","page":"Tutorials","title":"Tutorials","text":"","category":"section"},{"location":"first_steps/tutorials/","page":"Tutorials","title":"Tutorials","text":"In construction","category":"page"},{"location":"advanced/parallel/#Parallel-algorithms","page":"Parallel algorithms","title":"Parallel algorithms","text":"","category":"section"},{"location":"advanced/parallel/","page":"Parallel algorithms","title":"Parallel algorithms","text":"Graphs.Parallel is a module for graph algorithms that are parallelized. Their names should be consistent with the serial versions in the main module. In order to use parallel versions of the algorithms you can write:","category":"page"},{"location":"advanced/parallel/","page":"Parallel algorithms","title":"Parallel algorithms","text":"using Graphs\nimport Graphs.Parallel\n\ng = path_graph(10)\nbc = Parallel.betweenness_centrality(g)","category":"page"},{"location":"advanced/parallel/#How-to-use-them?","page":"Parallel algorithms","title":"How to use them?","text":"","category":"section"},{"location":"advanced/parallel/","page":"Parallel algorithms","title":"Parallel algorithms","text":"The arguments to parallel versions of functions match as closely as possible their serial versions with potential addition default or keyword arguments to control parallel execution. One exception is that for algorithms that cannot be meaningfully parallelized for certain types of arguments a MethodError will be raised. For example, dijkstra_shortest_paths works for either a single or multiple source argument, but since the parallel version is slower when given only a single source, it will raise a MethodError.","category":"page"},{"location":"advanced/parallel/","page":"Parallel algorithms","title":"Parallel algorithms","text":"g = Graph(10)\n# these work\nGraphs.dijkstra_shortest_paths(g,1)\nGraphs.dijkstra_shortest_paths(g, [1,2])\nParallel.dijkstra_shortest_paths(g, [1,2])\n# this doesn't\nParallel.dijkstra_shortest_paths(g,1)","category":"page"},{"location":"advanced/parallel/","page":"Parallel algorithms","title":"Parallel algorithms","text":"Note that after importing or using Graphs.Parallel, you must fully qualify the version of the function you wish to use (using, e.g., Graphs.betweenness_centrality(g) for the sequential version and Parallel.betweenness_centrality(g) for the parallel version).","category":"page"},{"location":"advanced/parallel/#Available-parallel-algorithms","page":"Parallel algorithms","title":"Available parallel algorithms","text":"","category":"section"},{"location":"advanced/parallel/","page":"Parallel algorithms","title":"Parallel algorithms","text":"The following is a current list of parallel algorithms:","category":"page"},{"location":"advanced/parallel/","page":"Parallel algorithms","title":"Parallel algorithms","text":"Centrality measures:\nParallel.betweenness_centrality\nParallel.closeness_centrality\nParallel.pagerank\nParallel.radiality_centrality\nParallel.stress_centrality\nDistance measures:\nParallel.center\nParallel.diameter\nParallel.eccentricity\nParallel.radius\nShortest paths algorithms:\nParallel.bellman_ford_shortest_paths\nParallel.dijkstra_shortest_paths\nParallel.floyd_warshall_shortest_paths\nParalell.johnson_shortest_paths\nTraversal algorithms:\nParallel.bfs\nParallel.greedy_color","category":"page"},{"location":"advanced/parallel/","page":"Parallel algorithms","title":"Parallel algorithms","text":"Also note that in some cases, the arguments for the parallel versions may differ from the serial (standard) versions. As an example, parallel Dijkstra shortest paths takes advantage of multiple processors to execute centrality from multiple source vertices. It is an error to pass a single source vertex into the parallel version of dijkstrashortestpaths.","category":"page"},{"location":"advanced/parallel/#Index","page":"Parallel algorithms","title":"Index","text":"","category":"section"},{"location":"advanced/parallel/","page":"Parallel algorithms","title":"Parallel algorithms","text":"Pages = [\"parallel.md\"]","category":"page"},{"location":"advanced/parallel/#Full-docs","page":"Parallel algorithms","title":"Full docs","text":"","category":"section"},{"location":"advanced/parallel/","page":"Parallel algorithms","title":"Parallel algorithms","text":"Modules = [Graphs, Graphs.Parallel]\nPages = [\n    \"Parallel/Parallel.jl\",\n    \"Parallel/utils.jl\",\n    \"Parallel/distance.jl\",\n    \"Parallel/centrality/betweenness.jl\",\n    \"Parallel/centrality/closeness.jl\",\n    \"Parallel/centrality/pagerank.jl\",\n    \"Parallel/centrality/radiality.jl\",\n    \"Parallel/centrality/stress.jl\",\n    \"Parallel/dominatingset/minimal_dom_set.jl\",\n    \"Parallel/independentset/maximal_ind_set.jl\",\n    \"Parallel/shortestpaths/bellman-ford.jl\",\n    \"Parallel/shortestpaths/dijkstra.jl\",\n    \"Parallel/shortestpaths/floyd-warshall.jl\",\n    \"Parallel/shortestpaths/johnson.jl\",\n    \"Parallel/traversals/bfs.jl\",\n    \"Parallel/traversals/greedy_color.jl\",\n    \"Parallel/vertexcover/random_vertex_cover.jl\",\n]","category":"page"},{"location":"advanced/parallel/#Graphs.Parallel.distr_generate_reduce-Union{Tuple{Comp}, Tuple{T}, Tuple{AbstractGraph{T}, Function, Comp, Integer}} where {T<:Integer, Comp}","page":"Parallel algorithms","title":"Graphs.Parallel.distr_generate_reduce","text":"distr_generate_min_set(g, gen_func, comp, reps)\n\nDistributed implementation of generate_reduce.\n\n\n\n\n\n","category":"method"},{"location":"advanced/parallel/#Graphs.Parallel.generate_reduce-Union{Tuple{Comp}, Tuple{T}, Tuple{AbstractGraph{T}, Function, Comp, Integer}} where {T<:Integer, Comp}","page":"Parallel algorithms","title":"Graphs.Parallel.generate_reduce","text":"generate_reduce(g, gen_func, comp, reps; parallel=:threads)\n\nCompute gen_func(g) reps times and return the instance best for which comp(best, v) is true where v is all the other instances of gen_func(g).\n\nFor example, comp(x, y) = length(x) < length(y) ? x : y then instance with the smallest length will be returned.\n\n\n\n\n\n","category":"method"},{"location":"advanced/parallel/#Graphs.Parallel.threaded_generate_reduce-Union{Tuple{Comp}, Tuple{T}, Tuple{AbstractGraph{T}, Function, Comp, Integer}} where {T<:Integer, Comp}","page":"Parallel algorithms","title":"Graphs.Parallel.threaded_generate_reduce","text":"threaded_generate_reduce(g, gen_func, comp reps)\n\nMulti-threaded implementation of generate_reduce.\n\n\n\n\n\n","category":"method"},{"location":"advanced/parallel/#Graphs.Parallel.dominating_set-Union{Tuple{T}, Tuple{AbstractGraph{T}, Integer, MinimalDominatingSet}} where T<:Integer","page":"Parallel algorithms","title":"Graphs.Parallel.dominating_set","text":"dominating_set(g, reps, MinimalDominatingSet(); parallel=:threads, seed=-1)\n\nPerform Graphs.dominating_set(g, MinimalDominatingSet()) reps times in parallel  and return the solution with the fewest vertices.\n\nOptional Arguements\n\nparallel=:threads: If parallel=:distributed then the multiprocessor implementation is\n\nused. This implementation is more efficient if reps is large.\n\nIf seed >= 0, a random generator of each process/thread is seeded with this value.\n\n\n\n\n\n","category":"method"},{"location":"advanced/parallel/#Graphs.Parallel.independent_set-Union{Tuple{T}, Tuple{AbstractGraph{T}, Integer, MaximalIndependentSet}} where T<:Integer","page":"Parallel algorithms","title":"Graphs.Parallel.independent_set","text":"independent_set(g, reps, MaximalIndependentSet(); parallel=:threads)\n\nPerform Graphs.independent_set(g, MaximalIndependentSet()) reps times in parallel  and return the solution with the most vertices.\n\nOptional Arguements\n\nparallel=:threads: If parallel=:distributed then the multiprocessor implementation is\n\nused. This implementation is more efficient if reps is large.\n\n\n\n\n\n","category":"method"},{"location":"advanced/parallel/#Graphs.Parallel.MultipleDijkstraState","page":"Parallel algorithms","title":"Graphs.Parallel.MultipleDijkstraState","text":"struct Parallel.MultipleDijkstraState{T, U}\n\nAn AbstractPathState designed for Parallel.dijkstrashortestpaths calculation.\n\n\n\n\n\n","category":"type"},{"location":"advanced/parallel/#Graphs.Parallel.dijkstra_shortest_paths-Union{Tuple{AbstractGraph{U}}, Tuple{T}, Tuple{U}, Tuple{AbstractGraph{U}, Any}, Tuple{AbstractGraph{U}, Any, AbstractMatrix{T}}} where {U, T<:Real}","page":"Parallel algorithms","title":"Graphs.Parallel.dijkstra_shortest_paths","text":"Parallel.dijkstra_shortest_paths(g, sources=vertices(g), distmx=weights(g))\n\nCompute the shortest paths between all pairs of vertices in graph g by running [dijkstra_shortest_paths] for every vertex and using an optional list of source vertex sources and an optional distance matrix distmx. Return a Parallel.MultipleDijkstraState with relevant traversal information.\n\n\n\n\n\n","category":"method"},{"location":"advanced/parallel/#Graphs.Parallel.ThreadQueue","page":"Parallel algorithms","title":"Graphs.Parallel.ThreadQueue","text":"ThreadQueue\n\nA thread safe queue implementation for using as the queue for BFS.\n\n\n\n\n\n","category":"type"},{"location":"advanced/parallel/#Graphs.Parallel.bfs_tree!-Union{Tuple{T}, Tuple{Graphs.Parallel.ThreadQueue, AbstractGraph, T, Array{Base.Threads.Atomic{T}}}} where T<:Integer","page":"Parallel algorithms","title":"Graphs.Parallel.bfs_tree!","text":"bfs_tree!(g, src, parents)\n\nProvide a parallel breadth-first traversal of the graph g starting with source vertex s, and return a parents array. The returned array is an Array of Atomic integers.\n\nImplementation Notes\n\nThis function uses @threads for parallelism which depends on the JULIA_NUM_THREADS environment variable to decide the number of threads to use. Refer @threads documentation for more details.\n\n\n\n\n\n","category":"method"},{"location":"advanced/parallel/#Graphs.Parallel.vertex_cover-Union{Tuple{T}, Tuple{AbstractGraph{T}, Integer, RandomVertexCover}} where T<:Integer","page":"Parallel algorithms","title":"Graphs.Parallel.vertex_cover","text":"vertex_cover(g, reps, RandomVertexCover(); parallel=:threads)\n\nPerform Graphs.vertex_cover(g, RandomVertexCover()) reps times in parallel  and return the solution with the fewest vertices.\n\nOptional Arguements\n\nparallel=:threads: If parallel=:distributed then the multiprocessor implementation is\n\nused. This implementation is more efficient if reps is large.\n\n\n\n\n\n","category":"method"},{"location":"core_functions/core/#Core-functions","page":"Core functions","title":"Core functions","text":"","category":"section"},{"location":"core_functions/core/","page":"Core functions","title":"Core functions","text":"Graphs.jl includes the following core functions.","category":"page"},{"location":"core_functions/core/#Index","page":"Core functions","title":"Index","text":"","category":"section"},{"location":"core_functions/core/","page":"Core functions","title":"Core functions","text":"Pages = [\"core.md\"]","category":"page"},{"location":"core_functions/core/#Full-docs","page":"Core functions","title":"Full docs","text":"","category":"section"},{"location":"core_functions/core/","page":"Core functions","title":"Core functions","text":"Modules = [Graphs]\nPages = [\"core.jl\"]\n","category":"page"},{"location":"core_functions/core/#Graphs.AbstractPathState","page":"Core functions","title":"Graphs.AbstractPathState","text":"AbstractPathState\n\nAn abstract type that provides information from shortest paths calculations.\n\n\n\n\n\n","category":"type"},{"location":"core_functions/core/#Graphs.add_vertices!-Tuple{AbstractGraph, Integer}","page":"Core functions","title":"Graphs.add_vertices!","text":"add_vertices!(g, n)\n\nAdd n new vertices to the graph g. Return the number of vertices that were added successfully.\n\nExamples\n\njulia> using Graphs\n\njulia> g = SimpleGraph()\n{0, 0} undirected simple Int64 graph\n\njulia> add_vertices!(g, 2)\n2\n\n\n\n\n\n","category":"method"},{"location":"core_functions/core/#Graphs.all_neighbors","page":"Core functions","title":"Graphs.all_neighbors","text":"all_neighbors(g, v)\n\nReturn a list of all inbound and outbound neighbors of v in g. For undirected graphs, this is equivalent to both outneighbors and inneighbors.\n\nImplementation Notes\n\nReturns a reference to the current graph's internal structures, not a copy. Do not modify result. If the graph is modified, the behavior is undefined: the array behind this reference may be modified too, but this is not guaranteed.\n\nExamples\n\n```jldoctest julia> using Graphs\n\njulia> g = DiGraph(3);\n\njulia> add_edge!(g, 2, 3);\n\njulia> add_edge!(g, 3, 1);\n\njulia> all_neighbors(g, 1) 1-element Array{Int64,1}:  3\n\njulia> all_neighbors(g, 2) 1-element Array{Int64,1}:  3\n\njulia> all_neighbors(g, 3) 2-element Array{Int64,1}:  1  2  ```\n\n\n\n\n\n","category":"function"},{"location":"core_functions/core/#Graphs.common_neighbors-Tuple{AbstractGraph, Integer, Integer}","page":"Core functions","title":"Graphs.common_neighbors","text":"common_neighbors(g, u, v)\n\nReturn the neighbors common to vertices u and v in g.\n\nImplementation Notes\n\nReturns a reference to the current graph's internal structures, not a copy. Do not modify result. If the graph is modified, the behavior is undefined: the array behind this reference may be modified too, but this is not guaranteed.\n\nExamples\n\njulia> using Graphs\n\njulia> g = SimpleGraph(4);\n\njulia> add_edge!(g, 1, 2);\n\njulia> add_edge!(g, 2, 3);\n\njulia> add_edge!(g, 3, 4);\n\njulia> add_edge!(g, 4, 1);\n\njulia> add_edge!(g, 1, 3);\n\njulia> common_neighbors(g, 1, 3)\n2-element Array{Int64,1}:\n 2\n 4\n\njulia> common_neighbors(g, 1, 4)\n1-element Array{Int64,1}:\n 3\n\n\n\n\n\n","category":"method"},{"location":"core_functions/core/#Graphs.degree","page":"Core functions","title":"Graphs.degree","text":"degree(g[, v])\n\nReturn a vector corresponding to the number of edges which start or end at each vertex in graph g. If v is specified, only return degrees for vertices in v. For directed graphs, this value equals the incoming plus outgoing edges. For undirected graphs, it equals the connected edges.\n\nExamples\n\njulia> using Graphs\n\njulia> g = DiGraph(3);\n\njulia> add_edge!(g, 2, 3);\n\njulia> add_edge!(g, 3, 1);\n\njulia> degree(g)\n3-element Array{Int64,1}:\n 1\n 1\n 2\n\n\n\n\n\n","category":"function"},{"location":"core_functions/core/#Graphs.degree_histogram-Union{Tuple{AbstractGraph{T}}, Tuple{T}, Tuple{AbstractGraph{T}, Any}} where T","page":"Core functions","title":"Graphs.degree_histogram","text":"degree_histogram(g, degfn=degree)\n\nReturn a Dict with values representing the number of vertices that have degree represented by the key.\n\nDegree function (for example, indegree or outdegree) may be specified by overriding degfn.\n\n\n\n\n\n","category":"method"},{"location":"core_functions/core/#Graphs.density","page":"Core functions","title":"Graphs.density","text":"density(g)\n\nReturn the density of g. Density is defined as the ratio of the number of actual edges to the number of possible edges (V(V-1) for directed graphs and fracV(V-1)2 for undirected graphs).\n\n\n\n\n\n","category":"function"},{"location":"core_functions/core/#Graphs.has_self_loops-Tuple{AbstractGraph}","page":"Core functions","title":"Graphs.has_self_loops","text":"has_self_loops(g)\n\nReturn true if g has any self loops.\n\nExamples\n\njulia> using Graphs\n\njulia> g = SimpleGraph(2);\n\njulia> add_edge!(g, 1, 2);\n\njulia> has_self_loops(g)\nfalse\n\njulia> add_edge!(g, 1, 1);\n\njulia> has_self_loops(g)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"core_functions/core/#Graphs.indegree-Tuple{AbstractGraph, Integer}","page":"Core functions","title":"Graphs.indegree","text":"indegree(g[, v])\n\nReturn a vector corresponding to the number of edges which end at each vertex in graph g. If v is specified, only return degrees for vertices in v.\n\nExamples\n\njulia> using Graphs\n\njulia> g = DiGraph(3);\n\njulia> add_edge!(g, 2, 3);\n\njulia> add_edge!(g, 3, 1);\n\njulia> indegree(g)\n3-element Array{Int64,1}:\n 1\n 0\n 1\n\n\n\n\n\n","category":"method"},{"location":"core_functions/core/#Graphs.is_ordered-Tuple{AbstractEdge}","page":"Core functions","title":"Graphs.is_ordered","text":"is_ordered(e)\n\nReturn true if the source vertex of edge e is less than or equal to the destination vertex.\n\nExamples\n\njulia> using Graphs\n\njulia> g = DiGraph(2);\n\njulia> add_edge!(g, 2, 1);\n\njulia> is_ordered(first(edges(g)))\nfalse\n\n\n\n\n\n","category":"method"},{"location":"core_functions/core/#Graphs.neighbors-Tuple{AbstractGraph, Integer}","page":"Core functions","title":"Graphs.neighbors","text":"neighbors(g, v)\n\nReturn a list of all neighbors reachable from vertex v in g. For directed graphs, the default is equivalent to outneighbors; use all_neighbors to list inbound and outbound neighbors.\n\nImplementation Notes\n\nReturns a reference to the current graph's internal structures, not a copy. Do not modify result. If the graph is modified, the behavior is undefined: the array behind this reference may be modified too, but this is not guaranteed.\n\nExamples\n\njulia> using Graphs\n\njulia> g = DiGraph(3);\n\njulia> add_edge!(g, 2, 3);\n\njulia> add_edge!(g, 3, 1);\n\njulia> neighbors(g, 1)\n0-element Array{Int64,1}\n\njulia> neighbors(g, 2)\n1-element Array{Int64,1}:\n 3\n\njulia> neighbors(g, 3)\n1-element Array{Int64,1}:\n 1\n\n\n\n\n\n","category":"method"},{"location":"core_functions/core/#Graphs.noallocextreme-NTuple{4, Any}","page":"Core functions","title":"Graphs.noallocextreme","text":"noallocextreme(f, comparison, initial, g)\n\nCompute the extreme value of [f(g,i) for i=i:nv(g)] without gathering them all\n\n\n\n\n\n","category":"method"},{"location":"core_functions/core/#Graphs.num_self_loops-Tuple{AbstractGraph}","page":"Core functions","title":"Graphs.num_self_loops","text":"num_self_loops(g)\n\nReturn the number of self loops in g.\n\nExamples\n\njulia> using Graphs\n\njulia> g = SimpleGraph(2);\n\njulia> add_edge!(g, 1, 2);\n\njulia> num_self_loops(g)\n0\n\njulia> add_edge!(g, 1, 1);\n\njulia> num_self_loops(g)\n1\n\n\n\n\n\n","category":"method"},{"location":"core_functions/core/#Graphs.outdegree-Tuple{AbstractGraph, Integer}","page":"Core functions","title":"Graphs.outdegree","text":"outdegree(g[, v])\n\nReturn a vector corresponding to the number of edges which start at each vertex in graph g. If v is specified, only return degrees for vertices in v.\n\nExamples\n\njulia> using Graphs\n\njulia> g = DiGraph(3);\n\njulia> add_edge!(g, 2, 3);\n\njulia> add_edge!(g, 3, 1);\n\njulia> outdegree(g)\n3-element Array{Int64,1}:\n 0\n 1\n 1\n\n\n\n\n\n","category":"method"},{"location":"core_functions/core/#Graphs.squash-Tuple{AbstractGraph}","page":"Core functions","title":"Graphs.squash","text":"squash(g)\n\nReturn a copy of a graph with the smallest practical eltype that can accommodate all vertices.\n\nMay also return the original graph if the eltype does not change.\n\n\n\n\n\n","category":"method"},{"location":"core_functions/core/#Graphs.weights-Tuple{AbstractGraph}","page":"Core functions","title":"Graphs.weights","text":"weights(g)\n\nReturn the weights of the edges of a graph g as a matrix. Defaults to Graphs.DefaultDistance.\n\nImplementation Notes\n\nIn general, referencing the weight of a nonexistent edge is undefined behavior. Do not rely on the weights matrix as a substitute for the graph's adjacency_matrix.\n\n\n\n\n\n","category":"method"},{"location":"core_functions/core/#Graphs.Δ-Tuple{Any}","page":"Core functions","title":"Graphs.Δ","text":"Δ(g)\n\nReturn the maximum degree of vertices in g.\n\n\n\n\n\n","category":"method"},{"location":"core_functions/core/#Graphs.Δin-Tuple{Any}","page":"Core functions","title":"Graphs.Δin","text":"Δin(g)\n\nReturn the maximum indegree of vertices in g.\n\n\n\n\n\n","category":"method"},{"location":"core_functions/core/#Graphs.Δout-Tuple{Any}","page":"Core functions","title":"Graphs.Δout","text":"Δout(g)\n\nReturn the maximum outdegree of vertices in g.\n\n\n\n\n\n","category":"method"},{"location":"core_functions/core/#Graphs.δ-Tuple{Any}","page":"Core functions","title":"Graphs.δ","text":"δ(g)\n\nReturn the minimum degree of vertices in g.\n\n\n\n\n\n","category":"method"},{"location":"core_functions/core/#Graphs.δin-Tuple{Any}","page":"Core functions","title":"Graphs.δin","text":"δin(g)\n\nReturn the minimum indegree of vertices in g.\n\n\n\n\n\n","category":"method"},{"location":"core_functions/core/#Graphs.δout-Tuple{Any}","page":"Core functions","title":"Graphs.δout","text":"δout(g)\n\nReturn the minimum outdegree of vertices in g.\n\n\n\n\n\n","category":"method"},{"location":"license/#License-information","page":"License information","title":"License information","text":"","category":"section"},{"location":"license/","page":"License information","title":"License information","text":"The Graphs.jl (formerly called LightGraphs.jl) package is licensed under the Simplified \"2-clause\" BSD License:","category":"page"},{"location":"license/","page":"License information","title":"License information","text":"Copyright (c) 2015: Seth Bromberger and other contributors. Copyright (c) 2012: John Myles White and other contributors.","category":"page"},{"location":"license/","page":"License information","title":"License information","text":"Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","category":"page"},{"location":"license/","page":"License information","title":"License information","text":"Graphs uses code derived from and/or inspired by the following package(s):","category":"page"},{"location":"license/","page":"License information","title":"License information","text":"NetworkX:","category":"page"},{"location":"license/","page":"License information","title":"License information","text":"Copyright (C) 2004-2012, NetworkX Developers Aric Hagberg <hagberg@lanl.gov> Dan Schult <dschult@colgate.edu> Pieter Swart <swart@lanl.gov> All rights reserved.Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\nRedistributions in binary form must reproduce the above with the distribution.\nNeither the name of the NetworkX Developers nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","category":"page"},{"location":"algorithms/cut/#Cuts","page":"Cuts","title":"Cuts","text":"","category":"section"},{"location":"algorithms/cut/","page":"Cuts","title":"Cuts","text":"Graphs.jl implements several algorithms for graph cuts.","category":"page"},{"location":"algorithms/cut/#Index","page":"Cuts","title":"Index","text":"","category":"section"},{"location":"algorithms/cut/","page":"Cuts","title":"Cuts","text":"Pages = [\"cut.md\"]","category":"page"},{"location":"algorithms/cut/#Full-docs","page":"Cuts","title":"Full docs","text":"","category":"section"},{"location":"algorithms/cut/","page":"Cuts","title":"Cuts","text":"Modules = [Graphs]\nPages = [\n    \"graphcut/karger_min_cut.jl\",\n    \"graphcut/normalized_cut.jl\",\n]\n","category":"page"},{"location":"algorithms/cut/#Graphs.karger_cut_cost-Union{Tuple{T}, Tuple{AbstractGraph{T}, Vector{<:Integer}}} where T<:Integer","page":"Cuts","title":"Graphs.karger_cut_cost","text":"karger_cut_cost(g, cut)\n\nFind the number of crossing edges in a cut of graph g where the cut is represented by the integer array, cut.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/cut/#Graphs.karger_cut_edges-Union{Tuple{T}, Tuple{AbstractGraph{T}, Vector{<:Integer}}} where T<:Integer","page":"Cuts","title":"Graphs.karger_cut_edges","text":"karger_cut_edges(g, cut)\n\nFind the crossing edges in a cut of graph g where the cut is represented by the integer array, cut.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/cut/#Graphs.karger_min_cut-Union{Tuple{AbstractGraph{T}}, Tuple{T}} where T<:Integer","page":"Cuts","title":"Graphs.karger_min_cut","text":"karger_min_cut(g)\n\nPerform Karger Minimum Cut to find the minimum cut of graph g with some probability of success. A cut is a partition of vertices(g) into two non-empty sets. The size of a cut is the number of edges crossing the two non-empty sets. \n\nImplementation Notes\n\nThe cut is represented by an integer array. If cut[v] == 1 then v is in the first non-empty set. If cut[v] == 2 then v is in the second non-empty set. cut[1] = 1.\n\nIf |V| < 2 then cut[v] = 0 for all v.\n\nPerformance\n\nRuntime: O(|E|) Memory: O(|E|)\n\n\n\n\n\n","category":"method"},{"location":"algorithms/cut/#Graphs.normalized_cut-Union{Tuple{T}, Tuple{AbstractGraph, Real}, Tuple{AbstractGraph, Real, AbstractMatrix{T}}, Tuple{AbstractGraph, Real, AbstractMatrix{T}, Int64}} where T<:Real","page":"Cuts","title":"Graphs.normalized_cut","text":"normalized_cut(g, thres, distmx=weights(g), [num_cuts=10]);\n\nPerform recursive two-way normalized graph-cut on a graph, partitioning the vertices into disjoint sets. Return a vector that contains the set index for each vertex.\n\nIt is important to identify a good threshold for your application. A bisection search over the range (0,1) will help determine a good value of thres.\n\nKeyword Arguments\n\nthres: Subgraphs aren't split if best normalized cut is above this threshold\nnum_cuts: Number of cuts performed to determine optimal cut\n\nReferences\n\n\"Normalized Cuts and Image Segmentation\" - Jianbo Shi and Jitendra Malik\n\n\n\n\n\n","category":"method"},{"location":"algorithms/dominatingset/#Dominating-sets","page":"Dominating sets","title":"Dominating sets","text":"","category":"section"},{"location":"algorithms/dominatingset/","page":"Dominating sets","title":"Dominating sets","text":"Graphs.jl implements functions for dominating sets.","category":"page"},{"location":"algorithms/dominatingset/#Index","page":"Dominating sets","title":"Index","text":"","category":"section"},{"location":"algorithms/dominatingset/","page":"Dominating sets","title":"Dominating sets","text":"Pages = [\"dominatingset.md\"]","category":"page"},{"location":"algorithms/dominatingset/#Full-docs","page":"Dominating sets","title":"Full docs","text":"","category":"section"},{"location":"algorithms/dominatingset/","page":"Dominating sets","title":"Dominating sets","text":"Modules = [Graphs]\nPages = [\n    \"dominatingset/degree_dom_set.jl\",\n    \"dominatingset/minimal_dom_set.jl\",\n]\n","category":"page"},{"location":"algorithms/dominatingset/#Graphs.dominating_set-Union{Tuple{T}, Tuple{AbstractGraph{T}, DegreeDominatingSet}} where T<:Integer","page":"Dominating sets","title":"Graphs.dominating_set","text":"dominating_set(g, DegreeDominatingSet())\n\nObtain a dominating set using a greedy heuristic.\n\nImplementation Notes\n\nA vertex is said to be dominated if it is in the dominating set or adjacent to a vertex  in the dominating set. Initialise the dominating set to an empty set and iteratively choose the vertex that would  dominate the most undominated vertices.\n\nPerformance\n\nRuntime: mathcalO((V+E)*log(V)) Memory: mathcalO(V) Approximation Factor: ln(maximum(degree(g)))+2\n\n\n\n\n\n","category":"method"},{"location":"algorithms/dominatingset/#Graphs.update_dominated!-Union{Tuple{T}, Tuple{AbstractGraph{T}, DataStructures.PriorityQueue, Integer, BitVector, BitVector}} where T<:Integer","page":"Dominating sets","title":"Graphs.update_dominated!","text":"update_dominated!(degree_queue, v, dominated, in_dom_set)\n\nCheck if a vertex is already dominated. If not, make it dominated and update degree_queue by decreasing the priority of the vertices adjacent to v by 1.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/dominatingset/#Graphs.dominating_set-Union{Tuple{T}, Tuple{AbstractGraph{T}, MinimalDominatingSet}} where T<:Integer","page":"Dominating sets","title":"Graphs.dominating_set","text":"dominating_set(g, MinimalDominatingSet(); seed=-1)\n\nFind a set of vertices that consitute a dominating set (all vertices in g are either adjacent to a vertex  in the set or is a vertex in the set) and it is not possible to delete a vertex from the set  without sacrificing the dominating property.\n\nImplementation Notes\n\nInitially, every vertex is in the dominating set. In some random order, we check if the removal of a vertex from the set will destroy the  dominating property. If no, the vertex is removed from the dominating set.\n\nPerformance\n\nRuntime: mathcalO(V+E) Memory: mathcalO(V)\n\nOptional Arguments\n\nIf seed >= 0, a random generator is seeded with this value.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/traversals/#Traversals-and-coloring","page":"Traversals and coloring","title":"Traversals and coloring","text":"","category":"section"},{"location":"algorithms/traversals/","page":"Traversals and coloring","title":"Traversals and coloring","text":"Graphs.jl includes various routines for exploring graphs.","category":"page"},{"location":"algorithms/traversals/#Index","page":"Traversals and coloring","title":"Index","text":"","category":"section"},{"location":"algorithms/traversals/","page":"Traversals and coloring","title":"Traversals and coloring","text":"Pages = [\"traversals.md\"]","category":"page"},{"location":"algorithms/traversals/#Full-docs","page":"Traversals and coloring","title":"Full docs","text":"","category":"section"},{"location":"algorithms/traversals/","page":"Traversals and coloring","title":"Traversals and coloring","text":"Modules = [Graphs]\nPages   = [\n    \"traversals/bfs.jl\",\n    \"traversals/bipartition.jl\",\n    \"traversals/dfs.jl\",\n    \"traversals/diffusion.jl\",\n    \"traversals/greedy_color.jl\",\n    \"traversals/maxadjvisit.jl\",\n    \"traversals/randomwalks.jl\",\n]","category":"page"},{"location":"algorithms/traversals/#Graphs.bfs_parents-Tuple{AbstractGraph, Integer}","page":"Traversals and coloring","title":"Graphs.bfs_parents","text":"bfs_parents(g, s[; dir=:out])\n\nPerform a breadth-first search of graph g starting from vertex s. Return a vector of parent vertices indexed by vertex. If dir is specified, use the corresponding edge direction (:in and :out are acceptable values).\n\nPerformance\n\nThis implementation is designed to perform well on large graphs. There are implementations which are marginally faster in practice for smaller graphs, but the performance improvements using this implementation on large graphs can be significant.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/traversals/#Graphs.bfs_tree-Tuple{AbstractGraph, Integer}","page":"Traversals and coloring","title":"Graphs.bfs_tree","text":"bfs_tree(g, s[; dir=:out])\n\nProvide a breadth-first traversal of the graph g starting with source vertex s, and return a directed acyclic graph of vertices in the order they were discovered. If dir is specified, use the corresponding edge direction (:in and :out are acceptable values).\n\n\n\n\n\n","category":"method"},{"location":"algorithms/traversals/#Graphs.gdistances!-Union{Tuple{T}, Tuple{AbstractGraph{T}, Any, Any}} where T","page":"Traversals and coloring","title":"Graphs.gdistances!","text":"gdistances!(g, source, dists; sort_alg=QuickSort)\n\nFill dists with the geodesic distances of vertices in g from source vertex (or collection of vertices) source. dists should be a vector of length nv(g)  filled with typemax(T). Return dists.\n\nFor vertices in disconnected components the default distance is typemax(T).\n\nAn optional sorting algorithm may be specified (see Performance section).\n\nPerformance\n\ngdistances uses QuickSort internally for its default sorting algorithm, since it performs the best of the algorithms built into Julia Base. However, passing a RadixSort (available via SortingAlgorithms.jl) will provide significant performance improvements on larger graphs.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/traversals/#Graphs.gdistances-Union{Tuple{T}, Tuple{AbstractGraph{T}, Any}} where T","page":"Traversals and coloring","title":"Graphs.gdistances","text":"gdistances(g, source; sort_alg=QuickSort)\n\nReturn a vector filled with the geodesic distances of vertices in  g from source. If source is a collection of vertices each element should be unique. For vertices in disconnected components the default distance is typemax(T).\n\nAn optional sorting algorithm may be specified (see Performance section).\n\nPerformance\n\ngdistances uses QuickSort internally for its default sorting algorithm, since it performs the best of the algorithms built into Julia Base. However, passing a RadixSort (available via SortingAlgorithms.jl) will provide significant performance improvements on larger graphs.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/traversals/#Graphs.has_path-Union{Tuple{T}, Tuple{AbstractGraph{T}, Integer, Integer}} where T","page":"Traversals and coloring","title":"Graphs.has_path","text":"has_path(g::AbstractGraph, u, v; exclude_vertices=Vector())\n\nReturn true if there is a path from u to v in g (while avoiding vertices in exclude_vertices) or u == v. Return false if there is no such path or if u or v is in excluded_vertices. \n\n\n\n\n\n","category":"method"},{"location":"algorithms/traversals/#Graphs.tree-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T<:Integer","page":"Traversals and coloring","title":"Graphs.tree","text":"tree(parents)\n\nConvert a parents array into a directed graph.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/traversals/#Graphs.bipartite_map-Union{Tuple{AbstractGraph{T}}, Tuple{T}} where T","page":"Traversals and coloring","title":"Graphs.bipartite_map","text":"bipartite_map(g) -> Vector{UInt8}\n\nFor a bipartite graph g, return a vector c of size V containing the assignment of each vertex to one of the two sets (c_i == 1 or c_i == 2). If g is not bipartite, return an empty vector.\n\nImplementation Notes\n\nNote that an empty vector does not necessarily indicate non-bipartiteness. An empty graph will return an empty vector but is bipartite.\n\nExamples\n\njulia> using Graphs\n\njulia> g = SimpleGraph(3);\n\njulia> bipartite_map(g)\n3-element Array{UInt8,1}:\n 0x01\n 0x01\n 0x01\n\njulia> add_vertices!(g, 3);\n\njulia> add_edge!(g, 1, 2);\n\njulia> add_edge!(g, 2, 3);\n\njulia> bipartite_map(g)\n3-element Array{UInt8,1}:\n 0x01\n 0x02\n 0x01\n\n\n\n\n\n","category":"method"},{"location":"algorithms/traversals/#Graphs.is_bipartite-Tuple{AbstractGraph}","page":"Traversals and coloring","title":"Graphs.is_bipartite","text":"is_bipartite(g)\n\nReturn true if graph g is bipartite.\n\nExamples\n\njulia> using Graphs\n\njulia> g = SimpleGraph(3);\n\njulia> add_edge!(g, 1, 2);\n\njulia> add_edge!(g, 2, 3);\n\njulia> is_bipartite(g)\ntrue\n\njulia> add_edge!(g, 1, 3);\n\njulia> is_bipartite(g)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"algorithms/traversals/#Graphs.dfs_parents-Tuple{AbstractGraph, Integer}","page":"Traversals and coloring","title":"Graphs.dfs_parents","text":"dfs_parents(g, s[; dir=:out])\n\nPerform a depth-first search of graph g starting from vertex s. Return a vector of parent vertices indexed by vertex. If dir is specified, use the corresponding edge direction (:in and :out are acceptable values).\n\nImplementation Notes\n\nThis version of DFS is iterative.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/traversals/#Graphs.dfs_tree-Tuple{AbstractGraph, Integer}","page":"Traversals and coloring","title":"Graphs.dfs_tree","text":"dfs_tree(g, s)\n\nReturn an ordered vector of vertices representing a directed acyclic graph based on depth-first traversal of the graph g starting with source vertex s.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/traversals/#Graphs.is_cyclic","page":"Traversals and coloring","title":"Graphs.is_cyclic","text":"is_cyclic(g)\n\nReturn true if graph g contains a cycle.\n\nImplementation Notes\n\nUses DFS.\n\n\n\n\n\n","category":"function"},{"location":"algorithms/traversals/#Graphs.topological_sort_by_dfs","page":"Traversals and coloring","title":"Graphs.topological_sort_by_dfs","text":"topological_sort_by_dfs(g)\n\nReturn a topological sort of a directed graph g as a vector of vertices in topological order.\n\n\n\n\n\n","category":"function"},{"location":"algorithms/traversals/#Graphs.diffusion-Union{Tuple{T}, Tuple{AbstractGraph{T}, Real, Integer}} where T","page":"Traversals and coloring","title":"Graphs.diffusion","text":"diffusion(g, p, n)\n\nRun diffusion simulation on g for n steps with spread probabilities based on p. Return a vector with the set of new vertices reached at each step of the simulation.\n\nOptional Arguments\n\ninitial_infections=sample(vertices(g), 1): A list of vertices that\n\nare infected at the start of the simulation.\n\nwatch=Vector(): While simulation is always run on the full graph,\n\nspecifying watch limits reporting to a specific set of vertices reached during the simulation. If left empty, all vertices will be watched.\n\nnormalize=false: if false, set the probability of spread from a vertex i to\n\neach of the outneighbors of i to p. If true, set the probability of spread from a vertex i to each of the outneighbors of i to fracpoutdegreee(g i).\n\nrng=GLOBAL_RNG: A random generator to sample from\n\n\n\n\n\n","category":"method"},{"location":"algorithms/traversals/#Graphs.diffusion_rate-Union{Tuple{Array{Vector{T}, 1}}, Tuple{T}} where T<:Integer","page":"Traversals and coloring","title":"Graphs.diffusion_rate","text":"diffusion_rate(results)\ndiffusion_rate(g, p, n; ...)\n\nGiven the results of a diffusion output or the parameters to the diffusion simulation itself, (run and) return the rate of diffusion as a vector representing the cumulative number of vertices infected at each simulation step, restricted to vertices included in watch, if specified.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/traversals/#Graphs.Coloring","page":"Traversals and coloring","title":"Graphs.Coloring","text":"struct Coloring{T}\n\nStore the number of colors used and mapping from vertex to color\n\n\n\n\n\n","category":"type"},{"location":"algorithms/traversals/#Graphs.degree_greedy_color-Union{Tuple{AbstractGraph{T}}, Tuple{T}} where T<:Integer","page":"Traversals and coloring","title":"Graphs.degree_greedy_color","text":"degree_greedy_color(g)\n\nColor graph g iteratively in the descending order of the degree of the vertices.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/traversals/#Graphs.greedy_color-Union{Tuple{AbstractGraph{U}}, Tuple{U}} where U<:Integer","page":"Traversals and coloring","title":"Graphs.greedy_color","text":"greedy_color(g; sort_degree=false, reps = 1)\n\nColor graph g based on Greedy Coloring Heuristics\n\nThe heuristics can be described as choosing a permutation of the vertices and assigning the lowest color index available iteratively in that order.\n\nIf sort_degree is true then the permutation is chosen in reverse sorted order of the degree of the vertices. parallel and reps are irrelevant in this case.\n\nIf sort_degree is false then reps colorings are obtained based on random permutations and the one using least colors is chosen.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/traversals/#Graphs.perm_greedy_color-Union{Tuple{T}, Tuple{AbstractGraph, Vector{T}}} where T<:Integer","page":"Traversals and coloring","title":"Graphs.perm_greedy_color","text":"perm_greedy_color(g, seq)\n\nColor graph g according to an order specified by seq using a greedy heuristic. seq[i] = v implies that vertex v is the i^th vertex to be colored.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/traversals/#Graphs.random_greedy_color-Union{Tuple{T}, Tuple{AbstractGraph{T}, Integer}} where T<:Integer","page":"Traversals and coloring","title":"Graphs.random_greedy_color","text":"random_greedy_color(g, reps)\n\nColor the graph g iteratively in a random order using a greedy heuristic and choose the best coloring out of reps such random colorings.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/traversals/#Graphs.maximum_adjacency_visit-Union{Tuple{T}, Tuple{U}, Tuple{AbstractGraph{U}, AbstractMatrix{T}}, Tuple{AbstractGraph{U}, AbstractMatrix{T}, Bool}, Tuple{AbstractGraph{U}, AbstractMatrix{T}, Bool, IO}, Tuple{AbstractGraph{U}, AbstractMatrix{T}, Bool, IO, U}} where {U, T<:Real}","page":"Traversals and coloring","title":"Graphs.maximum_adjacency_visit","text":"maximum_adjacency_visit(g[, distmx][, log][, io][, s])\nmaximum_adjacency_visit(g[, s])\n\nReturn the vertices in g traversed by maximum adjacency search, optionally starting from vertex s (default 1). An optional distmx matrix may be specified; if omitted, edge distances are assumed to be 1. If log (default false) is true, visitor events will be printed to io, which defaults to STDOUT; otherwise, no event information will be displayed.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/traversals/#Graphs.mincut-Union{Tuple{AbstractGraph}, Tuple{T}, Tuple{AbstractGraph, AbstractMatrix{T}}} where T<:Real","page":"Traversals and coloring","title":"Graphs.mincut","text":"mincut(g, distmx=weights(g))\n\nReturn a tuple (parity, bestcut), where parity is a vector of integer values that determines the partition in g (1 or 2) and bestcut is the weight of the cut that makes this partition. An optional distmx matrix may be specified; if omitted, edge distances are assumed to be 1.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/traversals/#Graphs.non_backtracking_randomwalk","page":"Traversals and coloring","title":"Graphs.non_backtracking_randomwalk","text":"non_backtracking_randomwalk(g, s, niter; seed=-1)\n\nPerform a non-backtracking random walk on directed graph g starting at vertex s and continuing for a maximum of niter steps. Return a vector of vertices visited in order.\n\n\n\n\n\n","category":"function"},{"location":"algorithms/traversals/#Graphs.randomwalk-Union{Tuple{AG}, Tuple{T}, Tuple{AG, Integer, Integer}} where {T, AG<:AbstractGraph{T}}","page":"Traversals and coloring","title":"Graphs.randomwalk","text":"randomwalk(g, s, niter; seed=-1)\n\nPerform a random walk on graph g starting at vertex s and continuing for a maximum of niter steps. Return a vector of vertices visited in order.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/traversals/#Graphs.self_avoiding_walk-Union{Tuple{AG}, Tuple{T}, Tuple{AG, Integer, Integer}} where {T, AG<:AbstractGraph{T}}","page":"Traversals and coloring","title":"Graphs.self_avoiding_walk","text":"self_avoiding_walk(g, s, niter; seed=-1)\n\nPerform a self-avoiding walk on graph g starting at vertex s and continuing for a maximum of niter steps. Return a vector of vertices visited in order.\n\n\n\n\n\n","category":"method"},{"location":"core_functions/interface/#AbstractGraph-interface","page":"AbstractGraph interface","title":"AbstractGraph interface","text":"","category":"section"},{"location":"core_functions/interface/","page":"AbstractGraph interface","title":"AbstractGraph interface","text":"Graphs.jl defines the AbstractGraph interface for compatibility with external graph formats.","category":"page"},{"location":"core_functions/interface/#Index","page":"AbstractGraph interface","title":"Index","text":"","category":"section"},{"location":"core_functions/interface/","page":"AbstractGraph interface","title":"AbstractGraph interface","text":"Pages   = [\"interface.md\"]","category":"page"},{"location":"core_functions/interface/#Full-docs","page":"AbstractGraph interface","title":"Full docs","text":"","category":"section"},{"location":"core_functions/interface/","page":"AbstractGraph interface","title":"AbstractGraph interface","text":"Modules = [Graphs]\nPages   = [\"interface.jl\"]\n","category":"page"},{"location":"core_functions/interface/#Graphs.AbstractEdge","page":"AbstractGraph interface","title":"Graphs.AbstractEdge","text":"AbstractEdge\n\nAn abstract type representing a single edge between two vertices of a graph.\n\n\n\n\n\n","category":"type"},{"location":"core_functions/interface/#Graphs.AbstractEdgeIter","page":"AbstractGraph interface","title":"Graphs.AbstractEdgeIter","text":"AbstractEdgeIter\n\nAn abstract type representing an edge iterator.\n\n\n\n\n\n","category":"type"},{"location":"core_functions/interface/#Graphs.AbstractGraph","page":"AbstractGraph interface","title":"Graphs.AbstractGraph","text":"AbstractGraph\n\nAn abstract type representing a graph.\n\n\n\n\n\n","category":"type"},{"location":"core_functions/interface/#Graphs.NotImplementedError","page":"AbstractGraph interface","title":"Graphs.NotImplementedError","text":"NotImplementedError{M}(m)\n\nException thrown when a method from the AbstractGraph interface is not implemented by a given graph type.\n\n\n\n\n\n","category":"type"},{"location":"core_functions/interface/#Base.eltype-Tuple{AbstractGraph}","page":"AbstractGraph interface","title":"Base.eltype","text":"eltype(g)\n\nReturn the type of the graph's vertices (must be <: Integer)\n\n\n\n\n\n","category":"method"},{"location":"core_functions/interface/#Base.reverse-Tuple{AbstractEdge}","page":"AbstractGraph interface","title":"Base.reverse","text":"reverse(e)\n\nCreate a new edge from e with source and destination vertices reversed.\n\nExamples\n\njulia> using Graphs\n\njulia> g = SimpleDiGraph(2);\n\njulia> add_edge!(g, 1, 2);\n\njulia> reverse(first(edges(g)))\nEdge 2 => 1\n\n\n\n\n\n","category":"method"},{"location":"core_functions/interface/#Base.zero-Tuple{Type{<:AbstractGraph}}","page":"AbstractGraph interface","title":"Base.zero","text":"zero(G)\n\nReturn a zero-vertex, zero-edge version of the graph type G. The fallback is defined for graph values zero(g::G) = zero(G).\n\nExamples\n\njulia> g = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);\n\njulia> zero(typeof(g))\n{0, 0} directed simple Int64 graph\n\njulia> zero(g)\n{0, 0} directed simple Int64 graph\n\n\n\n\n\n","category":"method"},{"location":"core_functions/interface/#Graphs.dst-Tuple{AbstractEdge}","page":"AbstractGraph interface","title":"Graphs.dst","text":"dst(e)\n\nReturn the destination vertex of edge e.\n\nExamples\n\njulia> using Graphs\n\njulia> g = SimpleGraph(2);\n\njulia> add_edge!(g, 1, 2);\n\njulia> dst(first(edges(g)))\n2\n\n\n\n\n\n","category":"method"},{"location":"core_functions/interface/#Graphs.edges-Tuple{Any}","page":"AbstractGraph interface","title":"Graphs.edges","text":"edges(g)\n\nReturn (an iterator to or collection of) the edges of a graph. For AbstractSimpleGraphs it returns a SimpleEdgeIter. The expressions e in edges(g) and e ∈ edges(ga) evaluate as calls to has_edge.\n\nImplementation Notes\n\nA returned iterator is valid for one pass over the edges, and is invalidated by changes to g.\n\nExamples\n\njulia> using Graphs\n\njulia> g = path_graph(3);\n\njulia> collect(edges(g))\n2-element Array{Graphs.SimpleGraphs.SimpleEdge{Int64},1}:\n Edge 1 => 2\n Edge 2 => 3\n\n\n\n\n\n","category":"method"},{"location":"core_functions/interface/#Graphs.edgetype-Tuple{AbstractGraph}","page":"AbstractGraph interface","title":"Graphs.edgetype","text":"edgetype(g)\n\nReturn the type of graph g's edge\n\n\n\n\n\n","category":"method"},{"location":"core_functions/interface/#Graphs.has_edge-Tuple{Any, Any, Any}","page":"AbstractGraph interface","title":"Graphs.has_edge","text":"has_edge(g, s, d)\n\nReturn true if the graph g has an edge from node s to node d.\n\nAn optional has_edge(g, e) can be implemented to check if an edge belongs to a graph, including any data other than source and destination node.\n\ne ∈ edges(g) or e ∈ edges(g) evaluate as calls to has_edge, c.f. edges.\n\nExamples\n\njulia> using Graphs\n\njulia> g = SimpleDiGraph(2);\n\njulia> add_edge!(g, 1, 2);\n\njulia> has_edge(g, 1, 2)\ntrue\n\njulia> has_edge(g, 2, 1)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"core_functions/interface/#Graphs.has_vertex-Tuple{Any, Any}","page":"AbstractGraph interface","title":"Graphs.has_vertex","text":"has_vertex(g, v)\n\nReturn true if v is a vertex of g.\n\nExamples\n\njulia> using Graphs\n\njulia> has_vertex(SimpleGraph(2), 1)\ntrue\n\njulia> has_vertex(SimpleGraph(2), 3)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"core_functions/interface/#Graphs.inneighbors-Tuple{Any, Any}","page":"AbstractGraph interface","title":"Graphs.inneighbors","text":"inneighbors(g, v)\n\nReturn a list of all neighbors connected to vertex v by an incoming edge.\n\nImplementation Notes\n\nReturns a reference to the current graph's internal structures, not a copy. Do not modify result. If the graph is modified, the behavior is undefined: the array behind this reference may be modified too, but this is not guaranteed.\n\nExamples\n\njulia> g = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);\n\njulia> inneighbors(g, 4)\n2-element Array{Int64,1}:\n 3\n 5\n\n\n\n\n\n","category":"method"},{"location":"core_functions/interface/#Graphs.is_directed-Tuple{G} where G","page":"AbstractGraph interface","title":"Graphs.is_directed","text":"is_directed(G)\n\nReturn true if the graph type G is a directed graph; false otherwise. New graph types must implement is_directed(::Type{<:G}). The method can also be called with is_directed(g::G)\n\nExamples\n\njulia> using Graphs\n\njulia> is_directed(SimpleGraph(2))\nfalse\n\njulia> is_directed(SimpleGraph)\nfalse\n\njulia> is_directed(SimpleDiGraph(2))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"core_functions/interface/#Graphs.ne-Tuple{AbstractGraph}","page":"AbstractGraph interface","title":"Graphs.ne","text":"ne(g)\n\nReturn the number of edges in g.\n\nExamples\n\njulia> using Graphs\n\njulia> g = path_graph(3);\n\njulia> ne(g)\n2\n\n\n\n\n\n","category":"method"},{"location":"core_functions/interface/#Graphs.nv-Tuple{AbstractGraph}","page":"AbstractGraph interface","title":"Graphs.nv","text":"nv(g)\n\nReturn the number of vertices in g.\n\nExamples\n\njulia> using Graphs\n\njulia> nv(SimpleGraph(3))\n3\n\n\n\n\n\n","category":"method"},{"location":"core_functions/interface/#Graphs.outneighbors-Tuple{Any, Any}","page":"AbstractGraph interface","title":"Graphs.outneighbors","text":"outneighbors(g, v)\n\nReturn a list of all neighbors connected to vertex v by an outgoing edge.\n\nImplementation Notes\n\nReturns a reference to the current graph's internal structures, not a copy. Do not modify result. If the graph is modified, the behavior is undefined: the array behind this reference may be modified too, but this is not guaranteed.\n\nExamples\n\njulia> g = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);\n\njulia> outneighbors(g, 4)\n1-element Array{Int64,1}:\n 5\n\n\n\n\n\n","category":"method"},{"location":"core_functions/interface/#Graphs.src-Tuple{AbstractEdge}","page":"AbstractGraph interface","title":"Graphs.src","text":"src(e)\n\nReturn the source vertex of edge e.\n\nExamples\n\njulia> using Graphs\n\njulia> g = SimpleGraph(2);\n\njulia> add_edge!(g, 1, 2);\n\njulia> src(first(edges(g)))\n1\n\n\n\n\n\n","category":"method"},{"location":"core_functions/interface/#Graphs.vertices-Tuple{AbstractGraph}","page":"AbstractGraph interface","title":"Graphs.vertices","text":"vertices(g)\n\nReturn (an iterator to or collection of) the vertices of a graph.\n\nImplementation Notes\n\nA returned iterator is valid for one pass over the edges, and is invalidated by changes to g.\n\nExamples\n\njulia> using Graphs\n\njulia> collect(vertices(SimpleGraph(4)))\n4-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n\n\n\n\n\n","category":"method"},{"location":"core_functions/interface/","page":"AbstractGraph interface","title":"AbstractGraph interface","text":"zero(::Type{<:AbstractGraph})","category":"page"},{"location":"core_functions/interface/#Base.zero-Tuple{Type{<:AbstractGraph}}-2","page":"AbstractGraph interface","title":"Base.zero","text":"zero(G)\n\nReturn a zero-vertex, zero-edge version of the graph type G. The fallback is defined for graph values zero(g::G) = zero(G).\n\nExamples\n\njulia> g = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);\n\njulia> zero(typeof(g))\n{0, 0} directed simple Int64 graph\n\njulia> zero(g)\n{0, 0} directed simple Int64 graph\n\n\n\n\n\n","category":"method"},{"location":"core_functions/module/#Module","page":"Module","title":"Module","text":"","category":"section"},{"location":"core_functions/module/","page":"Module","title":"Module","text":"Graphs.jl has some module-level definitions.","category":"page"},{"location":"core_functions/module/#Index","page":"Module","title":"Index","text":"","category":"section"},{"location":"core_functions/module/","page":"Module","title":"Module","text":"Pages = [\"module.md\"]","category":"page"},{"location":"core_functions/module/#Full-docs","page":"Module","title":"Full docs","text":"","category":"section"},{"location":"core_functions/module/","page":"Module","title":"Module","text":"Modules = [Graphs]\nPages = [\"Graphs.jl\"]\n","category":"page"},{"location":"core_functions/module/#Graphs.Graphs","page":"Module","title":"Graphs.Graphs","text":"Graphs\n\nAn optimized graphs package.\n\nSimple graphs (not multi- or hypergraphs) are represented in a memory- and time-efficient manner with adjacency lists and edge sets. Both directed and undirected graphs are supported via separate types, and conversion is available from directed to undirected.\n\nThe project goal is to mirror the functionality of robust network and graph analysis libraries such as NetworkX while being simpler to use and more efficient than existing Julian graph libraries such as Graphs.jl. It is an explicit design decision that any data not required for graph manipulation (attributes and other information, for example) is expected to be stored outside of the graph structure itself. Such data lends itself to storage in more traditional and better-optimized mechanisms.\n\nFull documentation is available, and tutorials are available at the JuliaGraphsTutorials repository.\n\n\n\n\n\n","category":"module"},{"location":"core_functions/module/#Graphs.DiGraph","page":"Module","title":"Graphs.DiGraph","text":"DiGraph\n\nA datastruture representing a directed graph.\n\n\n\n\n\n","category":"type"},{"location":"core_functions/module/#Graphs.Edge","page":"Module","title":"Graphs.Edge","text":"Edge\n\nA datastruture representing an edge between two vertices in a Graph or DiGraph.\n\n\n\n\n\n","category":"type"},{"location":"core_functions/module/#Graphs.Graph","page":"Module","title":"Graphs.Graph","text":"Graph\n\nA datastruture representing an undirected graph.\n\n\n\n\n\n","category":"type"},{"location":"#Graphs.jl","page":"Graphs.jl","title":"Graphs.jl","text":"","category":"section"},{"location":"","page":"Graphs.jl","title":"Graphs.jl","text":"(Image: Build Status) (Image: codecov.io) (Image: )","category":"page"},{"location":"#Overview","page":"Graphs.jl","title":"Overview","text":"","category":"section"},{"location":"","page":"Graphs.jl","title":"Graphs.jl","text":"The goal of Graphs.jl is to offer a performant platform for network and graph analysis in Julia, following the example of libraries such as NetworkX in Python. To this end, Graphs.jl offers:","category":"page"},{"location":"","page":"Graphs.jl","title":"Graphs.jl","text":"a set of simple, concrete graph implementations – SimpleGraph (for undirected graphs) and SimpleDiGraph (for directed graphs)\nan API for the development of more sophisticated graph implementations under the AbstractGraph type\na large collection of graph algorithms with the same requirements as this API.","category":"page"},{"location":"#Installation","page":"Graphs.jl","title":"Installation","text":"","category":"section"},{"location":"","page":"Graphs.jl","title":"Graphs.jl","text":"Installation is straightforward. First, enter Pkg mode by hitting ], and then run the following command:","category":"page"},{"location":"","page":"Graphs.jl","title":"Graphs.jl","text":"pkg> add Graphs","category":"page"},{"location":"#Basic-use","page":"Graphs.jl","title":"Basic use","text":"","category":"section"},{"location":"","page":"Graphs.jl","title":"Graphs.jl","text":"Graphs.jl includes numerous convenience functions for generating graphs, such as path_graph, which builds a simple undirected path graph of a given length. Once created, these graphs can be easily interrogated and modified.","category":"page"},{"location":"","page":"Graphs.jl","title":"Graphs.jl","text":"julia> g = path_graph(6)\n{6, 5} undirected simple Int64 graph\n\n# Number of vertices\njulia> nv(g)\n6\n\n# Number of edges\njulia> ne(g)\n5\n\n# Add an edge to make the path a loop\njulia> add_edge!(g, 1, 6);","category":"page"},{"location":"#Documentation","page":"Graphs.jl","title":"Documentation","text":"","category":"section"},{"location":"","page":"Graphs.jl","title":"Graphs.jl","text":"The full documentation is available at GitHub Pages. Documentation for methods is also available via the Julia REPL help system. Additional tutorials can be found at JuliaGraphsTutorials.","category":"page"},{"location":"#Citing","page":"Graphs.jl","title":"Citing","text":"","category":"section"},{"location":"","page":"Graphs.jl","title":"Graphs.jl","text":"We encourage you to cite our work if you have used our libraries, tools or datasets. Starring the Graphs.jl repository on GitHub is also appreciated.","category":"page"},{"location":"","page":"Graphs.jl","title":"Graphs.jl","text":"The latest citation information may be found in the CITATION.bib file within the repository.","category":"page"},{"location":"#Contributing","page":"Graphs.jl","title":"Contributing","text":"","category":"section"},{"location":"","page":"Graphs.jl","title":"Graphs.jl","text":"We welcome contributions and bug reports! Please see CONTRIBUTING.md for guidance on development and bug reporting.","category":"page"},{"location":"","page":"Graphs.jl","title":"Graphs.jl","text":"JuliaGraphs development subscribes to the Julia Community Standards.","category":"page"},{"location":"#Related-packages","page":"Graphs.jl","title":"Related packages","text":"","category":"section"},{"location":"","page":"Graphs.jl","title":"Graphs.jl","text":"It is an explicit design decision that any data not required for graph manipulation (attributes and other information, for example) is expected to be stored outside of the graph structure itself.","category":"page"},{"location":"","page":"Graphs.jl","title":"Graphs.jl","text":"Additional functionality like advanced IO and file formats, weighted graphs, property graphs, and optimization-related functions can be found in the packages of the JuliaGraphs organization.","category":"page"},{"location":"#Project-status","page":"Graphs.jl","title":"Project status","text":"","category":"section"},{"location":"","page":"Graphs.jl","title":"Graphs.jl","text":"The Graphs.jl project is a reboot of the LightGraphs.jl package (archived in October 2021), which remains available on GitHub at sbromberger/LightGraphs.jl. If you don't need any new features developed since the fork, you can continue to use older versions of LightGraphs.jl indefinitely. New versions will be released here using the name Graphs.jl instead of LightGraphs.jl. There was an older package also called Graphs.jl. The source history and versions are still available in this repository, but the current code base is unrelated to the old Graphs.jl code and is derived purely from LightGraphs.jl. To access the history of the old Graphs.jl code, you can start from commit 9a25019.","category":"page"},{"location":"#Transition-from-LightGraphs-to-Graphs","page":"Graphs.jl","title":"Transition from LightGraphs to Graphs","text":"","category":"section"},{"location":"","page":"Graphs.jl","title":"Graphs.jl","text":"LightGraphs.jl and Graphs.jl are functionally identical, still there are some steps involved making the change:","category":"page"},{"location":"","page":"Graphs.jl","title":"Graphs.jl","text":"Change LightGraphs = \"093fc24a-ae57-5d10-9952-331d41423f4d\" to Graphs = \"86223c79-3864-5bf0-83f7-82e725a168b6\" in your Project.toml.\nUpdate your using and import statements.\nUpdate your type constraints and other references to LightGraphs to Graphs.\nIncrement your version number. Following semantic versioning, we suggest a patch release when no graphs or other Graphs.jl-objects can be passed through the API of your package by those depending on it, otherwise consider it a breaking release. \"Passed through\" entails created outside and consumed inside your package and vice versa.\nTag a release.","category":"page"},{"location":"#About-versions","page":"Graphs.jl","title":"About versions","text":"","category":"section"},{"location":"","page":"Graphs.jl","title":"Graphs.jl","text":"The master branch of Graphs.jl is generally designed to work with versions of Julia starting from the LTS release all the way to the current stable release, except during Julia version increments as we transition to the new version.\nLater versions: Some functionality might not work with prerelease / unstable / nightly versions of Julia. If you run into a problem, please file an issue.\nThe project was previously developed under the name LightGraphs.jl and older versions of LightGraphs.jl (≤ v1.3.5) must still be used with that name.\nThere was also an older package also called Graphs.jl (git tags v0.2.5 through v0.10.3), but the current code base here is a fork of LightGraphs.jl v1.3.5.\nAll older LightGraphs.jl versions are tagged using the naming scheme lg-vX.Y.Z rather than plain vX.Y.Z, which is used for old Graphs.jl versions (≤ v0.10) and newer versions derived from LightGraphs.jl but released with the Graphs.jl name (≥ v1.4).\nIf you are using a version of Julia prior to 1.x, then you should use LightGraphs.jl at lg-v.12.* or Graphs.jl at v0.10.3","category":"page"},{"location":"algorithms/steinertree/#Steiner-tree","page":"Steiner tree","title":"Steiner tree","text":"","category":"section"},{"location":"algorithms/steinertree/","page":"Steiner tree","title":"Steiner tree","text":"Graphs.jl provides some functionalities related to Steiner Trees.","category":"page"},{"location":"algorithms/steinertree/#Index","page":"Steiner tree","title":"Index","text":"","category":"section"},{"location":"algorithms/steinertree/","page":"Steiner tree","title":"Steiner tree","text":"Pages = [\"steinertree.md\"]","category":"page"},{"location":"algorithms/steinertree/#Full-docs","page":"Steiner tree","title":"Full docs","text":"","category":"section"},{"location":"algorithms/steinertree/","page":"Steiner tree","title":"Steiner tree","text":"Modules = [Graphs]\nPages = [\n    \"steinertree/steiner_tree.jl\",\n]\n","category":"page"},{"location":"algorithms/steinertree/#Graphs.filter_non_term_leaves!-Union{Tuple{T}, Tuple{AbstractGraph{T}, Vector{<:Integer}}} where T<:Integer","page":"Steiner tree","title":"Graphs.filter_non_term_leaves!","text":"filter_non_term_leaves!(g, term_vert)\n\nRemove edges of g so that all non-isolated leaves of g are in the set term_vert\n\n\n\n\n\n","category":"method"},{"location":"algorithms/steinertree/#Graphs.steiner_tree","page":"Steiner tree","title":"Graphs.steiner_tree","text":"steiner_tree(g, term_vert, distmx=weights(g))\n\nReturn an approximately minimum steiner tree of connected, undirected graph g with positive edge  weights represented by distmx using Approximate Steiner Tree.  The minimum steiner tree problem involves finding a subset of edges in g of minimum weight such that all the vertices in term_vert are connected.\n\nt = length(term_vert).\n\nPerformance\n\nRuntime: O(t(tlog(t)+|E|log(|V| )) Memory: O(t|V|) Approximation Factor: 2-2/t\n\n\n\n\n\n","category":"function"},{"location":"first_steps/paths_traversal/#Paths-and-traversal","page":"Paths and traversal","title":"Paths and traversal","text":"","category":"section"},{"location":"first_steps/paths_traversal/","page":"Paths and traversal","title":"Paths and traversal","text":"Graphs.jl provides several traversal and shortest-path algorithms, along with various utility functions. Where appropriate, edge distances may be passed in as a matrix of real number values.","category":"page"},{"location":"first_steps/paths_traversal/","page":"Paths and traversal","title":"Paths and traversal","text":"Edge distances for most traversals may be passed in as a sparse or dense matrix of values, indexed by [src,dst] vertices. That is, distmx[2,4] = 2.5 assigns the distance 2.5 to the (directed) edge connecting vertex 2 and vertex 4. Note that for undirected graphs distmx[4,2] also has to be set.","category":"page"},{"location":"first_steps/paths_traversal/","page":"Paths and traversal","title":"Paths and traversal","text":"Default edge distances may be passed in via the Graphs.DefaultDistance structure.","category":"page"},{"location":"first_steps/paths_traversal/","page":"Paths and traversal","title":"Paths and traversal","text":"Any graph traversal will traverse an edge only if it is present in the graph. When a distance matrix is given:","category":"page"},{"location":"first_steps/paths_traversal/","page":"Paths and traversal","title":"Paths and traversal","text":"distance values for undefined edges will be ignored;\nany unassigned values (in sparse distance matrices) for edges that are present in the graph will be assumed to take the default value of 1.0;\nany zero values (in sparse/dense distance matrices) for edges that are present in the graph will instead have an implicit edge cost of 1.0.","category":"page"},{"location":"first_steps/paths_traversal/#Graph-traversal","page":"Paths and traversal","title":"Graph traversal","text":"","category":"section"},{"location":"first_steps/paths_traversal/","page":"Paths and traversal","title":"Paths and traversal","text":"Graph traversal refers to a process that traverses vertices of a graph following certain order (starting from user-input sources). This package implements three traversal schemes:","category":"page"},{"location":"first_steps/paths_traversal/","page":"Paths and traversal","title":"Paths and traversal","text":"BreadthFirst\nDepthFirst\nMaximumAdjacency","category":"page"},{"location":"first_steps/paths_traversal/","page":"Paths and traversal","title":"Paths and traversal","text":"The package also includes uniform random walks and self avoiding walks with the following functions:","category":"page"},{"location":"first_steps/paths_traversal/","page":"Paths and traversal","title":"Paths and traversal","text":"randomwalk\nnon_backtracking_randomwalk\nself_avoiding_walk","category":"page"},{"location":"first_steps/paths_traversal/#Shortest-paths","page":"Paths and traversal","title":"Shortest paths","text":"","category":"section"},{"location":"first_steps/paths_traversal/","page":"Paths and traversal","title":"Paths and traversal","text":"The following properties always hold for shortest path algorithms implemented here:","category":"page"},{"location":"first_steps/paths_traversal/","page":"Paths and traversal","title":"Paths and traversal","text":"The distance from a vertex to itself is always 0.\nThe distance between two vertices with no connecting edge is always Inf or typemax(eltype(distmx)).","category":"page"},{"location":"first_steps/paths_traversal/","page":"Paths and traversal","title":"Paths and traversal","text":"The dijkstra_shortest_paths, desopo_pape_shortest_paths, floyd_warshall_shortest_paths, bellman_ford_shortest_paths, and yen_k_shortest_paths functions return path states (subtypes of Graphs.AbstractPathState) that contain various information about the graph learned during traversal.","category":"page"},{"location":"first_steps/paths_traversal/","page":"Paths and traversal","title":"Paths and traversal","text":"The corresponding state types (with the exception of YenState) have the following common fields:","category":"page"},{"location":"first_steps/paths_traversal/","page":"Paths and traversal","title":"Paths and traversal","text":"state.dists holds a vector with the distances computed, indexed by source vertex.\nstate.parents holds a vector of parents of each vertex on the shortest paths (the parent of a source vertex is always 0). YenState substitutes .paths for .parents.","category":"page"},{"location":"first_steps/paths_traversal/","page":"Paths and traversal","title":"Paths and traversal","text":"In addition, with the appropriate optional arguments, dijkstra_shortest_paths will return information on all possible shortest paths available from the source.","category":"page"}]
}
